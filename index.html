
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>
      Multi-Agent Interactive Chain Demo
      (Auto-Run, Terminal, Folders, Drag/Drop, Diff/Version, Autosave, Import Orgs)
    </title>

    <!-- React + ReactDOM + Babel (Updated to v7 for modern JS syntax) -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

    <!-- Material UI (UMD) -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/@mui/material@5.13.7/umd/material-ui.development.js"></script>
    <script src="https://unpkg.com/@emotion/react@11.10.8/dist/emotion-react.umd.min.js"></script>
    <script src="https://unpkg.com/@emotion/styled@11.10.8/dist/emotion-styled.umd.min.js"></script>

    <!-- CodeMirror 5 -->
    <script src="https://unpkg.com/codemirror@5.65.9/lib/codemirror.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/codemirror@5.65.9/lib/codemirror.css"
    />
    <!-- Common modes -->
    <script src="https://unpkg.com/codemirror@5.65.9/mode/javascript/javascript.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/mode/css/css.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/mode/xml/xml.js"></script> <!-- XML needed for HTMLMixed -->
    <script src="https://unpkg.com/codemirror@5.65.9/mode/htmlmixed/htmlmixed.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/mode/shell/shell.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/mode/python/python.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/mode/markdown/markdown.js"></script>
    <!-- CodeMirror Dark Theme -->
    <link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.9/theme/material-darker.css">
    <!-- CodeMirror Addons -->
    <script src="https://unpkg.com/codemirror@5.65.9/addon/edit/closebrackets.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/edit/matchbrackets.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/fold/foldcode.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/fold/foldgutter.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.9/addon/fold/foldgutter.css" />
    <script src="https://unpkg.com/codemirror@5.65.9/addon/fold/brace-fold.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/fold/comment-fold.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/fold/xml-fold.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/scroll/annotatescrollbar.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/search/searchcursor.js"></script>
    <script src="https://unpkg.com/codemirror@5.65.9/addon/search/matchesonscrollbar.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/codemirror@5.65.9/addon/search/matchesonscrollbar.css">
    <script src="https://unpkg.com/codemirror@5.65.9/addon/search/match-highlighter.js"></script>



    <!-- jsdiff (for better diffing) -->
    <script src="https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js"></script>

    <!-- Prism.js (for syntax highlighting in chat) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <!-- Prism line numbers (optional, but good for code blocks) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <!-- Prism Toolbar plugin (for copy to clipboard) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" />
    <!-- Prism copy to clipboard button -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <style>
      /* Original Light Mode Styles (will be overridden or co-exist with dark mode) */
      body {
        margin: 0;
        padding: 0;
        font-family: "Roboto", sans-serif;
        transition: background-color 0.3s ease, color 0.3s ease; /* For smooth theme transition */
      }
      /* Default Light theme for body */
      body:not(.dark-mode) {
        background-color: #fff;
        color: #000;
      }
      #root {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        padding-top: 110px; /* Increased space for fixed header */
        position: relative; /* for absolute top-right panel */
      }

      .workspace-container {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 20px;
      }

      .chat-box {
        border: 1px solid #ccc;
        padding: 10px;
        max-height: 400px; /* Increased height */
        overflow-y: auto;
        margin-bottom: 10px;
        background: #fafafa;
      }
      body.dark-mode .chat-box {
        background: var(--card-bg);
        border-color: var(--card-border);
      }

      .chat-msg {
        margin-bottom: 8px;
      }
      .chat-msg strong { /* This might be less used now with styled bubbles */
        margin-right: 5px;
        font-weight: bold;
      }
      .chat-msg h3 { /* Agent ### headings */
        margin: 0.5em 0 0.3em;
        font-size: 1.1em;
      }
      body.dark-mode .chat-msg h3 {
        color: var(--text-heading-glow);
      }
      /* Prism code block styling in chat */
      .chat-code-block {
          position: relative; /* For copy button */
      }
      .chat-code-block pre[class*="language-"] {
          margin: 0.5em 0 !important;
          border-radius: 4px;
          font-size: 0.9em !important;
      }
      /* Ensure Prism copy button is styled well for dark mode */
      body.dark-mode .prism-copy-to-clipboard-button {
          background-color: rgba(200,200,200,0.2) !important;
          color: var(--text-secondary) !important;
          border: 1px solid var(--card-border) !important;
      }
       body.dark-mode .prism-copy-to-clipboard-button:hover {
          background-color: rgba(200,200,200,0.3) !important;
       }


      .preview-section {
        border: 1px solid #ccc;
        margin-top: 10px;
        padding: 10px;
      }
      body.dark-mode .preview-section {
        border-color: var(--card-border);
      }
      .preview-iframe {
        width: 100%;
        height: 300px;
        border: 1px solid #aaa;
        margin-top: 10px;
      }
      body.dark-mode .preview-iframe {
        border-color: var(--card-border);
      }
      .metadata-tags {
        font-size: 0.85em;
        color: #555;
      }
      body.dark-mode .metadata-tags {
        color: var(--text-secondary);
      }

      /* Step reorder arrow buttons */
      .step-reorder-buttons button {
        min-width: 30px;
        padding: 4px 6px;
        margin-right: 5px;
      }

      /* Terminal panel */
      .terminal-panel {
        border: 1px solid #ccc;
        background: #1e1e1e;
        color: #ddd;
        padding: 10px;
        font-family: Consolas, monospace;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap; /* Changed from pre to pre-wrap */
        word-break: break-all; /* Ensure long strings without spaces wrap */
        margin-bottom: 10px;
        border-radius: 4px;
      }
      body.dark-mode .terminal-panel {
         background: #0a0c0f; /* Even darker for contrast */
         border-color: var(--card-border);
         color: var(--text-secondary);
      }

      .terminal-input-box {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
      }
      .terminal-input-box input { /* This is not an MUI component, style directly */
        flex: 1;
        padding: 8px 10px;
        border-radius: 4px;
        font-size: 0.95em;
      }
      body:not(.dark-mode) .terminal-input-box input {
        border: 1px solid #ccc;
        background-color: #fff;
        color: #000;
      }
      body.dark-mode .terminal-input-box input {
        background-color: var(--bg-end);
        border: 1px solid var(--card-border);
        color: var(--text-primary);
      }
      body.dark-mode .terminal-input-box input::placeholder {
        color: var(--text-secondary);
      }


      /* Auto-Run Logs box */
      .auto-run-logs {
        border: 1px solid #ccc;
        background: #fafafa;
        padding: 10px;
        max-height: 300px;
        overflow-y: auto;
        margin-bottom: 10px;
        border-radius: 4px;
      }
      body.dark-mode .auto-run-logs {
        background: var(--card-bg);
        border-color: var(--card-border);
      }
      .auto-run-logs .log-entry {
        margin-bottom: 6px;
        font-size: 0.9em;
      }
      .auto-run-logs .log-entry strong {
        margin-right: 5px;
        color: var(--text-heading-glow); /* Make role stand out */
      }
      body:not(.dark-mode) .auto-run-logs .log-entry strong {
        color: #1976d2; /* MUI primary blue for light mode */
      }


      /* File Explorer / Folders + Draggable styling */
      .file-explorer {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 10px;
        background: #f9f9f9;
        border-radius: 4px;
      }
      body.dark-mode .file-explorer {
        background: var(--card-bg);
        border-color: var(--card-border);
      }
      .folder {
        font-weight: bold;
        cursor: pointer;
      }
      .folder-contents {
        margin-left: 15px;
        padding-left: 10px; /* Indent contents more */
        border-left: 1px dashed var(--card-border);
        margin-top: 5px;
      }
      .draggable-file {
        cursor: move;
      }
      .workspace-drop-zone {
        border: 2px dashed #aaa;
        padding: 20px;
        text-align: center;
        margin: 10px 0;
        border-radius: 8px;
      }
      body.dark-mode .workspace-drop-zone {
        border-color: var(--card-border);
        color: var(--text-secondary);
      }
      .workspace-drop-zone.drag-over {
        background-color: #eef;
        border-color: #00f;
      }
      body.dark-mode .workspace-drop-zone.drag-over {
        background-color: rgba(35, 134, 255, 0.1);
        border-color: var(--text-heading-glow);
      }

      /* Diff styling (jsdiff output) */
      .diff-line {
        white-space: pre-wrap;
        font-family: monospace;
        padding: 2px 5px; /* Add some padding */
        display: block; /* Ensure it takes full width */
      }
      .diff-added {
        background: #e6ffe6;
      }
      body.dark-mode .diff-added {
        background: rgba(0, 255, 0, 0.15); /* Slightly stronger */
        color: #90ee90;
      }
      .diff-removed {
        background: #ffe6e6;
        text-decoration: line-through;
      }
      body.dark-mode .diff-removed {
        background: rgba(255, 0, 0, 0.15); /* Slightly stronger */
        color: #f08080;
        text-decoration: line-through;
      }
      .diff-common { /* For lines that are common */
        /* No specific background needed, inherits from parent */
         opacity: 0.7; /* Make common lines slightly less prominent */
      }
      body.dark-mode .diff-common {
        color: var(--text-secondary);
      }


      /* Pull Request Panel */
      .pr-panel {
        border: 1px solid #ccc;
        background: #fefefe;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
      }
      body.dark-mode .pr-panel {
        background: var(--card-bg);
        border-color: var(--card-border);
      }
      .pr-item {
        border: 1px solid #ccc;
        padding: 10px;
        margin-bottom: 10px;
        background: #fff;
        border-radius: 4px;
      }
      body.dark-mode .pr-item {
        background: var(--bg-end); /* Slightly different from card-bg for nesting */
        border-color: var(--card-border);
      }
      .pr-item-code-block {
        background: #fafafa;
        padding: 5px;
        margin: 5px 0;
        border: 1px dashed #ccc;
        font-family: monospace;
        white-space: pre-wrap;
        border-radius: 4px;
      }
      body.dark-mode .pr-item-code-block {
        background: rgba(13, 17, 23, 0.7);
        border-color: var(--card-border);
        color: var(--text-primary); /* Ensure code text is readable */
      }


      /* Structured Data Panel */
      .structured-panel {
        border: 1px solid #ccc;
        background: #fefefe;
        padding: 10px;
        margin-bottom: 20px;
        border-radius: 4px;
      }
      body.dark-mode .structured-panel {
        background: var(--card-bg);
        border-color: var(--card-border);
      }

      /* Persistent Header */
      #app-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0; /* Use left/right to span full width */
        box-sizing: border-box; /* Ensures padding is included in the total width/height */
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 32px; /* Keep the 32px horizontal padding */
        z-index: 1000;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      body:not(.dark-mode) #app-header {
        background-color: #f8f9fa;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      body.dark-mode #app-header {
        background-color: rgba(13, 17, 23, 0.8); /* var(--bg-end with alpha) */
        backdrop-filter: blur(12px) saturate(150%);
        -webkit-backdrop-filter: blur(12px) saturate(150%);
        border-bottom: 1px solid var(--card-border);
      }

      #app-header .logo-container .logo-svg {
        height: 32px; /* Adjust as needed */
        width: auto;
      }
      #app-header .theme-toggle-container {
        display: flex;
        align-items: center;
      }


      /* NEW DARK MODE STYLES (from user) */
      :root {
          --bg-start: #010409;
          --bg-end: #0D1117;
          --card-bg: rgba(22, 27, 34, 0.7); /* More opaque for readability on dark backgrounds */
          --card-border: rgba(48, 54, 61, 0.6);
          --card-hover-bg: rgba(30, 36, 44, 0.85);
          --text-primary: #C9D1D9;
          --text-secondary: #8B949E;
          --text-heading-glow: #58A6FF; /* For main headings */
          --accent-glow: rgba(35, 134, 255, 0.4);

          /* Logo Colors */
          --logo-c-name: #F778BA;
          --logo-c-not:  #A2D2FB;
          --logo-c-found:#81F0E5;
          --logo-c-dot:  #FFD166;
          --logo-c-ai: #ABF7B1;
          --logo-c-ai-rgb: 171, 247, 177; /* RGB version for rgba() */

          /* Add RGB versions for other colors if used in rgba() for JS theme */
          --logo-c-not-rgb: 162, 210, 251; /* from #A2D2FB */
          --bg-start-rgb: 1, 4, 9;       /* from #010409 */
          --card-bg-rgb: 22, 27, 34;      /* from rgba(22, 27, 34, 0.7) */
      }

      body.dark-mode {
          font-family: 'Inter', sans-serif;
          scroll-behavior: smooth;
          background: linear-gradient(160deg, var(--bg-start) 0%, var(--bg-end) 100%);
          color: var(--text-primary);
          overflow-x: hidden;
          position: relative;
      }

      body.dark-mode::before, body.dark-mode::after {
          content: '';
          position: fixed;
          border-radius: 50%;
          z-index: -2; /* Behind main content and header */
          pointer-events: none;
          animation-timing-function: ease-in-out;
          animation-iteration-count: infinite;
          animation-direction: alternate;
      }
      body.dark-mode::before {
          width: 70vmax; height: 70vmax;
          background: radial-gradient(circle, rgba(35, 134, 255, 0.08) 0%, transparent 60%);
          top: -30vh; left: -30vw;
          animation-name: pulseLarge;
          animation-duration: 20s;
      }
      body.dark-mode::after {
          width: 50vmax; height: 50vmax;
          background: radial-gradient(circle, rgba(88, 166, 255, 0.06) 0%, transparent 65%);
          bottom: -25vh; right: -25vw;
          animation-name: pulseSmall;
          animation-duration: 18s;
          animation-delay: -5s;
      }

      @keyframes pulseLarge {
          0% { transform: scale(0.9) translate(0,0); opacity: 0.04; }
          50% { transform: scale(1.1) translate(5vw, -5vh); opacity: 0.08; }
          100% { transform: scale(0.9) translate(0,0); opacity: 0.04; }
      }
      @keyframes pulseSmall {
          0% { transform: scale(1) translate(0,0); opacity: 0.03; }
          50% { transform: scale(1.2) translate(-5vw, 5vh); opacity: 0.06; }
          100% { transform: scale(1) translate(0,0); opacity: 0.03; }
      }

      .text-gradient-brand, .namenotfoundai-animated {
          background: linear-gradient(120deg, var(--logo-c-name), var(--logo-c-not), var(--logo-c-found), var(--logo-c-dot), var(--logo-c-ai));
          background-size: 250% 250%;
          -webkit-background-clip: text;
          background-clip: text;
          -webkit-text-fill-color: transparent;
          animation: animatedGradientText 8s ease infinite alternate;
      }
      @keyframes animatedGradientText {
          0% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
          100% { background-position: 0% 50%; }
      }

      body.dark-mode .heading-glow {
          text-shadow: 0 0 15px var(--text-heading-glow), 0 0 30px var(--accent-glow);
          color: var(--text-heading-glow);
      }
      body.dark-mode .MuiPaper-root {
        background-color: var(--card-bg) !important;
        color: var(--text-primary) !important;
        border: 1px solid var(--card-border) !important;
        border-radius: 8px !important; /* More rounded corners for Paper */
      }
       body.dark-mode .MuiDialog-paper {
        background-color: var(--bg-end) !important;
        border-radius: 12px !important; /* More rounded dialogs */
      }

      .interactive-card { /* This class can be added to Paper components if desired */
          background: var(--card-bg);
          border: 1px solid var(--card-border);
          backdrop-filter: blur(10px) saturate(120%);
          -webkit-backdrop-filter: blur(10px) saturate(120%);
          border-radius: 0.75rem;
          transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      box-shadow 0.3s ease-out,
                      border-color 0.3s ease-out,
                      background-color 0.3s ease-out;
          display: flex;
          flex-direction: column;
          overflow: hidden;
          position: relative;
      }
      .interactive-card:hover:not(.non-interactive) {
          transform: translateY(-8px) scale(1.01);
          box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.3), 0 0 20px var(--accent-glow);
          border-color: rgba(88, 166, 255, 0.5);
          background: var(--card-hover-bg);
      }

      .logo-svg tspan { transition: fill 0.3s ease; }
      @keyframes cycle-colors-name {
          0%, 100% { fill: var(--logo-c-name); } 20% { fill: var(--logo-c-not); } 40% { fill: var(--logo-c-found); } 60% { fill: var(--logo-c-dot); } 80% { fill: var(--logo-c-ai); }
      }
      @keyframes cycle-colors-not {
          0%, 100% { fill: var(--logo-c-not); } 20% { fill: var(--logo-c-found); } 40% { fill: var(--logo-c-dot); } 60% { fill: var(--logo-c-ai); } 80% { fill: var(--logo-c-name); }
      }
      @keyframes cycle-colors-found {
          0%, 100% { fill: var(--logo-c-found); } 20% { fill: var(--logo-c-dot); } 40% { fill: var(--logo-c-ai); } 60% { fill: var(--logo-c-name); } 80% { fill: var(--logo-c-not); }
      }
      @keyframes cycle-colors-dot {
          0%, 100% { fill: var(--logo-c-dot); } 20% { fill: var(--logo-c-ai); } 40% { fill: var(--logo-c-name); } 60% { fill: var(--logo-c-not); } 80% { fill: var(--logo-c-found); }
      }
      @keyframes cycle-colors-ai {
          0%, 100% { fill: var(--logo-c-ai); } 20% { fill: var(--logo-c-name); } 40% { fill: var(--logo-c-not); } 60% { fill: var(--logo-c-found); } 80% { fill: var(--logo-c-dot); }
      }
      .logo-tspan-name { animation: cycle-colors-name 10s infinite linear; }
      .logo-tspan-not { animation: cycle-colors-not 10s infinite linear 0.4s; }
      .logo-tspan-found { animation: cycle-colors-found 10s infinite linear 0.8s; }
      .logo-tspan-dot { animation: cycle-colors-dot 10s infinite linear 1.2s; }
      .logo-tspan-ai { animation: cycle-colors-ai 10s infinite linear 1.6s; }

      /* CodeMirror styling enhancements */
      .CodeMirror {
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.95em; /* Slightly larger font */
        height: auto; /* For auto-sizing based on content in some cases, or set fixed */
      }
      body.dark-mode .CodeMirror {
        border-color: var(--card-border);
      }
       /* Ensure CodeMirror gutters in dark mode are styled correctly */
      body.dark-mode .CodeMirror-gutters {
        background-color: var(--bg-end) !important; /* Match editor background or slightly darker */
        border-right: 1px solid var(--card-border) !important;
      }
      body.dark-mode .CodeMirror-linenumbers span {
        color: var(--text-secondary) !important;
      }
       body.dark-mode .CodeMirror-foldgutter-open,
       body.dark-mode .CodeMirror-foldgutter-folded {
         color: var(--text-secondary) !important;
       }

    </style>
  </head>

  <body>
    <div id="app-header-container"></div>
    <div id="root"></div>

    <script type="text/babel">
      const { createTheme, ThemeProvider } = MaterialUI;

      // Define light and dark themes for Material UI
      const lightTheme = createTheme({
        palette: {
          mode: 'light',
          primary: { main: '#1976d2' },
          secondary: { main: '#dc004e' },
          background: {
            paper: '#ffffff',
            default: '#f8f9fa', // Lighter default background
          },
          text: {
            primary: '#212121',
            secondary: '#757575'
          }
        },
        shape: {
            borderRadius: 8, // Default border radius for components like Paper, Button
        },
      });

      const darkTheme = createTheme({
        palette: {
          mode: 'dark',
          primary: { main: '#58A6FF' },
          secondary: { main: '#F778BA'},
          background: { // Use direct values that MUI JS can parse
            paper: 'rgba(22, 27, 34, 0.7)', // Value of var(--card-bg)
            default: '#0D1117',           // Value of var(--bg-end)
          },
          text: { // Use direct values that MUI JS can parse
            primary: '#C9D1D9',            // Value of var(--text-primary)
            secondary: '#8B949E',          // Value of var(--text-secondary)
          },
          error: { main: '#f44336' }, // Standard error color
          warning: { main: '#ffa726' }, // Standard warning color
          info: { main: '#29b6f6' }, // Standard info color
          success: { main: '#66bb6a' }, // Standard success color
        },
        shape: {
            borderRadius: 8,
        },
        components: {
            MuiButton: {
                styleOverrides: {
                    root: ({ ownerState, theme }) => ({
                        transition: 'transform 0.1s ease-out, background-color 0.2s ease',
                        '&:active': {
                            transform: 'scale(0.97)',
                        },
                        ...(ownerState.variant === 'contained' && ownerState.color === 'primary' && theme.palette.mode === 'dark' && {
                            background: `linear-gradient(120deg, ${theme.palette.primary.main}, var(--logo-c-not))`,
                            color: '#fff',
                             '&:hover': {
                                background: `linear-gradient(120deg, var(--logo-c-not), ${theme.palette.primary.main})`,
                                // boxShadow: `0 0 15px ${theme.palette.primary.main}80` // Subtle glow
                             }
                        }),
                         ...(ownerState.variant === 'outlined' && ownerState.color === 'primary' && theme.palette.mode === 'dark' && {
                            borderColor: theme.palette.primary.main,
                            color: theme.palette.primary.main,
                            '&:hover': {
                                borderColor: 'var(--logo-c-not)',
                                color: 'var(--logo-c-not)',
                                backgroundColor: MaterialUI.alpha('#A2D2FB', 0.1) // Use MUI's alpha with direct hex
                            }
                         }),
                         ...(ownerState.variant === 'contained' && ownerState.color === 'success' && theme.palette.mode === 'dark' && {
                            backgroundColor: 'var(--logo-c-ai)',
                            color: 'var(--bg-start)',
                             '&:hover': {
                                backgroundColor: '#8fdb93', // A slightly lighter shade of --logo-c-ai
                             }
                         }),
                    }),
                }
            },
            MuiTextField: {
                styleOverrides: {
                    root: ({theme}) => ({
                        '& label.Mui-focused': {
                            color: theme.palette.mode === 'dark' ? 'var(--text-heading-glow)' : theme.palette.primary.main,
                        },
                        '& .MuiOutlinedInput-root': {
                            '&.Mui-focused fieldset': {
                                borderColor: theme.palette.mode === 'dark' ? 'var(--text-heading-glow)' : theme.palette.primary.main,
                            },
                             /* Apply custom background for dark mode TextFields */
                            ...(theme.palette.mode === 'dark' && {
                                backgroundColor: MaterialUI.alpha('#010409', 0.3), // Use MUI's alpha with direct hex (value of --bg-start)
                                '&:hover .MuiOutlinedInput-notchedOutline': {
                                    borderColor: '#8B949E', // Direct value of var(--text-secondary)
                                },
                            }),
                        },

                    }),
                },
            },
            MuiSwitch: {
                 styleOverrides: {
                    track: ({theme}) => ({
                        backgroundColor: theme.palette.mode === 'dark' ? 'var(--text-secondary)' : theme.palette.grey[400],
                    }),
                    switchBase: ({theme}) => ({
                        '&.Mui-checked': {
                            color: theme.palette.mode === 'dark' ? 'var(--logo-c-ai)' : theme.palette.primary.main,
                            '& + .MuiSwitch-track': {
                                backgroundColor: theme.palette.mode === 'dark' ? 'var(--logo-c-ai)' : theme.palette.primary.main,
                                opacity: 0.7,
                            },
                        },
                    }),
                },
            },
             MuiPaper: {
                styleOverrides: {
                    root: ({theme}) => ({
                       ...(theme.palette.mode === 'dark' && {
                            // Already handled by body.dark-mode .MuiPaper-root, but can add more here
                       }),
                       ...(theme.palette.mode === 'light' && {
                            border: '1px solid #e0e0e0', // So light mode papers also have a border
                       }),
                    })
                }
            },
            MuiDialogTitle: {
                styleOverrides: {
                    root: ({theme}) => ({
                       '&.MuiTypography-root': {
                            color: theme.palette.mode === 'dark' ? 'var(--text-heading-glow)' : theme.palette.primary.dark,
                            textShadow: theme.palette.mode === 'dark' ? '0 0 8px var(--accent-glow)' : 'none',
                       }
                    })
                }
            },
            MuiSnackbarContent: { // For global notifications
                styleOverrides: {
                    root: ({theme}) => ({
                        ...(theme.palette.mode === 'dark' && {
                            backgroundColor: 'var(--card-hover-bg)',
                            color: 'var(--text-primary)',
                            border: '1px solid var(--card-border)',
                        }),
                         ...(theme.palette.mode === 'light' && {
                            backgroundColor: theme.palette.primary.light,
                            color: theme.palette.primary.contrastText,
                        }),
                    })
                }
            },
            MuiTooltip: {
                styleOverrides: {
                    tooltip: ({theme}) => ({
                        ...(theme.palette.mode === 'dark' && {
                            backgroundColor: 'var(--card-hover-bg)',
                            color: 'var(--text-primary)',
                            border: `1px solid var(--card-border)`
                        }),
                         ...(theme.palette.mode === 'light' && {
                             backgroundColor: theme.palette.grey[700],
                         }),
                    })
                }
            }
        }
      });

      function Logo() {
        return (
          <svg className="logo-svg" viewBox="0 0 220 30" xmlns="http://www.w3.org/2000/svg">
            <text y="22" fontSize="24" fontFamily="Inter, sans-serif" fontWeight="bold">
              <tspan className="logo-tspan-name" fill="var(--logo-c-name)">name</tspan>
              <tspan className="logo-tspan-not" dx="1" fill="var(--logo-c-not)">not</tspan>
              <tspan className="logo-tspan-found" dx="1" fill="var(--logo-c-found)">found</tspan>
              <tspan className="logo-tspan-dot" dx="1" fill="var(--logo-c-dot)">.</tspan>
              <tspan className="logo-tspan-ai" dx="0.5" fill="var(--logo-c-ai)">ai</tspan>
            </text>
          </svg>
        );
      }

      function AppHeader({ darkMode, onToggleDarkMode }) {
        const { Typography, Switch, Box, Tooltip } = MaterialUI;
        return (
          <Box component="header" id="app-header">
            <Box className="logo-container">
              <Logo />
            </Box>
            <Box className="theme-toggle-container">
              <Typography variant="body2" sx={{ color: darkMode ? 'var(--text-secondary)' : 'inherit', mr: 1 }}>
                {darkMode ? 'Dark' : 'Light'} Mode
              </Typography>
              <Tooltip title={darkMode ? "Switch to Light Mode" : "Switch to Dark Mode"} placement="bottom">
                <Switch checked={darkMode} onChange={onToggleDarkMode} />
              </Tooltip>
            </Box>
          </Box>
        );
      }


      /***************************************************************
       * OS Detection (front-end)
       ***************************************************************/
      function detectOS() {
        const ua = navigator.userAgent.toLowerCase();
        if (ua.indexOf("win") >= 0) return "windows";
        if (ua.indexOf("mac") >= 0) return "mac";
        if (ua.indexOf("linux") >= 0) return "linux";
        return "other";
      }

      /***************************************************************
       * Utility: parse code blocks from text for various uses
       ***************************************************************/
      function parseCodeBlocksGeneric(text, extractFilenameComment = true) {
        const result = [];
        // Enhanced regex to better capture language and optional filename comment on first line
        // ```lang? // filename.ext OR # filename.ext
        // code
        // ```
        const tripleRegex = /```(?:([\w+-]+)\s*)?(?:\/\/\s*([\w.:/\-]+)\s*|\#\s*([\w.:/\-]+)\s*)?\r?\n([\s\S]*?)\r?\n```/g; // Added ':' and '/' to filename chars

        let match;
        while ((match = tripleRegex.exec(text)) !== null) {
          const lang = (match[1] || "").trim().toLowerCase();
          const filenameFromComment = (match[2] || match[3] || "").trim();
          let codeBlock = match[4] || "";
          let title = "";

          if (extractFilenameComment && filenameFromComment) {
            title = filenameFromComment;
          } else if (lang) {
            title = `Code (${lang || "untitled"})`;
          } else {
            title = "Code (untitled)";
          }

          result.push({
            title,
            content: codeBlock.trim(),
            lang: lang
          });
        }

        // FILE: ... CODE: ... ENDCODE (legacy, keep for compatibility if needed)
        const fileRegex = /FILE:\s*(.+?)\nCODE:\s*([\s\S]+?)\nENDCODE/g;
        while ((match = fileRegex.exec(text)) !== null) {
          const filename = match[1].trim();
          const code = match[2].trim();
          result.push({
            title: filename,
            content: code,
            lang: "" // No language info from this format
          });
        }
        return result;
      }


      /***************************************************************
       * aggregatorApi - adjustable aggregatorUrl
       ***************************************************************/
      async function fetchAgents(aggregatorUrl) {
        const r = await fetch(`${aggregatorUrl}/agents`);
        if (!r.ok) {
          let errorText = "Error listing agents";
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(`${errorText} (Status: ${r.status})`);
        }
        return await r.json(); // Expected: { active_agents: [ {name?, port?, type, role_description, n_ctx, ...}, ... ] }
      }

      async function sendMessageToAgent(aggregatorUrl, {
        agentIdentifierObj, // Expects full agent object {name?, port?, type, ...}
        question,
        max_tokens,
        conversation_id,
        temperature // Optional
      }) {
        const payload = {
          agentIdentifier: agentIdentifierObj, // Pass the object directly, aggregator V1.5 expects "agentIdentifier" or uses alias
          question,
          max_tokens: max_tokens || 10000,
          conversation_id,
          temperature
        };
        if (payload.temperature === null || typeof payload.temperature === 'undefined') {
            delete payload.temperature;
        }

        const r = await fetch(`${aggregatorUrl}/message`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!r.ok) {
          let errorText = `sendMessageToAgent error (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        return await r.json();
      }

      async function interactiveStepApi(aggregatorUrl, {
        conversation_id,
        agentIdentifierObj, // Expects full agent object {name?, port?, type, ...}
        role,
        role_description,
        workspaces, // Expects [{type, title, content}]
        user_message,
        last_agent_message,
        maxTokens,
        finish_step,
        temperature // Optional
      }) {
        const payload = {
          conversation_id,
          agentIdentifier: agentIdentifierObj, // Pass the object directly
          role,
          role_description,
          workspaces,
          user_message,
          last_agent_message,
          max_tokens: maxTokens || 10000,
          finish_step,
          temperature
        };
        if (payload.temperature === null || typeof payload.temperature === 'undefined') {
            delete payload.temperature;
        }

        const r = await fetch(`${aggregatorUrl}/interactive_step`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!r.ok) {
          let errorText = `interactive_step error (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        const data = await r.json();
        return data; // Expected: {done, answer, assessment?}
      }

      async function contextAgentCall(
        aggregatorUrl,
        conversationId,
        contextAgentIdentifierObj, // Expects full agent object
        conversationText,
        extraContext = ""
      ) {
        if (!contextAgentIdentifierObj || !conversationId) {
            console.warn("Context agent call skipped: missing identifier object or conversationId.");
            return;
        }
        const contentForLogging =
          "Context Agent logging request initiated by client.\n" +
          "Input Conversation Text (summary/full):\n" + conversationText +
          (extraContext ? "\n\nAdditional Context for Agent Prompt (if applicable):\n" + extraContext : "");

        const payload = {
          conversation_id: conversationId,
          role: "ContextAgentInteractionLog",
          content: contentForLogging,
          agentIdentifier: contextAgentIdentifierObj // Pass object directly
        };
        try {
          const r = await fetch(`${aggregatorUrl}/context_agent_call`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            console.error("Context agent logging API error:", await r.text());
          }
        } catch (err) {
          console.error("Context agent logging API fetch error:", err);
        }
      }

      async function runTerminalCommand(aggregatorUrl, cmd, conversationId = null) {
        try {
          const payload = {
            command: cmd,
            conversation_id: conversationId
          };
          const r = await fetch(`${aggregatorUrl}/exec_command`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            let errorDetail = `Terminal command error (Status ${r.status})`;
            try {
                const errorJsonOrText = await r.text();
                try {
                    const errorJson = JSON.parse(errorJsonOrText);
                    errorDetail = errorJson.detail || errorJson.message || JSON.stringify(errorJson);
                } catch (parseErr) {
                    errorDetail = errorJsonOrText; // If not JSON, use raw text
                }
            } catch (e) { /* ignore if text() itself fails */ }
            throw new Error(errorDetail);
          }
          return await r.json(); // Expects { stdout, stderr, code }
        } catch (err) {
          console.error("Terminal command fetch/processing error:", err);
          return { stdout: "", stderr: String(err.message || err), code: -1 };
        }
      }

      async function putProject(aggregatorUrl, conversationId, projectData) {
        // projectData (from ChainManager) should now include steps with `agentIdentifierObj`
        const r = await fetch(`${aggregatorUrl}/project/${conversationId}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(projectData)
        });
        if (!r.ok) {
          let errorText = `Error saving project (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        // return await r.json(); // Optional
      }

      async function getProject(aggregatorUrl, conversationId) {
        const r = await fetch(`${aggregatorUrl}/project/${conversationId}`);
        if (!r.ok) {
          if (r.status === 404) {
            try { return await r.json(); } catch (e) {
                throw new Error(`Error loading project (404, but failed to parse default): ${e}`);
            }
          }
          let errorText = `Error loading project (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        return await r.json(); // Expects full ProjectData, steps should include agentIdentifierObj (as dict)
      }

      // Pull Request Endpoints
      async function submitPullRequest(aggregatorUrl, conversation_id, codeBlocks, description = "") {
        const payload = {
          conversation_id,
          code_blocks: codeBlocks,
          description
        };
        const r = await fetch(`${aggregatorUrl}/pr_submit`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!r.ok) {
          let errorText = `Error submitting pull request (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        return await r.json();
      }

      async function listPullRequests(aggregatorUrl, conversation_id) {
        const r = await fetch(`${aggregatorUrl}/pr_list?conversation_id=${encodeURIComponent(conversation_id)}`);
        if (!r.ok) {
          let errorText = `Error listing pull requests (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        return await r.json();
      }

      async function approvePullRequest(aggregatorUrl, conversation_id, pr_id) {
        const r = await fetch(
          `${aggregatorUrl}/pr_approve?conversation_id=${encodeURIComponent(conversation_id)}&pr_id=${encodeURIComponent(pr_id)}`,
          { method: "POST" }
        );
        if (!r.ok) {
          let errorText = `Error approving pull request (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        return await r.json();
      }

      // Structured Data
      async function addStructuredData(aggregatorUrl, conversation_id, data_type, json_data) {
        const payload = {
          conversation_id,
          data_type,
          json_data
        };
        const r = await fetch(`${aggregatorUrl}/structured_data/add`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!r.ok) {
          let errorText = `Error adding structured data (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        return await r.json();
      }

      async function listStructuredData(aggregatorUrl, conversation_id, data_type = null) {
        let url = `${aggregatorUrl}/structured_data/list?conversation_id=${encodeURIComponent(conversation_id)}`;
        if (data_type) {
          url += `&data_type=${encodeURIComponent(data_type)}`;
        }
        const r = await fetch(url);
        if (!r.ok) {
          let errorText = `Error listing structured data (Status ${r.status})`;
          try { errorText = await r.text(); } catch (e) { /* ignore */ }
          throw new Error(errorText);
        }
        return await r.json();
      }

      async function callChainApi(aggregatorUrl, chainRequestPayload) {
        const r = await fetch(`${aggregatorUrl}/chain`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(chainRequestPayload)
        });
        if (!r.ok) {
            let errorText = `Chain API error (Status ${r.status})`;
            try { errorText = await r.text(); } catch (e) { /* ignore */ }
            throw new Error(errorText);
        }
        return await r.json();
      }

      async function callAutoPipelineApi(aggregatorUrl, pipelineRequestPayload) {
        const r = await fetch(`${aggregatorUrl}/auto_pipeline`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(pipelineRequestPayload)
        });
        if (!r.ok) {
            let errorText = `Auto Pipeline API error (Status ${r.status})`;
            try { errorText = await r.text(); } catch (e) { /* ignore */ }
            throw new Error(errorText);
        }
        return await r.json();
      }

      // NEW: storeFeedbackApi for WorkspaceTaskModal
      async function storeFeedbackApi(aggregatorUrl, payload) {
        try {
          const r = await fetch(`${aggregatorUrl}/feedback/store`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            let errorText = `Error storing feedback (Status ${r.status})`;
            try { errorText = await r.text(); } catch (e) { /* ignore */ }
            throw new Error(errorText);
          }
          return await r.json();
        } catch (err) {
          console.error("Feedback API fetch/processing error:", err);
          throw err;
        }
      }

      // Expose to window for WorkspaceTaskModal
      window.storeFeedbackApi = storeFeedbackApi;


      /***************************************************************
       * parseForWorkspaces (uses parseCodeBlocksGeneric)
       ***************************************************************
       * NEW: summarizeConversation moved to global scope
       */
      async function summarizeConversation(aggregatorUrl, conversationText, agentIdentifierObjForSummarization, convIdForLogging = null, globalContextAgentIdentifier = null, allActiveAgents = []) {
        let agentToUse = agentIdentifierObjForSummarization;

        if (!agentToUse) {
            if (globalContextAgentIdentifier) {
                agentToUse = globalContextAgentIdentifier;
            } else if (allActiveAgents.length > 0) {
                agentToUse = allActiveAgents[0];
            } else {
                console.warn("No agent available for summarization.");
                return "Error: No agent available to summarize conversation.";
            }
        }

        const payload = {
          agentIdentifier: agentToUse,
          question: `Please provide a concise summary of the following interaction, focusing on key outcomes, decisions, and any files created or significantly modified. This summary will be passed to the next agent in a chain or used for overall project tracking:\n\n${conversationText}`,
          max_tokens: 500,
          conversation_id: convIdForLogging
        };
        try {
          const data = await sendMessageToAgent(aggregatorUrl, payload);
          return data.answer || "[No summary provided by agent.]";
        } catch (error) {
          console.error("Summarization call failed:", error);
          return `[Error summarizing conversation: ${error.message}]`;
        }
      }
      // Expose to window for WorkspaceTaskModal
      window.summarizeConversation = summarizeConversation;


      function parseForWorkspaces(text) {
        const parsedBlocks = parseCodeBlocksGeneric(text, true);
        return parsedBlocks.map(block => {
            const type = determineTypeFromFilename(block.title, block.lang);
            return {
                ...block,
                type,
            };
        });
      }

      function determineTypeFromFilename(filename, fenceLang) {
        const lowerFile = filename.toLowerCase();
        const lowerLang = (fenceLang || "").toLowerCase();

        if (lowerFile.endsWith(".py") || lowerLang === "python") return "code";
        if (lowerFile.endsWith(".js") || lowerFile.endsWith(".jsx") || lowerFile.endsWith(".ts") || lowerFile.endsWith(".tsx") ||
            lowerLang === "javascript" || lowerLang === "jsx" || lowerLang === "typescript" || lowerLang === "tsx") return "code";
        if (lowerFile.endsWith(".html") || lowerFile.endsWith(".htm") || lowerLang === "html" || lowerLang === "htmlmixed") return "html";
        if (lowerFile.endsWith(".css") || lowerLang === "css") return "css";
        if (lowerLang === "bash" || lowerLang === "shell" || lowerLang === "sh" || lowerFile.endsWith(".sh")) return "code";
        if (lowerFile.endsWith(".md") || lowerLang === "markdown") return "text"; // Treat MD as text for TextWorkspace, but CodeMirror will handle its mode

        if (fenceLang && fenceLang !== "text" && fenceLang !== "plaintext") return "code";

        return "text"; // Default
      }

      function getTagsForWorkspace(title, lang = "") {
        const tags = [];
        const lowerTitle = title.toLowerCase();
        const lowerLang = (lang || "").toLowerCase();

        if (lowerTitle.endsWith(".py") || lowerLang.includes("python")) tags.push("Python");
        if (lowerTitle.endsWith(".js") || lowerLang.includes("javascript")) tags.push("JavaScript");
        if (lowerTitle.endsWith(".jsx") || lowerLang.includes("jsx")) tags.push("JSX");
        if (lowerTitle.endsWith(".ts") || lowerLang.includes("typescript")) tags.push("TypeScript");
        if (lowerTitle.endsWith(".tsx") || lowerLang.includes("tsx")) tags.push("TSX");
        if (lowerTitle.endsWith(".html") || lowerLang.includes("html")) tags.push("HTML");
        if (lowerTitle.endsWith(".css") || lowerLang.includes("css")) tags.push("CSS");
        if (lowerTitle.includes("server") ) tags.push("ServerLogic");
        if (lowerTitle.includes("react") || lowerLang.includes("react")) tags.push("React");
        if (lowerLang === "bash" || lowerLang === "shell" || lowerLang === "sh" || lowerTitle.endsWith(".sh")) tags.push("Shell/Bash");
        if (lowerTitle.endsWith(".md") || lowerLang.includes("markdown")) tags.push("Markdown");
        if (lowerTitle.endsWith(".json") || lowerLang.includes("json")) tags.push("JSON");
        if (lowerTitle.endsWith(".xml") || lowerLang.includes("xml")) tags.push("XML");


        if (!tags.length && lang && lang !== "text" && lang !== "plaintext") tags.push(lang.charAt(0).toUpperCase() + lang.slice(1));
        if (!tags.length) tags.push("Text");
        return tags;
      }

      function formatAgentText(raw) {
        if (typeof raw !== 'string') {
            console.warn("formatAgentText received non-string input:", raw);
            return "";
        }
        let replaced = raw
          .replace(/&/g, "&amp;") // Ensure ampersand is escaped first
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");

        replaced = replaced.replace(/^###\s+(.*?)(?:\r?\n|$)/gm, "<h3>$1</h3>");
        replaced = replaced.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
        replaced = replaced.replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, "<em>$1</em>");
        replaced = replaced.replace(/(^|[^`])`(?!`)([^`]+?|\s?)`(?!`)/g, "$1<code>$2</code>");


        replaced = replaced.replace(/^\s*[-*+]\s+(.*)/gm, "<li>$1</li>");
        if (replaced.includes("<li>")) {
             replaced = replaced.replace(/^(<\/ul>\s*)?((?:<li>.*?<\/li>\s*)+)(<ul>\s*)?/gm, (match, p1, p2, p3) => {
                 return (p1 || "") + "<ul>" + p2 + "</ul>" + (p3 || "");
             });
             replaced = replaced.replace(/<ul>\s*<ul>/g, "<ul>").replace(/<\/ul>\s*<\/ul>/g, "</ul>");
        }

        replaced = replaced.replace(/^\s*\d+\.\s+(.*)/gm, "<oli>$1</oli>");
        if (replaced.includes("<oli>")) {
            replaced = replaced.replace(/^(<\/ol>\s*)?((?:<oli>.*?<\/oli>\s*)+)(<ol>\s*)?/gm, (match, p1, p2, p3) => {
                 return (p1 || "") + "<ol>" + p2.replace(/<oli>/g, "<li>").replace(/<\/oli>/g, "</li>") + "</ol>" + (p3 || "");
             });
            replaced = replaced.replace(/<ol>\s*<ol>/g, "<ol>").replace(/<\/ol>\s*<\/ol>/g, "</ol>");
        }
        return replaced;
      }

      function diffUsingJsDiff(oldContent, newContent) {
        const diff = Diff.diffLines(oldContent || "", newContent || "", { newlineIsToken: true, ignoreWhitespace: false });
        const result = [];
        diff.forEach(part => {
          const lines = part.value.split(/(\r?\n)/);
          for (let i = 0; i < lines.length; i++) {
            const lineText = lines[i];
            if (lineText === '' && i === lines.length - 1 && (part.value.endsWith('\n') || part.value.endsWith('\r\n'))) continue;

            if (lineText === '\r\n' || lineText === '\n') {
                if (part.value === lineText && (part.added || part.removed)) {
                     result.push({ type: part.added ? "added" : "removed", text: "[newline]" });
                }
            } else if (lineText || part.added || part.removed) {
              result.push({ type: part.added ? "added" : part.removed ? "removed" : "common", text: lineText });
            }
          }
        });
        return result;
      }

      /***************************************************************
       * Utility: Deep copy a workspace item
       ***************************************************************/
      function deepCopyWorkspaceItem(item) {
        if (!item) return null;
        // Simple deep copy for plain objects and arrays, good enough for workspace items
        // For more complex objects with functions or Date instances, a more robust deep copy would be needed.
        try {
            return JSON.parse(JSON.stringify(item));
        } catch (e) {
            console.error("Failed to deep copy item:", item, e);
            // Fallback to shallow copy if JSON stringify fails (e.g., circular refs, though not expected here)
            return { ...item };
        }
      }


      const {
        Box,
        Button,
        TextField,
        Typography,
        Select,
        MenuItem,
        FormControl,
        InputLabel,
        Paper,
        Switch,
        FormControlLabel,
        CircularProgress,
        Dialog,
        DialogTitle,
        DialogContent,
        DialogActions,
        Tooltip,
        IconButton,
        Snackbar,
        Alert,
        Chip, // Added for WorkspaceTaskModal
        Divider, // Added for WorkspaceTaskModal
        List, ListItem, ListItemText, ListItemIcon, // Added for WorkspaceTaskModal
        Collapse, // Added for WorkspaceTaskModal
        Checkbox, // Added for WorkspaceTaskModal
        FormGroup, // Added for WorkspaceTaskModal
        ListSubheader, // Added for WorkspaceTaskModal
        Grid, // Added for WorkspaceTaskModal
        LinearProgress, // Added for WorkspaceTaskModal
      useTheme, // Added for WorkspaceTaskModal & WorkspaceTaskModal
      Rating, // Added for WorkspaceTaskModal & WorkspaceTaskModal
      // Added from WorkspaceTaskModal's attempted destructuring
      Link,
      Fab
      } = MaterialUI;

      // Helper function (can be outside components if used by multiple)
      const getAgentIdentifierValueString = (agent) => {
          if (!agent) return "";
          // Use a consistent format: type:identifier (name or port)
          return agent.type === "network_scanned" ?
                 `network_scanned:${agent.port}` :
                 `${agent.type}:${agent.name}`; // e.g., "specialist_main_server:Coder"
      };


      /***************************************************************
       * ContextAgentSelector - Relies on `activeAgents` prop being array of agent objects
       ***************************************************************/
      function ContextAgentSelector({ activeAgents, contextAgentIdentifier, onChangeContextAgent, showSnackbar }) {
        const isDarkMode = document.body.classList.contains('dark-mode');

        // `getAgentIdentifierValueString` is now defined globally or passed as prop

        return (
            <Paper className="context-agent-panel interactive-card non-interactive" elevation={2} sx={{ borderRadius: 2, p: 1.5, mb: 2 }}>
                <Typography variant="body1" gutterBottom className={isDarkMode ? 'heading-glow' : ''} sx={{ fontWeight: 'medium', mb: 1 }}>
                    Context Agent (for Summaries, etc.)
                </Typography>
                <FormControl size="small" fullWidth>
                    <InputLabel id="context-agent-select-label">Select Agent for Context Tasks</InputLabel>
                    <Select
                        labelId="context-agent-select-label"
                        label="Select Agent for Context Tasks"
                        value={getAgentIdentifierValueString(contextAgentIdentifier)} // Uses the object directly
                        onChange={(e) => {
                            const selectedValueString = e.target.value;
                            let selectedAgentObj = null;
                            if (selectedValueString) {
                                selectedAgentObj = activeAgents.find(ag => getAgentIdentifierValueString(ag) === selectedValueString);
                            }
                            onChangeContextAgent(selectedAgentObj || null); // Pass the full agent object
                            if (showSnackbar) {
                                if (selectedAgentObj) {
                                    showSnackbar(`Context agent set to: ${selectedAgentObj.name || `Port ${selectedAgentObj.port}`}`, "info");
                                } else {
                                    showSnackbar("Context agent cleared. Default summarizer (likely Orchestrator model) will be used by aggregator.", "info");
                                }
                            }
                        }}
                    >
                        <MenuItem value="">
                            <em>(None - Use Aggregator's Default Summarizer)</em>
                        </MenuItem>
                        {activeAgents.map((agent) => {
                            const agentValue = getAgentIdentifierValueString(agent);
                            const displayName = agent.name || `Port ${agent.port}`;
                            const typeDisplay = agent.type ? `(${agent.type.replace("_main_server", "").replace("specialist", "Spec.").replace("network_scanned", "Net").replace("orchestrator", "Orch.")})` : '';
                            return (
                                <MenuItem key={agentValue} value={agentValue}>
                                    {displayName} <Typography variant="caption" sx={{ml:0.5, color:'text.secondary'}}>{typeDisplay}</Typography>
                                    {agent.role_description && <Tooltip title={agent.role_description}><IconButton size="small" sx={{ml:'auto', p:0.2}}><Typography sx={{fontSize:'0.7em'}}>ℹ️</Typography></IconButton></Tooltip>}
                                </MenuItem>
                            );
                        })}
                    </Select>
                </FormControl>
                {contextAgentIdentifier && (
                     <Typography variant="caption" display="block" sx={{mt:1, color: 'text.secondary'}}>
                        Selected for context: {contextAgentIdentifier.name || `Port ${contextAgentIdentifier.port}`} {contextAgentIdentifier.n_ctx ? `(${contextAgentIdentifier.n_ctx} ctx)` : ''}
                        {contextAgentIdentifier.role_description && <Tooltip title={contextAgentIdentifier.role_description}><span style={{cursor:'help'}}> (Role: {contextAgentIdentifier.role_description.substring(0,40)}...)</span></Tooltip>}
                     </Typography>
                )}
            </Paper>
        );
      }


      /***************************************************************
       * ConversationSelector
       ***************************************************************/
      function ConversationSelector({ aggregatorUrl, currentId, onChange, showSnackbar }) {
        const [allConversations, setAllConversations] = React.useState([]);
        const [newIdInput, setNewIdInput] = React.useState("");
        const isDarkMode = document.body.classList.contains('dark-mode');


        React.useEffect(() => {
          if (aggregatorUrl) {
            loadConvos();
          }
        }, [aggregatorUrl]);

        async function loadConvos() {
          if (!aggregatorUrl) {
            if (showSnackbar) showSnackbar("Aggregator URL is not set. Cannot load projects.", "warning");
            return;
          }
          try {
            const r = await fetch(`${aggregatorUrl}/conversations`);
            if (!r.ok) throw new Error("Conversations list error: " + await r.text());
            const data = await r.json();
            setAllConversations(data.conversations || []);
            if (showSnackbar) {
                if (data.conversations && data.conversations.length > 0) {
                    showSnackbar(`Refreshed project list (${data.conversations.length} found).`, "success");
                } else {
                    showSnackbar("No existing projects found on aggregator.", "info");
                }
            }
          } catch (err) {
            console.error("Error loading conversations:", err);
            if (showSnackbar) showSnackbar(`Error loading projects: ${err.message}`, "error");
          }
        }

        function handleNew() {
          if (!newIdInput.trim()) {
            if (showSnackbar) showSnackbar("New Project ID cannot be empty.", "warning");
            return;
          }
          const newId = newIdInput.trim();
          onChange(newId);
          setNewIdInput("");
          if (!allConversations.includes(newId)) {
            setAllConversations((prev) => [...prev, newId].sort());
          }
          if (showSnackbar) showSnackbar(`Switched to project: ${newId}`, "success");
        }

        return (
          <Paper sx={{ p: 2, mb: 2.5 }} elevation={2} className="interactive-card non-interactive">
            <Typography variant="h6" gutterBottom className={isDarkMode ? 'heading-glow' : ''} sx={{mb: 2}}>Conversation / Project ID</Typography>
            <Box display="flex" alignItems="center" gap={1.5} mb={2} flexWrap="wrap">
              <FormControl size="small" sx={{ minWidth: 200, flexGrow: 1}}>
                <InputLabel id="existing-project-label">Existing Project</InputLabel>
                <Select
                  labelId="existing-project-label"
                  value={currentId || ""}
                  label="Existing Project"
                  onChange={(e) => onChange(e.target.value)}
                >
                  <MenuItem value=""><em>(None - Create New Below)</em></MenuItem>
                  {allConversations.map((c) => (
                    <MenuItem key={c} value={c}>
                      {c}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              <Tooltip title="Refresh list of projects from aggregator">
                <Box component="span" sx={{ display: 'inline-flex' }}> {/* Wrapper for Tooltip */}
                  <Button variant="outlined" onClick={loadConvos} disabled={!aggregatorUrl}>
                    Refresh List
                  </Button>
                </Box>
              </Tooltip>
            </Box>
            <Box display="flex" mt={1.5} gap={1.5} flexWrap="wrap">
              <TextField
                label="Create or Load Project ID"
                size="small"
                value={newIdInput}
                onChange={(e) => setNewIdInput(e.target.value)}
                onKeyPress={(e) => { if (e.key === 'Enter' && newIdInput.trim()) handleNew(); }}
                sx={{flexGrow: 1}}
                placeholder="Enter a unique project name"
              />
              <Button variant="contained" color="primary" onClick={handleNew} disabled={!newIdInput.trim()}>
                Create / Load
              </Button>
            </Box>
          </Paper>
        );
      }


      /***************************************************************
       * DiffViewer (Uses jsdiff)
       ***************************************************************/
      function DiffViewer({ oldContent, newContent, onClose }) {
        const changes = React.useMemo(() => diffUsingJsDiff(oldContent, newContent), [oldContent, newContent]);
        const isDarkMode = document.body.classList.contains('dark-mode');

        return (
          <Dialog open={true} onClose={onClose} maxWidth="lg" fullWidth scroll="paper">
            <DialogTitle className={isDarkMode ? 'heading-glow' : ''}>Diff Viewer</DialogTitle>
            <DialogContent dividers sx={{ p:0 }}>
              <pre style={{ margin: 0, fontSize: '0.875em', whiteSpace: 'pre-wrap' }}>
              {changes.map((part, idx) => {
                  let className = "diff-line ";
                  if (part.type === "added") className += "diff-added";
                  else if (part.type === "removed") className += "diff-removed";
                  else className += "diff-common";

                  return (
                    <span key={idx} className={className}>
                      {part.text}
                    </span>
                  );
              })}
              </pre>
            </DialogContent>
            <DialogActions>
              <Button onClick={onClose}>Close</Button>
            </DialogActions>
          </Dialog>
        );
      }

      /***************************************************************
       * TerminalPanel
       ***************************************************************/
      function TerminalPanel({ aggregatorUrl, conversationId, terminalLogs, onRunCommand, showSnackbar }) { // Added conversationId
        const [commandInput, setCommandInput] = React.useState("");
        const terminalEndRef = React.useRef(null);
        const isDarkMode = document.body.classList.contains('dark-mode');

        React.useEffect(() => {
            if (terminalEndRef.current) {
                terminalEndRef.current.scrollIntoView({ behavior: "smooth" });
            }
        }, [terminalLogs]);


        async function handleRun() {
          if (!commandInput.trim()) {
              showSnackbar("Terminal command cannot be empty.", "warning");
              return;
          }
          // Pass conversationId to onRunCommand if it's set
          onRunCommand(commandInput.trim(), conversationId || null);
          setCommandInput("");
        }

        return (
          <Paper sx={{ p: 2, mb: 2.5 }} elevation={2} className="interactive-card non-interactive">
            <Typography variant="h6" gutterBottom className={isDarkMode ? 'heading-glow' : ''}>Built-In Terminal</Typography>
            <div className="terminal-input-box">
              <input
                type="text"
                placeholder="Enter command (runs in project context if selected)..."
                value={commandInput}
                onChange={(e) => setCommandInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    handleRun();
                  }
                }}
              />
              <Button variant="contained" color="primary" onClick={handleRun} disabled={!aggregatorUrl}>
                Run
              </Button>
            </div>
            <div className="terminal-panel">
                {terminalLogs.join("\n")}
                <div ref={terminalEndRef} />
            </div>
          </Paper>
        );
      }

      /***************************************************************
       * AutoRunLogs
       ***************************************************************/
      function AutoRunLogs({ logs }) {
        const logsEndRef = React.useRef(null);
        const isDarkMode = document.body.classList.contains('dark-mode');
         React.useEffect(() => {
        }, [logs]);

        return (
          <Paper sx={{ p: 2, mb: 2.5 }} elevation={2} className="interactive-card non-interactive">
            <Typography variant="h6" gutterBottom className={isDarkMode ? 'heading-glow' : ''}>Auto-Run & System Logs</Typography>
            <Box className="auto-run-logs">
              {logs.map((entry, idx) => (
                <div className="log-entry" key={idx}>
                  <strong>{entry.role}:</strong> {entry.content}
                </div>
              ))}
              <div ref={logsEndRef} />
            </Box>
          </Paper>
        );
      }

      /***************************************************************
       * buildPreviewDocument
       ***************************************************************/
      function buildPreviewDocument(workspaces) {
        let htmlContent = "";
        let cssContent = "";
        let jsContent = "";

        workspaces.forEach((ws) => {
          if (ws.type === "folder") return;
          const lowerTitle = ws.title.toLowerCase();
          const lowerLang = (ws.lang || "").toLowerCase();
          if (ws.type === "html" || lowerTitle.endsWith(".html") || lowerLang.includes("html")) {
            htmlContent += "\n" + ws.content;
          } else if (ws.type === "css" || lowerTitle.endsWith(".css") || lowerLang.includes("css")) {
            cssContent += "\n" + ws.content;
          } else if (
            ws.type === "code" && (lowerTitle.endsWith(".js") || lowerLang.includes("js") || lowerLang.includes("javascript"))
          ) {
            jsContent += "\n" + ws.content;
          }
        });

        const scriptOpen = "<script>";
        const scriptClose = "</scr" + "ipt>";
        const fullHtml = `
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>Live Preview</title>
<style>
body { font-family: sans-serif; margin: 8px; }
${cssContent}
</style>
</head>
<body>
${htmlContent}
${scriptOpen}
try {
  ${jsContent}
} catch (e) {
  console.error("Error in preview JavaScript:", e);
  document.body.insertAdjacentHTML("beforeend", "<div style='color:red; background:lightyellow; border:1px solid red; padding:10px; margin-top:10px;'>Preview JS Error: " + e.message + "</div>");
}
${scriptClose}
</body>
</html>
`.trim();
        return fullHtml;
      }

      /***************************************************************
       * FileExplorer
       ***************************************************************/
      // Pass handleLoadProjectFromAggregator & conversationId from ChainManager if placing refresh button here.
      function FileExplorer({ workspaces, setWorkspaces, showSnackbar, handleLoadProjectFromAggregator, conversationId, onTriggerTaskModal }) {
        const [renameDialogOpen, setRenameDialogOpen] = React.useState(false);
        const [renameTarget, setRenameTarget] = React.useState(null); // Store the whole workspace object
        const [renameValue, setRenameValue] = React.useState("");    // For the new basename
        const [openFolders, setOpenFolders] = React.useState({}); // Keys are now relative folder paths (item.id)
        const isDarkMode = document.body.classList.contains('dark-mode');

        // Helper to determine file type (from global scope or copied here if preferred)
        // Assuming `determineTypeFromFilename` is available globally or passed as prop/imported.

        function getFileIcon(title, type, lang) { // title is basename
            const lowerTitle = title.toLowerCase();
            // Check openFolders using the full path ID of the folder item IF it's a folder
            // This specific usage needs refinement based on how openFolders is keyed if not just basename
            // For simplicity here, we use a generic folder icon that doesn't depend on open state from title
            if (type === "folder") return "📁"; // Simpler approach for now
            // The open/closed state should be determined in renderWorkspaceItem using the folder's actual ws.id
            
            if (lowerTitle.endsWith(".html")) return "📄";
            if (lowerTitle.endsWith(".css")) return "🎨";
            if (lowerTitle.endsWith(".js") || lowerTitle.endsWith(".jsx") || lowerTitle.endsWith(".ts") || lowerTitle.endsWith(".tsx")) return "📜";
            if (lowerTitle.endsWith(".py")) return "🐍";
            if (lowerTitle.endsWith(".md")) return "📝";
            if (type === "code") return "💻";
            return "📄"; // Default document
        }

        function toggleFolderOpen(folderPathId) { // folderPathId is the relative path (item.id)
          setOpenFolders((prev) => ({ ...prev, [folderPathId]: !prev[folderPathId] }));
        }

        function handleRenameClick(wsItem) { // wsItem is the full workspace object
          setRenameTarget(wsItem);
          setRenameValue(wsItem.title); // wsItem.title is the current basename
          setRenameDialogOpen(true);
        }

        function handleRenameConfirm() {
          if (!renameTarget || !renameValue.trim()) {
            showSnackbar("New name cannot be empty.", "warning");
            return;
          }
          const oldPathId = renameTarget.id;
          const oldBaseName = renameTarget.title;
          const newBaseName = renameValue.trim();
          const parentPathId = renameTarget.parentId; // This is the parent folder's relative path, or null

          if (oldBaseName === newBaseName) {
            setRenameDialogOpen(false);
            return; // No actual change
          }
          
          const newPathId = parentPathId ? `${parentPathId}/${newBaseName}` : newBaseName;

          // Check for name collisions within the same parent
          if (workspaces.some(ws => ws.parentId === parentPathId && ws.id !== oldPathId && ws.title === newBaseName)) {
              showSnackbar(`An item named "${newBaseName}" already exists in folder "${parentPathId || "root"}".`, "error");
              return;
          }
           // Check if new full path ID already exists (should be rare if basename collision caught)
          if (workspaces.some(ws => ws.id === newPathId && ws.id !== oldPathId)) {
            showSnackbar(`A path "${newPathId}" already exists. This indicates a severe naming conflict.`, "error");
            return;
          }


          setWorkspaces((prevWs) => {
            return prevWs.map((ws) => {
              if (ws.id === oldPathId) { // Update the item being renamed
                return { ...ws, title: newBaseName, id: newPathId };
              }
              // If renaming a folder, update parentId of its direct children
              if (renameTarget.type === "folder" && ws.parentId === oldPathId) {
                // Child's new parentId is the newPathId of the folder.
                // Child's ID needs to be reconstructed: newParentPathId + child's old basename
                const childBaseName = ws.title;
                return { ...ws, parentId: newPathId, id: `${newPathId}/${childBaseName}` };
              }
              return ws;
            });
          });

          setRenameDialogOpen(false);
          setRenameTarget(null);
          showSnackbar(`UI: Renamed "${oldBaseName}" to "${newBaseName}". Save project to persist changes to server.`, "success");
        }

        function handleDeleteClick(wsItemToDelete) { // wsItemToDelete is the full workspace object
            const { id: pathIdToDelete, title: baseNameToDelete, type: itemType } = wsItemToDelete;

            if (confirm(`Are you sure you want to remove "${baseNameToDelete}" from the UI? This will affect the server on the next project save.`)) {
                setWorkspaces(prevWs => {
                    if (itemType === "folder") {
                        // Find all descendants recursively to remove them too
                        const descendants = new Set();
                        function findDescendants(currentParentId) {
                            prevWs.forEach(ws => {
                                if (ws.parentId === currentParentId) {
                                    descendants.add(ws.id);
                                    if (ws.type === "folder") {
                                        findDescendants(ws.id);
                                    }
                                }
                            });
                        }
                        findDescendants(pathIdToDelete);
                        descendants.add(pathIdToDelete); // Add the folder itself
                        return prevWs.filter(ws => !descendants.has(ws.id));
                    } else {
                        // Just a file
                        return prevWs.filter(ws => ws.id !== pathIdToDelete);
                    }
                });
                showSnackbar(`UI: Removed "${baseNameToDelete}". Save project to update server.`, "info");
            }
        }

        function getFolderContents(parentFolderPathId) { // parentFolderPathId is the relative path of the parent
          return workspaces.filter((x) => x.parentId === parentFolderPathId).sort((a,b) => a.title.localeCompare(b.title));
        }

        function renderWorkspaceItem(ws, indent = 0) { // ws.id is relative path, ws.title is basename
          const itemIcon = getFileIcon(ws.title, ws.type, ws.lang);
          
          if (ws.type === "folder") {
            const isOpen = openFolders[ws.id] || false; // Use ws.id (relative path) as key
            const displayIcon = isOpen ? "📂" : "📁";
            return (
              <Box key={ws.id} sx={{ ml: indent * 2, mb: 0.5 }}>
                <Box display="flex" alignItems="center">
                    <Typography variant="body1" component="span" onClick={() => toggleFolderOpen(ws.id)} sx={{ cursor: 'pointer', display: 'inline-flex', alignItems: 'center', '&:hover': {opacity:0.8} }}>
                    {displayIcon} <span style={{marginLeft: '4px'}}>{ws.title}</span> {/* ws.title is basename */}
                    </Typography>
                    {/* Assuming this IconButton could be disabled, e.g., disabled={!canRename} */}
                    <Tooltip title="Rename Folder (UI only, save to persist)">
                        <span>
                            <IconButton size="small" onClick={() => handleRenameClick(ws)} sx={{ml:1}} /* disabled={!canRename} */ ><Typography sx={{fontSize: '0.8em'}}>✏️</Typography></IconButton>
                        </span>
                    </Tooltip>
                    <Tooltip title="Delete Folder and its contents (UI only, save to persist)">
                        <IconButton size="small" onClick={() => handleDeleteClick(ws)} sx={{ml:0.5}}><Typography sx={{fontSize: '0.8em'}}>🗑️</Typography></IconButton>
                      </Tooltip>
                      <Tooltip title="Open Task Modal for this folder">
                          <IconButton size="small" onClick={() => onTriggerTaskModal && onTriggerTaskModal(ws)} sx={{ml:0.5}}><Typography sx={{fontSize: '0.8em'}}>🪄</Typography></IconButton>
                      </Tooltip>
                </Box>
                {isOpen && (
                  <div className="folder-contents">
                    {getFolderContents(ws.id).map((child) => // ws.id is parent folder's relative path
                      renderWorkspaceItem(child, indent + 1)
                    )}
                    {getFolderContents(ws.id).length === 0 && <Typography variant="caption" sx={{ml:2, color: 'text.secondary'}}>(empty)</Typography>}
                  </div>
                )}
              </Box>
            );
          } else { // It's a file
            return (
              <Box key={ws.id} sx={{ ml: indent * 2, mb: 0.5, display: 'flex', alignItems: 'center' }}>
                <Typography variant="body2" component="span" className="draggable-file">
                  {itemIcon} <span style={{marginLeft: '4px'}}>{ws.title}</span> {/* ws.title is basename */}
                </Typography>
                 {/* Assuming this IconButton could be disabled */}
                 <Tooltip title="Rename File (UI only, save to persist)">
                    <span>
                        <IconButton size="small" onClick={() => handleRenameClick(ws)} sx={{ml:1}} /* disabled={!canRenameFile} */><Typography sx={{fontSize: '0.8em'}}>✏️</Typography></IconButton>
                    </span>
                 </Tooltip>
                 {/* Assuming this IconButton could be disabled */}
                 <Tooltip title="Delete File (UI only, save to persist)">
                    <span>
                        <IconButton size="small" onClick={() => handleDeleteClick(ws)} sx={{ml:0.5}} /* disabled={!canDeleteFile} */><Typography sx={{fontSize: '0.8em'}}>🗑️</Typography></IconButton>
                    </span>
                  </Tooltip>
                  {/* Assuming this IconButton could be disabled */}
                  <Tooltip title="Open Task Modal for this file">
                     <span><IconButton size="small" onClick={() => onTriggerTaskModal && onTriggerTaskModal(ws)} sx={{ml:0.5}} /* disabled={!onTriggerTaskModal} */><Typography sx={{fontSize: '0.8em'}}>🪄</Typography></IconButton></span>
                   </Tooltip>
              </Box>
            );
          }
        }

        const topLevel = workspaces.filter((w) => !w.parentId || w.parentId === null).sort((a,b) => a.title.localeCompare(b.title));

        return (
          <Paper className="file-explorer interactive-card non-interactive" sx={{ p: 2, mb: 2.5 }} elevation={2}>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={1}>
                <Typography variant="h6" gutterBottom={false} className={isDarkMode ? 'heading-glow' : ''}>File / Folder Explorer</Typography>
                {handleLoadProjectFromAggregator && conversationId && (
                    <Tooltip title="Refresh file and folder list from server">
                        <Button
                            variant="outlined"
                            size="small"
                            onClick={() => handleLoadProjectFromAggregator(conversationId)}
                            startIcon={<Typography>🔄</Typography>}
                        >
                            Refresh List
                        </Button>
                    </Tooltip>
                )}
            </Box>
            <Box display="flex" gap={1} mb={1.5} flexWrap="wrap">
                <Button
                  variant="outlined"
                  size="small"
                  onClick={() => {
                    let folderNum = 1;
                    let newFolderName = `New Folder ${folderNum}`;
                    while (workspaces.some(w => w.type === "folder" && w.title === newFolderName && !w.parentId)) {
                        folderNum++;
                        newFolderName = `New Folder ${folderNum}`;
                    }
                    const newFolderId = newFolderName; // ID is the name for root folders
                    setWorkspaces((prev) => [
                      ...prev,
                      { 
                        id: newFolderId, type: "folder", title: newFolderName, 
                        parentId: null, content: "", lang: "", versionHistory: [] 
                      }
                    ]);
                    showSnackbar("New root folder added to UI. Save project to create on server.", "success");
                  }}
                >
                  + Add Root Folder (UI)
                </Button>
                <Button
                  variant="outlined"
                  size="small"
                  onClick={() => {
                    const parentFolderWs = openFolders && Object.keys(openFolders).find(pathId => openFolders[pathId])
                        ? workspaces.find(ws => ws.id === Object.keys(openFolders).find(pathId => openFolders[pathId]) && ws.type === 'folder')
                        : null;
                    
                    const parentPathId = parentFolderWs ? parentFolderWs.id : null;
                    const parentNameDisplay = parentFolderWs ? parentFolderWs.title : "root";

                    let newFileNameBase = "new_file.txt";
                    let fileNum = 1;
                    let currentAttemptName = newFileNameBase;
                    
                    while (workspaces.some(w => w.parentId === parentPathId && w.title === currentAttemptName)) {
                        currentAttemptName = `new_file_${fileNum++}.txt`;
                    }
                    newFileNameBase = currentAttemptName;

                    const newFileId = parentPathId ? `${parentPathId}/${newFileNameBase}` : newFileNameBase;

                    setWorkspaces((prev) => [
                      ...prev,
                      { 
                        id: newFileId, 
                        type: determineTypeFromFilename(newFileNameBase), 
                        title: newFileNameBase, 
                        parentId: parentPathId, 
                        content: `// New file: ${newFileNameBase}\n`, 
                        lang: newFileNameBase.split('.').pop() || "txt", 
                        versionHistory: [{content: `// New file: ${newFileNameBase}\n`, timestamp: Date.now()}]
                      }
                    ]);
                    showSnackbar(`New file "${newFileNameBase}" added to "${parentNameDisplay}" in UI. Save project to create on server.`, "success");
                  }}
                >
                  + Add File (UI)
                </Button>
            </Box>


            {topLevel.length === 0 && <Typography variant="body2" sx={{mt:1, color: 'text.secondary'}}>No files or folders. Drag & drop, let agents create them, or refresh.</Typography>}
            {topLevel.map((ws) => renderWorkspaceItem(ws))}

            <Dialog open={renameDialogOpen} onClose={() => setRenameDialogOpen(false)}>
              <DialogTitle className={isDarkMode ? 'heading-glow' : ''}>Rename Item</DialogTitle>
              <DialogContent>
                <TextField
                  autoFocus
                  margin="dense"
                  label="New Name (basename)"
                  fullWidth
                  value={renameValue}
                  onChange={(e) => setRenameValue(e.target.value)}
                  onKeyPress={(e) => { if (e.key === 'Enter' && renameValue.trim()) handleRenameConfirm(); }}
                  variant="outlined"
                  helperText="Only the file/folder name, not the full path. No slashes."
                />
              </DialogContent>
              <DialogActions>
                <Button onClick={() => setRenameDialogOpen(false)}>Cancel</Button>
                <Button onClick={handleRenameConfirm} variant="contained" color="primary" disabled={!renameValue.trim() || renameValue.includes('/') || renameValue.includes('\\')}>
                  Confirm Rename (UI)
                </Button>
              </DialogActions>
            </Dialog>
          </Paper>
        );
      }

      /***************************************************************
       * WorkspaceDropZone
       ***************************************************************/
      function WorkspaceDropZone({ onFilesDropped, showSnackbar }) {
        const [isDragOver, setIsDragOver] = React.useState(false);

        function handleDragOver(e) {
          e.preventDefault();
          e.stopPropagation();
          setIsDragOver(true);
        }

        function handleDragLeave(e) {
          e.preventDefault();
          e.stopPropagation();
          setIsDragOver(false);
        }

        function handleDrop(e) {
          e.preventDefault();
          e.stopPropagation();
          setIsDragOver(false);
          const files = e.dataTransfer.files;
          if (files.length === 0) return;
          const fileArray = Array.from(files);
          onFilesDropped && onFilesDropped(fileArray);
          showSnackbar(`${fileArray.length} file(s) dropped and added to workspaces.`, "success");
        }

        return (
          <Box
            className={`workspace-drop-zone ${isDragOver ? "drag-over" : ""}`}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            sx={{ padding: '30px', margin: '20px 0', borderRadius: '8px', borderStyle: 'dashed' }}
          >
            <Typography variant="h6">📂 Drag &amp; Drop Files Here to Upload to Root</Typography>
            <Typography variant="body2">(Files will be added to the root of the explorer)</Typography>
          </Box>
        );
      }

      /***************************************************************
       * TextWorkspace / CodeWorkspace
       ***************************************************************/
      function TextWorkspace({ ws, onChange, showSnackbar }) {
        const [diffOpen, setDiffOpen] = React.useState(false);
        const { content, versionHistory = [] } = ws;
        const tags = getTagsForWorkspace(ws.title, ws.lang);
        const isDarkMode = document.body.classList.contains('dark-mode');


        function handleEdit(e) {
          onChange(e.target.value);
        }

        function handleRevert() {
            if (versionHistory.length < 2) {
                showSnackbar("No previous version to revert to.", "info");
                return;
            }
            const older = versionHistory[versionHistory.length - 2];
            onChange(older.content);
            showSnackbar(`Reverted "${ws.title}" to previous version.`, "success");
        }

        return (
          <Paper sx={{ p: 2, mb: 2.5 }} elevation={2} className="interactive-card">
            <Typography variant="h6" className={isDarkMode ? 'heading-glow' : ''}>{ws.title}</Typography>
            <Typography className="metadata-tags" gutterBottom>Tags: {tags.join(", ")}</Typography>
            <Box display="flex" gap={1} mb={1.5} flexWrap="wrap">
              <Tooltip title={versionHistory.length < 2 ? "No older version for diff" : "Show differences from previous version"}>
                <span>
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={() => setDiffOpen(true)}
                    disabled={versionHistory.length < 2}
                    // Conditionally apply pointerEvents: 'none' when disabled
                    // to ensure the wrapping span handles hover events for the tooltip.
                    // 'auto' is the default, allowing events when not disabled.
                    style={{ pointerEvents: versionHistory.length < 2 ? 'none' : 'auto' }}
                  >
                    Show Diff
                  </Button>
                </span>
              </Tooltip>
              <Tooltip title={versionHistory.length < 2 ? "No older version to revert to" : "Revert to the previous version"}>
                <span>
                  <Button variant="outlined" size="small" onClick={handleRevert} disabled={versionHistory.length < 2}>
                    Revert Last
                  </Button>
                </span>
              </Tooltip>
            </Box>
            <TextField
              multiline
              minRows={5}
              maxRows={20}
              variant="outlined"
              fullWidth
              value={content || ""}
              onChange={handleEdit}
              InputProps={{ sx: { fontFamily: 'monospace' } }}
            />
            {diffOpen && versionHistory.length >= 2 && (
              <DiffViewer
                oldContent={versionHistory[versionHistory.length - 2].content}
                newContent={content}
                onClose={() => setDiffOpen(false)}
              />
            )}
          </Paper>
        );
      }

      function pickCodeMirrorMode(langOrTitle, fileContent = "") {
        const lower = String(langOrTitle || "").toLowerCase(); // Ensure it's a string
        const contentLower = String(fileContent || "").trim().toLowerCase();

        if (lower.endsWith(".js") || lower.includes("javascript")) return "javascript";
        if (lower.endsWith(".jsx")) return {name: "javascript", jsx: true};
        if (lower.endsWith(".ts")) return {name: "javascript", typescript: true};
        if (lower.endsWith(".tsx")) return {name: "javascript", typescript: true, jsx: true};
        if (lower.endsWith(".css")) return "css";
        if (lower.endsWith(".html") || lower.endsWith(".htm")) return "htmlmixed";
        if (lower.endsWith(".py") || lower.includes("python")) return "python";
        if (lower.endsWith(".sh") || lower.includes("bash") || lower.includes("shell")) return "shell";
        if (lower.endsWith(".xml") || lower.includes("xml")) return "xml";
        if (lower.endsWith(".json") || lower.includes("json")) return {name: "javascript", json: true};
        if (lower.endsWith(".md") || lower.includes("markdown")) return "markdown";

        if (contentLower.startsWith("<") && contentLower.includes(">")) return "htmlmixed";
        if (contentLower.startsWith("{") || contentLower.startsWith("[")) return {name: "javascript", json: true};

        return "text/plain";
      }

      function CodeWorkspace({ ws, onChange, darkMode, showSnackbar, onTriggerTaskModal }) {
        const textAreaRef = React.useRef(null);
        const editorInstanceRef = React.useRef(null);
        const [diffOpen, setDiffOpen] = React.useState(false);
        const { content = "", versionHistory = [] } = ws; // Ensure content and versionHistory default
        const tags = getTagsForWorkspace(ws.title, ws.lang);
        const isDarkMode = darkMode;

        React.useEffect(() => {
          let cmInstance;
          if (textAreaRef.current && !editorInstanceRef.current) {
            const mode = pickCodeMirrorMode(ws.lang || ws.title, content);
            cmInstance = window.CodeMirror.fromTextArea(textAreaRef.current, {
              lineNumbers: true,
              mode: mode,
              theme: isDarkMode ? 'material-darker' : 'default',
              autoCloseBrackets: true,
              matchBrackets: true,
              foldGutter: true,
              gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
              highlightSelectionMatches: {showToken: /\w/, annotateScrollbar: true},
            });
            cmInstance.setValue(content); // Initial content
            cmInstance.on("change", (instance) => {
              onChange(instance.getValue());
            });
            editorInstanceRef.current = cmInstance;
          }

          return () => {
            if (editorInstanceRef.current && typeof editorInstanceRef.current.toTextArea === 'function') {
              // editorInstanceRef.current.toTextArea(); // Sometimes problematic
              editorInstanceRef.current = null;
            }
          };
        }, []); // Only on mount

         React.useEffect(() => {
            const editor = editorInstanceRef.current;
            if (editor) {
                const editorValue = editor.getValue();
                if (editorValue !== content) { // Check if content actually changed
                    const cursor = editor.getCursor();
                    editor.setValue(content);
                    editor.setCursor(cursor); // Try to restore cursor position
                }
                const currentTheme = editor.getOption('theme');
                const newTheme = isDarkMode ? 'material-darker' : 'default';
                if (currentTheme !== newTheme) {
                    editor.setOption('theme', newTheme);
                }
                 const currentModeObj = editor.getOption('mode');
                 const newModeObj = pickCodeMirrorMode(ws.lang || ws.title, content);
                 const currentModeStr = typeof currentModeObj === 'string' ? currentModeObj : JSON.stringify(currentModeObj);
                 const newModeStr = typeof newModeObj === 'string' ? newModeObj : JSON.stringify(newModeObj);

                 if (currentModeStr !== newModeStr) {
                     editor.setOption('mode', newModeObj);
                 }
            }
        }, [content, isDarkMode, ws.lang, ws.title]);


        function revertToPrevious() {
          if (versionHistory.length < 2) {
            showSnackbar("No previous version to revert to.", "info");
            return;
          }
          const older = versionHistory[versionHistory.length - 2];
          onChange(older.content);
          showSnackbar(`Reverted "${ws.title}" to previous version.`, "success");
        }

        function handleCopyCode() {
            if(editorInstanceRef.current) {
                const codeToCopy = editorInstanceRef.current.getValue();
                navigator.clipboard.writeText(codeToCopy).then(() => {
                    showSnackbar(`Code from "${ws.title}" copied to clipboard!`, "success");
                }).catch(err => {
                    showSnackbar(`Failed to copy code: ${err.message}`, "error");
                    console.error('Failed to copy code: ', err);
                });
            }
        }

        return (
          <Paper sx={{ p: 2, mb: 2.5 }} elevation={2} className="interactive-card">
            <Box display="flex" justifyContent="space-between" alignItems="center">
                <Typography variant="h6" className={isDarkMode ? 'heading-glow' : ''}>{ws.title}</Typography>
                <Tooltip title="Copy all code from this workspace">
                    <IconButton onClick={handleCopyCode} size="small">
                        <Typography sx={{fontSize: '1em'}}>📋</Typography>
                    </IconButton>
                </Tooltip>
                <Tooltip title="Open Task Modal for this workspace">
                    <IconButton onClick={() => onTriggerTaskModal && onTriggerTaskModal(ws)} size="small" sx={{ ml: 0.5 }}>
                        <Typography sx={{fontSize: '1em'}}>🪄</Typography>
                    </IconButton>
                </Tooltip>
            </Box>
            <Typography className="metadata-tags" gutterBottom>Tags: {tags.join(", ")} (Mode: {JSON.stringify(pickCodeMirrorMode(ws.lang || ws.title, content))})</Typography>
            <Box display="flex" gap={1} mb={1.5} flexWrap="wrap">
              <Tooltip title={versionHistory.length < 2 ? "No older version for diff" : "Show differences from previous version"}>
                <span>
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={() => setDiffOpen(true)}
                    disabled={versionHistory.length < 2}
                  >
                    Show Diff
                  </Button>
                </span>
              </Tooltip>
              <Tooltip title={versionHistory.length < 2 ? "No older version to revert to" : "Revert to the previous version"}>
                <span>
                  <Button variant="outlined" size="small" onClick={revertToPrevious} disabled={versionHistory.length < 2}>
                    Revert Last
                  </Button>
                </span>
              </Tooltip>
            </Box>
            {/* Ensure textarea is present for CM to attach to, even if hidden */}
            <textarea ref={textAreaRef} defaultValue={content} style={{ display: "none" }} />
            {diffOpen && versionHistory.length >= 2 && (
              <DiffViewer
                oldContent={versionHistory[versionHistory.length - 2].content}
                newContent={content}
                onClose={() => setDiffOpen(false)}
              />
            )}
          </Paper>
        );
      }

      /***************************************************************
       * PullRequestPanel
       ***************************************************************/
      function PullRequestPanel({ aggregatorUrl, conversationId, onMerged, showSnackbar }) {
        const [prs, setPrs] = React.useState([]);
        const isDarkMode = document.body.classList.contains('dark-mode');


        React.useEffect(() => {
          if (conversationId && aggregatorUrl) {
            loadPRs();
          } else if (!conversationId) {
            setPrs([]);
          }
        }, [conversationId, aggregatorUrl]);

        async function loadPRs() {
          if (!conversationId || !aggregatorUrl) {
            return;
          }
          try {
            const data = await listPullRequests(aggregatorUrl, conversationId);
            setPrs(data.pull_requests || []);
            showSnackbar("Pull requests list refreshed.", "info");
          } catch (err) {
            console.error("Error loading PRs:", err);
            showSnackbar(`Error loading PRs: ${err.message}`, "error");
          }
        }

        async function handleApprove(prId) {
          try {
            await approvePullRequest(aggregatorUrl, conversationId, prId);
            showSnackbar(`PR #${prId} approved and merged!`, "success");
            loadPRs();
            onMerged && onMerged();
          } catch (err) {
            showSnackbar(`Error approving PR: ${err.message}`, "error");
          }
        }

        if (!conversationId) return null;

        return (
          <Paper className="pr-panel interactive-card non-interactive" sx={{ p: 2, mb: 2.5 }} elevation={2}>
            <Typography variant="h6" gutterBottom className={isDarkMode ? 'heading-glow' : ''}>Pull Requests</Typography>
            <Tooltip title="Refresh the list of pull requests from the aggregator.">
              <span>
                <Button variant="outlined" onClick={loadPRs} style={{ marginBottom: 10 }} disabled={!aggregatorUrl}>
                  Refresh PR List
                </Button>
              </span>
            </Tooltip>
            {prs.length === 0 && (
              <Typography variant="body2" sx={{color: 'text.secondary'}}>No pull requests for this project yet.</Typography>
            )}
            {prs.map((pr) => (
              <Box key={pr.id} className="pr-item" sx={{ borderRadius: 1, p:1.5, mb:1.5 }}>
                <Typography variant="subtitle1" sx={{ fontWeight: 'medium', color: pr.status === "merged" ? 'success.main' : (pr.status === "pending" ? 'warning.main' : 'text.primary') }}>
                  PR #{pr.id} - Status: {pr.status.toUpperCase()}
                </Typography>
                {pr.pr_data.description && (
                  <Typography variant="body2" sx={{ mb: 0.5, fontStyle: 'italic', color: 'text.secondary' }}>
                    {pr.pr_data.description}
                  </Typography>
                )}
                {(pr.pr_data.code_blocks || []).map((block, idx) => (
                  <Box key={idx} className="pr-item-code-block" sx={{ borderRadius: 1, p:1, my:1 }}>
                    <Typography variant="caption" sx={{fontWeight: 'bold', display:'block', color: 'text.secondary'}}>{block.title}</Typography>
                    <pre style={{margin:0, paddingTop: '4px', whiteSpace: 'pre-wrap', wordBreak: 'break-all', fontSize: '0.875em'}}>{block.content}</pre>
                  </Box>
                ))}
                {pr.status === "pending" && (
                  <Button variant="contained" size="small" color="success" onClick={() => handleApprove(pr.id)} sx={{mt:1}}>
                    Approve &amp; Merge
                  </Button>
                )}
              </Box>
            ))}
          </Paper>
        );
      }

      /***************************************************************
       * PipelinePanel (for /auto_pipeline endpoint)
       ***************************************************************/
      function PipelinePanel({ aggregatorUrl, conversationId, showSnackbar }) {
        const [buildCmd, setBuildCmd] = React.useState("npm run build");
        const [testCmd, setTestCmd] = React.useState("npm test");
        const [lintCmd, setLintCmd] = React.useState("npx eslint .");
        const [pipelineResult, setPipelineResult] = React.useState(null);
        const [loading, setLoading] = React.useState(false);
        const isDarkMode = document.body.classList.contains('dark-mode');


        async function runPipeline() {
          if (!conversationId) {
            showSnackbar("No project selected to run pipeline!", "warning");
            return;
          }
           if (!aggregatorUrl) {
            showSnackbar("Aggregator URL not set. Cannot run pipeline.", "error");
            return;
          }
          setLoading(true);
          setPipelineResult(null);
          try {
            const payload = {
              conversation_id: conversationId,
              build_command: buildCmd,
              test_command: testCmd,
              lint_command: lintCmd
            };
            // Using callAutoPipelineApi helper now
            const data = await callAutoPipelineApi(aggregatorUrl, payload);
            setPipelineResult(data);
            showSnackbar(`Pipeline run completed with status: ${data.status}`, data.status === "success" ? "success" : (data.status === "failure" ? "error" : "info"));
          } catch (err) {
            showSnackbar(`Error running pipeline: ${err.message}`, "error");
            setPipelineResult({ status: "error", message: err.message, pipeline_run_details: [{step_name: "Pipeline Error", status: "error", detail: err.message}] });
          } finally {
            setLoading(false);
          }
        }

        if (!conversationId) return null;


        return (
          <Paper sx={{ p: 2, mb: 2.5 }} elevation={2} className="interactive-card non-interactive">
            <Typography variant="h6" gutterBottom className={isDarkMode ? 'heading-glow' : ''}>CI/CD Pipeline Simulation</Typography>
            <Box display="flex" flexDirection="column" gap={1.5} mb={2}>
              <TextField
                label="Build Command (from request, project config overrides)"
                size="small"
                value={buildCmd}
                onChange={(e) => setBuildCmd(e.target.value)}
                variant="outlined"
                disabled={loading}
              />
              <TextField
                label="Test Command (from request, project config overrides)"
                size="small"
                value={testCmd}
                onChange={(e) => setTestCmd(e.target.value)}
                variant="outlined"
                disabled={loading}
              />
              <TextField
                label="Lint Command (from request, project config overrides)"
                size="small"
                value={lintCmd}
                onChange={(e) => setLintCmd(e.target.value)}
                variant="outlined"
                disabled={loading}
              />
              <Tooltip title="Execute the defined pipeline (aggregator uses project config first, then these commands as fallback).">
                <Box component="span" sx={{ display: 'inline-flex' }}> {/* Wrapper for Tooltip */}
                  <Button variant="contained" color="primary" onClick={runPipeline} disabled={loading || !aggregatorUrl}>
                    {loading ? <CircularProgress size={24} color="inherit" /> : "Run Pipeline"}
                  </Button>
                </Box>
              </Tooltip>
            </Box>
            {pipelineResult && (
              <Paper variant="outlined" sx={{ p: 1.5, borderColor: 'var(--card-border)', background: isDarkMode ? 'var(--bg-end)' : '#f5f5f5' }}>
                <Typography variant="body1" sx={{fontWeight: 'medium'}}>
                  Pipeline Status: <span style={{color: pipelineResult.status === "success" ? "var(--logo-c-ai)" : (pipelineResult.status === "failure" || pipelineResult.status === "error" ? "var(--logo-c-name)" : "var(--logo-c-dot)")}}>{pipelineResult.status}</span>
                </Typography>
                 {pipelineResult.message && (
                  <Typography variant="body2" sx={{ marginTop: 1 }}>
                    Message: {pipelineResult.message}
                  </Typography>
                )}
                {pipelineResult.supervisor_suggestion && (
                  <Typography variant="body2" sx={{ color: "var(--logo-c-name)", my: 0.5 }}>
                    Suggestion: {pipelineResult.supervisor_suggestion}
                  </Typography>
                )}
                {pipelineResult.merged_prs && pipelineResult.merged_prs.length > 0 && (
                  <Typography variant="body2" sx={{ color: "var(--logo-c-ai)", my: 0.5 }}>
                    Merged PR IDs: {pipelineResult.merged_prs.join(", ")}
                  </Typography>
                )}
                {pipelineResult.pipeline_run_details && pipelineResult.pipeline_run_details.length > 0 && (
                    <Box sx={{mt:1}}>
                        <Typography variant="body2" sx={{fontWeight:'medium'}}>Step Details:</Typography>
                        <Box sx={{maxHeight: '200px', overflowY: 'auto', background: isDarkMode ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)', p:1, borderRadius:1}}>
                        {pipelineResult.pipeline_run_details.map((step, idx) => (
                            <Box key={idx} sx={{mb:1, pb:1, borderBottom: idx < pipelineResult.pipeline_run_details.length - 1 ? `1px dashed ${isDarkMode ? 'var(--card-border)' : '#ddd'}` : 'none'}}>
                                <Typography variant="caption" sx={{fontWeight:'bold', color: step.status === 'passed' ? 'success.main' : (step.status === 'failed' ? 'error.main' : 'text.secondary')}}>{step.step_name}: {step.status.toUpperCase()}</Typography>
                                <pre style={{ whiteSpace: "pre-wrap", fontSize: "0.8em", margin:0, opacity:0.8 }}>{step.detail ? step.detail.substring(0,200) + (step.detail.length > 200 ? '...' : '') : '(No detail)'}</pre>
                            </Box>
                        ))}
                        </Box>
                    </Box>
                )}
              </Paper>
            )}
          </Paper>
        );
      }

      /***************************************************************
       * StructuredDataPanel
       ***************************************************************/
      function StructuredDataPanel({ aggregatorUrl, conversationId, showSnackbar }) {
        const [dataType, setDataType] = React.useState("");
        const [jsonValue, setJsonValue] = React.useState("");
        const [structuredList, setStructuredList] = React.useState([]);
        const [filterType, setFilterType] = React.useState("");
        const [loadingData, setLoadingData] = React.useState(false);
        const isDarkMode = document.body.classList.contains('dark-mode');


        async function handleAdd() {
          if (!dataType.trim()) {
            showSnackbar("Data Type cannot be empty for structured data.", "warning");
            return;
          }
          if (!jsonValue.trim()) {
            showSnackbar("JSON Value cannot be empty.", "warning");
            return;
          }
          let parsedJson = {};
          try {
            parsedJson = JSON.parse(jsonValue);
          } catch (err) {
            showSnackbar(`Invalid JSON: ${err.message}`, "error");
            return;
          }
          try {
            await addStructuredData(aggregatorUrl, conversationId, dataType.trim(), parsedJson);
            showSnackbar(`Structured data of type "${dataType.trim()}" added!`, "success");
            setDataType("");
            setJsonValue("");
            loadData();
          } catch (err) {
            showSnackbar(`Error adding structured data: ${err.message}`, "error");
          }
        }

        async function loadData() {
          if (!conversationId || !aggregatorUrl) return;
          setLoadingData(true);
          try {
            const resp = await listStructuredData(aggregatorUrl, conversationId, filterType.trim() || null);
            setStructuredList(resp.structured_data || []);
            showSnackbar(`Structured data for type "${filterType || 'all'}" loaded.`, "info");
          } catch (err) {
            console.error("Error loading structured data:", err);
            showSnackbar(`Error loading structured data: ${err.message}`, "error");
          } finally {
            setLoadingData(false);
          }
        }

        React.useEffect(() => {
            if (conversationId && aggregatorUrl) loadData();
            else setStructuredList([]);
        }, [conversationId, filterType, aggregatorUrl]);

        if (!conversationId) return null;


        return (
          <Paper className="structured-panel interactive-card non-interactive" sx={{ p: 2, mb: 2.5 }} elevation={2}>
            <Typography variant="h6" gutterBottom className={isDarkMode ? 'heading-glow' : ''}>Structured Data Store</Typography>
            <Box display="flex" flexDirection="column" gap={1.5} mb={2}>
              <TextField
                label="Data Type (e.g., requirement, bug_report)"
                size="small"
                value={dataType}
                onChange={(e) => setDataType(e.target.value)}
                variant="outlined"
                 disabled={!aggregatorUrl}
              />
              <TextField
                label="JSON Value"
                size="small"
                multiline
                minRows={3}
                maxRows={10}
                value={jsonValue}
                onChange={(e) => setJsonValue(e.target.value)}
                placeholder='{\n  "id": "REQ-001",\n  "description": "User login feature",\n  "priority": "high"\n}'
                variant="outlined"
                InputProps={{ sx: { fontFamily: 'monospace' } }}
                 disabled={!aggregatorUrl}
              />
              <Tooltip title="Add the specified data type and JSON value to the structured data store.">
                <span>
                  <Button variant="contained" color="primary" onClick={handleAdd} disabled={!aggregatorUrl || !dataType.trim() || !jsonValue.trim()}>
                    Add Structured Data
                  </Button>
                </span>
              </Tooltip>
            </Box>

            <Box display="flex" gap={1.5} alignItems="center" mb={1.5} flexWrap="wrap">
              <TextField
                label="Filter by Type (leave blank for all)"
                size="small"
                value={filterType}
                onChange={(e) => setFilterType(e.target.value)}
                variant="outlined"
                sx={{ width: 220 }}
                 disabled={!aggregatorUrl}
              />
              <Tooltip title="Load or refresh the list of structured data items based on the filter.">
                <span>
                  <Button variant="outlined" onClick={loadData} disabled={loadingData || !aggregatorUrl}>
                    {loadingData ? <CircularProgress size={22} sx={{mr:1}}/> : null}
                    Load/Refresh Data
                  </Button>
                </span>
              </Tooltip>
            </Box>

            {structuredList.length === 0 && <Typography variant="body2" sx={{color: 'text.secondary'}}>No structured data found for this filter and project.</Typography>}
            <Box sx={{maxHeight: '300px', overflowY: 'auto'}}>
                {structuredList.map((item) => (
                <Paper key={item.id} variant="outlined" sx={{ p: 1.5, mb: 1, borderColor: 'var(--card-border)', background: isDarkMode ? 'var(--bg-end)' : '#f9f9f9' }}>
                    <Typography variant="caption" display="block" sx={{color: 'text.secondary'}}>
                    ID: {item.id}
                    </Typography>
                    <Typography variant="body2" sx={{fontWeight: 'medium'}}>
                    Type: <span style={{color: isDarkMode ? 'var(--logo-c-not)' : 'primary.dark'}}>{item.data_type}</span>
                    </Typography>
                    <pre style={{margin:0, mt:0.5, fontSize: '0.85em', background: isDarkMode ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)', padding: '8px', borderRadius: '4px', whiteSpace: 'pre-wrap', wordBreak: 'break-all'}}>{JSON.stringify(item.json_data, null, 2)}</pre>
                </Paper>
                ))}
            </Box>
          </Paper>
        );
      }

      /***************************************************************
       * ChatMessage Renderer with Prism.js for code blocks
       ***************************************************************/
      const ChatMessageContent = React.memo(({ rawContent, role, isDarkMode }) => {
        const parts = React.useMemo(() => {
            const codeBlockRegex = /```(?:([\w+-]+)\s*)?(?:\/\/\s*([\w.:/\-]+)\s*|\#\s*([\w.:/\-]+)\s*)?\r?\n([\s\S]*?)\r?\n```/g; // Added : / to filename
            let lastIndex = 0;
            const newParts = [];
            let match;

            while ((match = codeBlockRegex.exec(rawContent)) !== null) {
                if (match.index > lastIndex) {
                    newParts.push({ type: 'text', content: rawContent.substring(lastIndex, match.index) });
                }
                const lang = (match[1] || '').trim().toLowerCase() || 'plaintext';
                const code = match[4] || '';
                newParts.push({ type: 'code', content: code.trim(), lang: lang });
                lastIndex = match.index + match[0].length;
            }

            if (lastIndex < rawContent.length) {
                newParts.push({ type: 'text', content: rawContent.substring(lastIndex) });
            }
            return newParts;
        }, [rawContent]);

        React.useEffect(() => {
            const hasCode = parts.some(p => p.type === 'code');
            if (hasCode && window.Prism) {
                window.Prism.highlightAll();
            }
        }, [parts]);


        return (
            <div>
                {parts.map((part, index) => {
                    if (part.type === 'code') {
                        const languageClass = `language-${part.lang || 'plaintext'}`;
                        return (
                            <div key={index} className="chat-code-block">
                                <pre className={`line-numbers ${languageClass}`} data-prismjs-copy={`Copy ${part.lang} code`}>
                                    <code className={languageClass}>
                                        {part.content}
                                    </code>
                                </pre>
                            </div>
                        );
                    } else {
                        return <Typography component="div" variant="body2" key={index} dangerouslySetInnerHTML={{ __html: formatAgentText(part.content) }} />;
                    }
                })}
            </div>
        );
      });


      /***************************************************************
       * StepChat (Memoized)
       ***************************************************************/
      const MemoizedStepChat = React.memo(function StepChat({
        aggregatorUrl,
        conversationId,
        stepIndex,
        // agentPort, // OLD - replaced by agentIdentifierObj
        agentIdentifierObj, // NEW - full agent object for this step
        role,
        roleDescription,
        maxTokens,
        workspaces,
        initialUserMsg,
        onFinishStep,
        // contextAgentPort, // OLD - replaced by contextAgentIdentifier from App state
        contextAgentIdentifier, // NEW - full agent object for context tasks
        setWorkspaces,
        onAgentRunCommand,
        onAddDeveloperFixStep,
        showSnackbar,
        isDarkMode // Passed from ChainManager
      }) {
        const [messages, setMessages] = React.useState([]);
        const [inputText, setInputText] = React.useState("");
        const [finished, setFinished] = React.useState(false);
        const [working, setWorking] = React.useState(false);

        const [reRouteRole, setReRouteRole] = React.useState("");
        const [showReRoute, setShowReRoute] = React.useState(false);
        const chatBoxRef = React.useRef(null);

        React.useEffect(() => {
          setFinished(false);
          setMessages([]);
          setShowReRoute(false);
          if (initialUserMsg) {
            const userMsg = { id: `msg-${Date.now()}`, role: "User", content: initialUserMsg, status: "sent" };
            setMessages([userMsg]);
            handleSendInternal(userMsg.content, userMsg.id);
          }
        }, [stepIndex, initialUserMsg]); // initialUserMsg dependency might cause re-runs if it changes often. Ensure it's stable per step start.

         React.useEffect(() => {
            if (chatBoxRef.current) {
                chatBoxRef.current.scrollTop = chatBoxRef.current.scrollHeight;
            }
        }, [messages]);


        function getLastAgentMessage() {
          return [...messages].reverse().find((m) => m.role !== "User" && m.role !== "system" && m.role !== "System");
        }

        async function handleSend() {
          if (!inputText.trim() || finished || working || !agentIdentifierObj) {
            if (!agentIdentifierObj) showSnackbar("No agent assigned to this step!", "error");
            return;
          }
          const optimisticId = `msg-${Date.now()}`;
          const userMsg = { id: optimisticId, role: "User", content: inputText, status: "sending" };

          setMessages((prev) => [...prev, userMsg]);
          const currentInput = inputText;
          setInputText("");

          try {
            await handleSendInternal(currentInput, optimisticId);
            setMessages(prev => prev.map(m => m.id === optimisticId ? {...m, status: "sent"} : m));
          } catch (error) {
             setMessages(prev => prev.map(m => m.id === optimisticId ? {...m, status: "failed", error: error.message} : m));
             showSnackbar(`Failed to send message: ${error.message}`, "error");
             setInputText(currentInput);
          }
        }

        function checkTesterFail(agentText) {
          if (role.toLowerCase().includes("tester")) {
            if (/\b(fail|failed|issue|bug)\b/i.test(agentText)) {
              onAddDeveloperFixStep && onAddDeveloperFixStep(stepIndex);
              showSnackbar("Tester reported 'fail'. A 'Developer (Fix)' step may have been added.", "warning");
            }
          }
        }

        async function handleDeveloperPR(agentText) {
          if (role.toLowerCase().includes("developer")) {
            const codeBlocks = parseCodeBlocksGeneric(agentText, true).filter(b => b.content.trim() !== "");
            if (codeBlocks.length > 0) {
              try {
                await submitPullRequest(aggregatorUrl, conversationId, codeBlocks.map(cb => ({title: cb.title, content: cb.content})), `Code from ${role} (Step ${stepIndex + 1})`);
                const prMsg = `[Developer submitted ${codeBlocks.length} code block(s) as a Pull Request.]`;
                setMessages((prev) => [...prev, { id: `msg-${Date.now()}`, role: "System", content: prMsg, status: "sent"}]);
                showSnackbar(prMsg, "success");
              } catch (err) {
                console.error("Error submitting PR:", err);
                const errMsg = `[Error submitting PR: ${err.message}]`;
                setMessages((prev) => [...prev, {id: `msg-${Date.now()}`, role: "System", content: errMsg, status: "error" }]);
                showSnackbar(errMsg, "error");
              }
            }
          }
        }


        async function handleSendInternal(userText, originalMessageId) {
          if (!agentIdentifierObj) {
            showSnackbar("No agent assigned to this step! Cannot send message.", "error");
            throw new Error("Agent not assigned for step.");
          }
          setWorking(true);
          try {
            const lastAgent = getLastAgentMessage();
            const filteredWorkspaces = workspaces
              .filter((w) => w.type !== "folder")
              .map((w) => ({
                type: w.type,
                title: w.title,
                content: w.content
              }));

            const result = await interactiveStepApi(aggregatorUrl, {
              conversation_id: conversationId,
              agentIdentifierObj: agentIdentifierObj, // Use the full agent object
              role,
              role_description: roleDescription,
              maxTokens,
              workspaces: filteredWorkspaces,
              user_message: userText,
              last_agent_message: lastAgent ? lastAgent.content : "",
              finish_step: false
            });

            const agentMsg = { id: `msg-${Date.now()}`, role: role, content: result.answer, status: "sent" };
            setMessages((prev) => [...prev, agentMsg]);

            await handleDeveloperPR(agentMsg.content);

            if (!role.toLowerCase().includes("developer")) {
              const parsedBlocks = parseForWorkspaces(agentMsg.content);
              if (parsedBlocks.length > 0) {
                const mergeMsg = `[Agent proposed ${parsedBlocks.length} workspace update(s). Merging them.]`;
                setMessages((prev) => [...prev, {id: `msg-${Date.now()}`, role: "System", content: mergeMsg, status: "sent"}]);
                showSnackbar(mergeMsg, "info");
              }
              parsedBlocks.forEach((b) => {
                setWorkspaces((prevWs) => {
                  const existing = prevWs.find((x) => x.title === b.title);
                  if (existing) {
                    const newContent = b.content;
                    return prevWs.map((x) => {
                      if (x.id === existing.id) {
                        return {
                          ...x,
                          content: newContent,
                          lang: b.lang || existing.lang,
                          type: b.type || existing.type,
                          versionHistory: [
                            ...(x.versionHistory || []),
                            { content: newContent, timestamp: Date.now() }
                          ].slice(-20)
                        };
                      }
                      return x;
                    });
                  } else {
                    const newId = "ws_" + Date.now() + "_" + Math.random().toString(36).substr(2, 5);
                    return [
                      ...prevWs,
                      {
                        id: newId,
                        title: b.title,
                        type: b.type,
                        lang: b.lang || "",
                        content: b.content,
                        parentId: null,
                        versionHistory: [{ content: b.content, timestamp: Date.now() }]
                      }
                    ];
                  }
                });
              });
            }

            checkTesterFail(agentMsg.content);
            // Pass conversationId to detectAndExecute for aggregator commands
            // Client-side detection of TERMINAL_CMD might be redundant if aggregator background task handles it.
            // await detectAndExecuteTerminalCommands(agentMsg.content, onAgentRunCommand, showSnackbar, conversationId);


            if (/incomplete|send\s+back|issue|missing|needs revision|cannot proceed/gi.test(agentMsg.content)) {
              setShowReRoute(true);
            } else {
              setShowReRoute(false);
            }

            let fullConvForCtx = "";
            messages.concat(agentMsg).forEach((m) => {
              fullConvForCtx += `${m.role}: ${m.content}\n\n`;
            });
            // Use the globally selected contextAgentIdentifier
            if (contextAgentIdentifier && aggregatorUrl) {
              await contextAgentCall(
                aggregatorUrl,
                conversationId,
                contextAgentIdentifier, // Use the passed full object
                fullConvForCtx
              );
            }
          } catch (err) {
            console.error("Error in handleSendInternal:", err);
            const errorSystemMsg = { id: `msg-${Date.now()}`, role: "System", content: `[Error: ${err.message}]`, status: "error" };
            setMessages((prev) => [...prev, errorSystemMsg]);
            throw err;
          } finally {
            setWorking(false);
          }
        }

        async function handleFinish() {
          if (finished || working || !agentIdentifierObj) {
            if (!agentIdentifierObj) showSnackbar("No agent assigned to this step!", "error");
            return;
          }
          setWorking(true);
          try {
            const lastAgent = getLastAgentMessage();
            const filteredWorkspaces = workspaces
              .filter((w) => w.type !== "folder")
              .map((w) => ({ type: w.type, title: w.title, content: w.content }));

            await interactiveStepApi(aggregatorUrl, {
              conversation_id: conversationId, agentIdentifierObj: agentIdentifierObj, role,
              role_description: roleDescription, maxTokens, workspaces: filteredWorkspaces,
              user_message: "[User has chosen to finalize this step without further input.]",
              last_agent_message: lastAgent ? lastAgent.content : "", finish_step: true
            });

            setFinished(true);
            const finalMsg = { id: `msg-${Date.now()}`, role: "System", content: "[Step finalized by user.]", status: "sent" };
            const updatedMessages = [...messages, finalMsg];
            setMessages(updatedMessages);
            showSnackbar("Step finalized.", "success");
            onFinishStep && onFinishStep(updatedMessages, agentIdentifierObj); // Pass agentIdentifierObj used

            let fullConv = "";
            updatedMessages.forEach((m) => { fullConv += `${m.role}: ${m.content}\n\n`; });
            if (contextAgentIdentifier && aggregatorUrl) { // Use globally selected context agent
              await contextAgentCall(
                aggregatorUrl, conversationId, contextAgentIdentifier, fullConv,
                "User just finished this step. Next role should speak."
              );
            }
          } catch (err) {
            console.error("Error finishing step:", err);
            const errSysMsg = {id: `msg-${Date.now()}`, role: "System", content: `[Error finalizing step: ${err.message}]`, status:"error"};
            setMessages((prev) => [...prev, errSysMsg]);
            showSnackbar(`Error finalizing step: ${err.message}`, "error");
          } finally {
            setWorking(false);
          }
        }

        function handleSendToAnotherRole() {
          if (!reRouteRole.trim()) {
              showSnackbar("Re-route role cannot be empty.", "warning");
              return;
          }
          const userMsg = {
            id: `msg-${Date.now()}`, role: "System", status: "sent",
            content: `Task conceptually routed to role: ${reRouteRole}. (Note: This UI does not yet implement cross-step re-routing beyond logging this intent).`
          };
          setMessages((prev) => [...prev, userMsg]);
          showSnackbar(`Task conceptually routed to: ${reRouteRole}. Further UI implementation for actual re-routing needed.`, "info");
          setShowReRoute(false);
          setReRouteRole("");
        }

        const agentDisplayName = agentIdentifierObj ? (agentIdentifierObj.name || `Port ${agentIdentifierObj.port}`) : 'N/A';

        return (
          <Paper sx={{ p: 2, mb: 2.5 }} elevation={3} className="interactive-card non-interactive"> {/* non-interactive to prevent hover on whole chat card */}
            <Typography variant="h5" gutterBottom className={isDarkMode ? 'heading-glow' : ''}>
              Step {stepIndex + 1} - Role: <span className={isDarkMode ? 'text-gradient-brand' : ''}>{role}</span> (Agent: {agentDisplayName})
            </Typography>
            {roleDescription && (
              <Typography variant="body2" sx={{ fontStyle: "italic", mb: 1.5, color: isDarkMode ? 'var(--text-secondary)' : 'text.secondary' }}>
                {roleDescription}
              </Typography>
            )}

            <Box className="chat-box" ref={chatBoxRef} sx={{mb:1.5, borderRadius:1}}>
              {messages.map((msg) => {
                const isAgentMessage = msg.role === role || msg.role === "Context Agent";
                const isUserMessage = msg.role === "User";
                const isSystemMessage = msg.role === "system" || msg.role === "System";
                const textAlign = isUserMessage ? 'right' : 'left';
                const bubbleColor = isUserMessage ?
                                      (isDarkMode ? 'var(--logo-c-dot)' : 'primary.light') :
                                    isSystemMessage ?
                                      (isDarkMode ? 'rgba(var(--card-bg-rgb, 22, 27, 34), 0.5)' : '#e0e0e0') :
                                    (isDarkMode ? 'var(--bg-end)' : '#f5f5f5');
                const textColor = isUserMessage ?
                                    (isDarkMode ? 'var(--bg-start)' : 'primary.contrastText') :
                                  isSystemMessage ?
                                    (isDarkMode ? 'var(--text-secondary)' : 'text.secondary') :
                                  'inherit';
                const borderRadius = isUserMessage ? '10px 10px 0 10px' : '10px 10px 10px 0';

                return (
                  <Box
                    key={msg.id}
                    className="chat-msg"
                    sx={{ textAlign, mb: 1 }}
                  >
                    <Paper
                        elevation={1}
                        sx={{
                            p:1.25, display: 'inline-block', maxWidth: '85%',
                            bgcolor: bubbleColor, color: textColor, borderRadius,
                            border: msg.status === 'failed' ? (isDarkMode ? '2px solid var(--logo-c-name)' : '2px solid red') : 'none',
                            opacity: msg.status === 'sending' ? 0.7 : 1,
                        }}
                    >
                        <Typography variant="caption" display="block" sx={{ fontWeight: 'bold', color: isUserMessage ? 'inherit' : (isAgentMessage ? (isDarkMode ? 'var(--text-heading-glow)' : 'secondary.main') : (isDarkMode ? 'var(--text-secondary)' : 'text.disabled')) }}>
                            {msg.role} {msg.status === 'sending' ? '(Sending...)' : msg.status === 'failed' ? '(Failed)' : ''}
                        </Typography>

                        <ChatMessageContent rawContent={msg.content} role={msg.role} isDarkMode={isDarkMode} />

                        {msg.status === 'failed' && msg.error &&
                            <Typography variant="caption" sx={{color: isDarkMode ? 'var(--logo-c-name)' : 'error.main', display:'block', mt:0.5}}>
                                Error: {msg.error}
                            </Typography>}
                    </Paper>
                  </Box>
                );
              })}
            </Box>

            {!finished && (
              <Box display="flex" mb={1.5} gap={1}>
                <TextField
                  variant="outlined"
                  size="small"
                  fullWidth
                  multiline
                  minRows={2} maxRows={5}
                  value={inputText}
                  onChange={(e) => setInputText(e.target.value)}
                  onKeyPress={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } }}
                  placeholder="Your response or instructions... (Shift+Enter for new line)"
                  disabled={working || !agentIdentifierObj} // Also disable if no agent assigned
                />
                <Button variant="contained" color="primary" onClick={handleSend} disabled={working || !inputText.trim() || !agentIdentifierObj} sx={{height: 'fit-content', alignSelf: 'flex-end', p: '10px 16px'}}>
                  Send
                </Button>
              </Box>
            )}

            {showReRoute && !finished && (
              <Box mb={1.5} p={1.5} component={Paper} variant="outlined" sx={{borderColor: 'var(--card-border)', background: isDarkMode ? 'rgba(var(--card-bg-rgb),0.5)' : 'rgba(255,239,186,0.3)'}}>
                <Typography variant="body2" gutterBottom>
                  This agent's response suggests something may be incomplete or requires action by a different role. You can provide more input above, or (conceptually) re-route this task.
                </Typography>
                <Box display="flex" gap={1} alignItems="center" mt={1}>
                  <TextField
                    label="Route to Role (e.g., Analyst, QA)"
                    size="small"
                    value={reRouteRole}
                    onChange={(e) => setReRouteRole(e.target.value)}
                    variant="outlined"
                    sx={{flexGrow: 1}}
                     disabled={working}
                  />
                  <Button variant="outlined" onClick={handleSendToAnotherRole}  disabled={working || !reRouteRole.trim()}>
                    Re-Route (Log Intent)
                  </Button>
                </Box>
              </Box>
            )}

            <Box display="flex" alignItems="center" gap={2} flexWrap="wrap">
              <Button
                variant="contained"
                color={finished ? "success" : "secondary"}
                onClick={handleFinish}
                disabled={finished || working || !agentIdentifierObj} // Also disable if no agent
              >
                {finished ? "Step Finalized" : "Finalize This Step"}
              </Button>

              {working && (
                <Box display="flex" alignItems="center" gap={1}>
                  <CircularProgress size={20} />
                  <Typography variant="body2" sx={{color: isDarkMode ? 'var(--text-secondary)' : 'text.secondary'}}>Agent is processing...</Typography>
                </Box>
              )}
            </Box>
          </Paper>
        );
      });

      /***************************************************************
       * ChainManager
       ***************************************************************/
      // function ChainManager({ aggregatorUrl, conversationId, contextAgentIdentifier, darkMode, showSnackbar }) { /* Removed duplicate definition */
      function ChainManager({ aggregatorUrl, conversationId, contextAgentIdentifier, darkMode, showSnackbar }) { /* This is the active definition */
            // ------------------------------------------------------------
           // workspace‐task‐modal integration
           // ------------------------------------------------------------
           const [wsModalOpen, setWsModalOpen] = React.useState(false);
            const [wsModalContext, setWsModalContext] = React.useState(null);
        
            // Cmd/Ctrl+Shift+T opens the modal with the current workspaces
            React.useEffect(() => {
              const handler = (e) => {
                const isMac = navigator.platform.toUpperCase().indexOf('MAC')>=0;
            if ((isMac ? e.metaKey : e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 't') {
                  e.preventDefault();
                  // Build a context object from current workspaces
                  setWsModalContext({
                    type: 'files',
                    // send only the non‐folder files
                    selectedFiles: workspaces.filter(w=> w.type!=='folder').map(w=>({
                      id: w.id,
                      title: w.title,
                      content: w.content,
                      lang: w.lang,
                    }))
                  });
                  setWsModalOpen(true);
                }
              };
              window.addEventListener('keydown', handler);
              return () => window.removeEventListener('keydown', handler);
            }, [workspaces]);
            // ------------------------------------------------------------
             // existing ChainManager state and effects...
        const [useAgentDiscovery, setUseAgentDiscovery] = React.useState(true);
        const [activeAgents, setActiveAgents] = React.useState([]); // Will store agent objects
        const [steps, setSteps] = React.useState([
          {
            agentIdentifierObj: null, // Store full agent object here
            role: "Developer",
            roleDescription: "Writes and maintains application code",
            maxTokens: 10000,
            temperature: null, // Default to aggregator/model default
          }
        ]);
        const [currentStepIndex, setCurrentStepIndex] = React.useState(0);
        const [inProgress, setInProgress] = React.useState(false);
        const [initialPrompt, setInitialPrompt] = React.useState("");

        const [workspaces, setWorkspaces] = React.useState([
          {
            id: "readme_" + Date.now(),
            type: "text",
            title: "Project README.md",
            content: "# Project Overview\n\nDescribe your project or plan here...\n",
            lang: "markdown",
            parentId: null,
            versionHistory: [
              {
                content: "# Project Overview\n\nDescribe your project or plan here...\n",
                timestamp: Date.now()
              }
            ]
          }
        ]);
        const [accumulatedContext, setAccumulatedContext] = React.useState("");

        const [autoRefreshPreview, setAutoRefreshPreview] = React.useState(true);
        const previewIframeRef = React.useRef(null);

        const [terminalLogs, setTerminalLogs] = React.useState([]);
        const [autoRunLogs, setAutoRunLogs] = React.useState([]);

        const orgTemplates = [
          {
            label: "Software Development Lifecycle (SDLC)",
            roles: [
              { role: "Business Analyst", roleDescription: "Analyze business needs, define requirements (user stories, acceptance criteria), and break them into development tasks.", maxTokens: 4000 },
              { role: "Lead Developer / Architect", roleDescription: "Designs the software architecture, defines technical standards, reviews code, and implements core complex features. Submits code via PRs.", maxTokens: 10000 },
              { role: "Developer", roleDescription: "Implements features based on tasks, writes unit tests, and fixes bugs. Submits code via PRs.", maxTokens: 8000 },
              { role: "QA Tester", roleDescription: "Develops test plans, executes tests (manual/automated) against requirements, reports bugs (clearly state 'fail' or 'pass' with details), and verifies fixes.", maxTokens: 4000 },
              { role: "Documentation Writer", roleDescription: "Creates and maintains user guides, API documentation, and project documentation based on implemented features and requirements.", maxTokens: 3000 }
            ]
          },
          {
            label: "Simple Web Project",
            roles: [
              { role: "Planner / UX Designer", roleDescription: "Outline the website structure, user flows, and content strategy. Create wireframes or mockups if applicable.", maxTokens: 3000 },
              { role: "Frontend Developer", roleDescription: "Implement the HTML, CSS, and JavaScript for the user interface based on the plan. Submits code via PRs.", maxTokens: 10000},
              { role: "Content Writer", roleDescription: "Write the textual content, imagery descriptions, and SEO metadata for the website.", maxTokens: 3000}
            ]
          },
          {
            label: "Data Analysis Pipeline",
            roles: [
              { role: "Data Analyst", roleDescription: "Defines data sources, cleaning procedures, and analysis questions. Interprets results.", maxTokens: 5000 },
              { role: "Data Engineer", roleDescription: "Implements data ingestion, transformation (ETL), and storage solutions. Writes scripts for data processing.", maxTokens: 8000},
              { role: "Report Generator", roleDescription: "Creates visualizations and reports from the analyzed data.", maxTokens: 4000}
            ]
          }
        ];
        const [orgTemplateSelected, setOrgTemplateSelected] = React.useState("");
        const [customOrgs, setCustomOrgs] = React.useState([]);
        const stepTemplates = [
          { label: "Developer", role: "Developer", roleDescription: "Implement code and features. Submit PRs.", maxTokens: 10000 },
          { label: "Tester (QA)", role: "Tester", roleDescription: "Test functionality, report 'fail' or 'pass' on issues, verify fixes.", maxTokens: 4000 },
          { label: "Analyst", role: "Business Analyst", roleDescription: "Define requirements, user stories, acceptance criteria.", maxTokens: 4000 },
          { label: "Code Reviewer", role: "Code Reviewer", roleDescription: "Review PRs for quality, correctness, and adherence to standards. Approve or request changes.", maxTokens: 5000 },
          { label: "Technical Writer", role: "Documentation Writer", roleDescription: "Create/update documentation based on changes.", maxTokens: 3000 },

        ];
        const [selectedTemplate, setSelectedTemplate] = React.useState("");
        const [autoRunState, setAutoRunState] = React.useState("stopped");
        const isDarkModeActive = darkMode;


        React.useEffect(() => {
          if (aggregatorUrl && useAgentDiscovery) {
            loadAgents();
          } else if (!useAgentDiscovery) {
            setActiveAgents([]);
          }
        }, [aggregatorUrl, useAgentDiscovery]);

        async function loadAgents() {
          try {
            const data = await fetchAgents(aggregatorUrl);
            setActiveAgents(data.active_agents || []); // Store agent objects
          } catch (err) {
            console.error("Error loading agents:", err);
            showSnackbar(`Error discovering agents: ${err.message}`, "error");
            setActiveAgents([]);
          }
        }

        React.useEffect(() => {
          if (conversationId) {
            handleLoadProjectFromAggregator(conversationId);
             setInProgress(false);
             setCurrentStepIndex(0);
             setAutoRunLogs([{role: "System", content: `Project "${conversationId}" loaded.`}]);
             setAccumulatedContext("");
             setTerminalLogs([]);
          } else {
             setInitialPrompt("");
             setSteps([{ agentIdentifierObj: null, role: "Developer", roleDescription: "Writes code", maxTokens: 10000, temperature: null }]);
             setWorkspaces([{ id: "readme_" + Date.now() , type: "text", title: "Project README.md", content: "# Project Overview\n\nDescribe your project or plan here...", lang: "markdown", parentId: null, versionHistory: [{ content: "# Project Overview\n\nDescribe your project or plan here...", timestamp: Date.now() }] }]);
             setCustomOrgs([]);
             setInProgress(false);
             setCurrentStepIndex(0);
             setAutoRunLogs([]);
             setAccumulatedContext("");
             setTerminalLogs([]);
             showSnackbar("No project selected. Ready to create a new one.", "info");
          }
        }, [conversationId, aggregatorUrl]); // Add aggregatorUrl as it might influence initial load too.

        const AUTOSAVE_INTERVAL = 30000;
        React.useEffect(() => {
          let autosaveTimer;
          if (conversationId && aggregatorUrl) {
            autosaveTimer = setInterval(() => {
              if (autoRunState === "running") return;
              saveProjectToAggregator();
            }, AUTOSAVE_INTERVAL);
          }
          return () => clearInterval(autosaveTimer);
        }, [conversationId, aggregatorUrl, initialPrompt, steps, workspaces, customOrgs, autoRunState]);

        async function handleLoadProjectFromAggregator(cid) {
          if (!aggregatorUrl) {
             showSnackbar("Aggregator URL not set. Cannot load project from server.", "error");
             return;
          }
          if (!cid) { // Check if conversationId is valid
            showSnackbar("Cannot load project: No Project ID selected.", "warning");
            return;
          }

          showSnackbar(`Loading/Refreshing project "${cid}" from server...`, "info", { autoHideDuration: 2000 });
          try {
            const data = await getProject(aggregatorUrl, cid); // Backend now returns disk-synced data
            
            setInitialPrompt(data.initialPrompt || "");

            const loadedSteps = (data.steps && data.steps.length > 0 ? data.steps : [{ agentIdentifierObj: null, role: "Developer", roleDescription: "Writes code", maxTokens: 10000, temperature: null }])
                .map(step => ({
                    ...step,
                    agentIdentifierObj: step.agentIdentifier || step.agentIdentifierObj || null,
                    temperature: step.temperature === undefined ? null : step.temperature
                }));
            setSteps(loadedSteps);

            const processedWorkspaces = (data.workspaces || []).map(ws => {
              // Backend now sends 'id' as relative path (e.g., "src/file.js" or "folder_name")
              // 'title' as basename (e.g., "file.js" or "folder_name")
              // 'parentId' as relative path of parent folder (or null/"" for root)
              return {
                ...ws,
                id: ws.id, 
                title: ws.title, 
                parentId: ws.parentId === "" ? null : ws.parentId, 
                lang: ws.lang || "",
                // Version history for items loaded from disk starts fresh with the disk content
                versionHistory: ws.content ? [{ content: ws.content, timestamp: Date.now() }] : []
              };
            });
            
            if (processedWorkspaces.length === 0 && cid) { // Only add default if project exists and is truly empty
                processedWorkspaces.push({
                    id: "README.md", 
                    type: "text",
                    title: "README.md",
                    content: "# Project Overview\n\nWelcome! This project is currently empty. Describe your project or plan here...",
                    lang: "markdown",
                    parentId: null,
                    versionHistory: [{ content: "# Project Overview\n\nWelcome! This project is currently empty. Describe your project or plan here...", timestamp: Date.now() }]
                });
                 showSnackbar(`Project "${cid}" was empty on server; initialized with a README.md.`, "info");
            }
            setWorkspaces(processedWorkspaces);

            setCustomOrgs(data.customOrgs || []);
            showSnackbar(`Project "${cid}" loaded/refreshed successfully.`, "success");
          } catch (err) {
            showSnackbar(`Error loading project "${cid}" from server: ${err.message}. UI may be out of sync.`, "error");
             // Optionally, clear UI or set to a specific error state
             // For now, we'll keep current UI state but warn user.
             console.error("Error in handleLoadProjectFromAggregator:", err);
          }
        }

        async function saveProjectToAggregator() {
          if (!conversationId || !aggregatorUrl) return;
          const projectDataToSave = {
            initialPrompt,
            // Steps will now have agentIdentifierObj which is an object. Aggregator expects this as dict.
            steps: steps.map(step => ({
                 ...step,
                 agentIdentifier: step.agentIdentifierObj // Ensure 'agentIdentifier' (or aliased Pydantic field) matches backend
            })),
            workspaces,
            customOrgs,
            // contextAgentIdentifierObj: contextAgentIdentifier, // If saving the global context agent with project
          };
          try {
            await putProject(aggregatorUrl, conversationId, projectDataToSave);
            const autosaveMsg = `Project "${conversationId}" autosaved to aggregator.`;
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: `[${new Date().toLocaleTimeString()}] ${autosaveMsg}`}]); // Keep log trimmed
          } catch (err) {
            console.error("Autosave server error:", err);
            const errorMsg = `Autosave to aggregator FAILED: ${err.message}`;
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: `[${new Date().toLocaleTimeString()}] ${errorMsg}`}]);
            showSnackbar(errorMsg, "error");
          }
        }
                // Inside ChainManager
        function handleApplyModalChanges(acceptedChanges, overallExplanation) {
            // acceptedChanges is an array: { fileId, title, newContent, isNew, originalContent, explanation }
            let newWorkspaces = [...workspaces];
            let filesUpdated = [];
        
            acceptedChanges.forEach(change => {
                const existingWsIndex = newWorkspaces.findIndex(ws => ws.id === change.fileId);
                if (change.isNew) {
                    // Create a new workspace item structure
                    const newFile = {
                        id: change.fileId, // The modal should generate a unique ID or use the proposed title
                        title: change.title, content: change.newContent,
                        type: determineTypeFromFilename(change.title), // Use global helper
                        lang: change.title.split('.').pop() || '',
                        versionHistory: [{ content: change.newContent, timestamp: Date.now() }],
                    };
                    newWorkspaces.push(newFile);
                    filesUpdated.push(newFile.title);
                } else if (existingWsIndex !== -1) {
                    const oldWs = newWorkspaces[existingWsIndex];
                    newWorkspaces[existingWsIndex] = {
                        ...oldWs,
                        content: change.newContent,
                        // Update version history
                        versionHistory: [...(oldWs.versionHistory || []), { content: change.newContent, timestamp: Date.now() }]
                    };
                    filesUpdated.push(oldWs.title);
                }
            });
        
            setWorkspaces(newWorkspaces);
            showSnackbar(`Applied changes from modal to: ${filesUpdated.join(', ')}. Explanation: ${overallExplanation.substring(0, 50)}...`, "success");
            // Optionally trigger saveProjectToAggregator()
        }
        
        // When ChainManager needs to open the modal (e.g., for re-route):
        // props.openWorkspaceModal(contextForModal, handleApplyModalChanges);

        function handleOrgSelect(label) {
          setOrgTemplateSelected(label);
          if (!label) return;
          const allOrgTemplates = [...orgTemplates, ...customOrgs];
          const found = allOrgTemplates.find((o) => o.label === label);
          if (!found) {
              showSnackbar(`Org template "${label}" not found.`, "warning");
              return;
          }
          const newSteps = found.roles.map((r) => ({
            agentIdentifierObj: activeAgents.length > 0 ? activeAgents[0] : null, // Default to first discovered agent
            role: r.role,
            roleDescription: r.roleDescription,
            maxTokens: r.maxTokens || 8000,
            temperature: null
          }));
          setSteps(newSteps);
          showSnackbar(`Applied org template: "${label}". Steps updated.`, "success");
        }

        function saveOrg() {
          if (steps.length === 0) {
              showSnackbar("Cannot save an empty org. Add some steps first.", "warning");
              return;
          }
          const orgName = prompt("Enter a name for this custom org (current step configuration):");
          if (!orgName || !orgName.trim()) {
              showSnackbar("Org name cannot be empty.", "info");
              return;
          }
          const orgData = {
            label: orgName.trim(),
            roles: steps.map((s) => ({
              role: s.role,
              roleDescription: s.roleDescription,
              maxTokens: s.maxTokens,
              // temperature not typically part of org role definition, but could be
            }))
          };
          setCustomOrgs((prev) => {
             const existing = prev.find(o => o.label === orgData.label);
             if (existing) {
                showSnackbar(`Org "${orgData.label}" already exists. Please choose a different name or delete the existing one first.`, "error");
                return prev;
             }
             showSnackbar(`Custom org "${orgName.trim()}" saved!`, "success");
             return [...prev, orgData];
          });
        }

        function handleImportOrgs(e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
            try {
              const data = JSON.parse(evt.target.result);
              let orgsToImport = [];
              if (Array.isArray(data)) {
                orgsToImport = data;
              } else if (data && data.customOrgs && Array.isArray(data.customOrgs)) {
                orgsToImport = data.customOrgs;
              } else if (data && data.standardOrgTemplates && Array.isArray(data.standardOrgTemplates)) {
                orgsToImport = data.standardOrgTemplates.concat(data.customOrgs || []);
              } else if (typeof data === 'object' && data !== null) {
                  if (data.label && Array.isArray(data.roles)) {
                      orgsToImport = [data];
                  }
              }

              if (orgsToImport.length === 0) {
                showSnackbar("No valid org definitions found in the imported file.", "warning");
                return;
              }
              mergeImportedOrgs(orgsToImport);
            } catch (err) {
              showSnackbar(`Error importing orgs: ${err.message}`, "error");
            }
          };
          reader.readAsText(file);
          e.target.value = null;
        }

        function mergeImportedOrgs(imported) {
          let addedCount = 0;
          let skippedCount = 0;
          let invalidCount = 0;

          setCustomOrgs((prev) => {
            const existingLabels = new Set(prev.map((o) => o.label));
            const merged = [...prev];
            imported.forEach((org) => {
              if (org && typeof org.label === 'string' && org.label.trim() !== "" && Array.isArray(org.roles) &&
                  org.roles.every(role => typeof role.role === 'string' && typeof role.roleDescription === 'string')) {
                  if (!existingLabels.has(org.label.trim())) {
                    const validatedRoles = org.roles.map(r => ({
                        role: r.role,
                        roleDescription: r.roleDescription,
                        maxTokens: r.maxTokens || 8000
                    }));
                    merged.push({ ...org, label: org.label.trim(), roles: validatedRoles });
                    existingLabels.add(org.label.trim());
                    addedCount++;
                  } else {
                    skippedCount++;
                  }
              } else {
                  console.warn("Skipped invalid org structure during import:", org);
                  invalidCount++;
              }
            });
            return merged;
          });
          let reportMsg = `Orgs import complete. Added: ${addedCount}.`;
          if (skippedCount > 0) reportMsg += ` Skipped (duplicates): ${skippedCount}.`;
          if (invalidCount > 0) reportMsg += ` Invalid structures: ${invalidCount}.`;
          showSnackbar(reportMsg, addedCount > 0 ? "success" : "info");
        }


        function addStep() {
          setSteps((prev) => [
            ...prev,
            { agentIdentifierObj: activeAgents.length > 0 ? activeAgents[0] : null, role: "New Agent Role", roleDescription: "Define purpose", maxTokens: 8000, temperature: null }
          ]);
        }
        function removeStep(idx) {
          if (steps.length <= 1) {
            showSnackbar("Cannot remove the last step.", "warning");
            return;
          }
          setSteps((prev) => prev.filter((_, i) => i !== idx));
        }
        function handleStepChange(idx, field, val) {
          setSteps((prev) => {
            const clone = [...prev];
            if (field === "agentIdentifierObj") {
              clone[idx].agentIdentifierObj = val; // val is the agent object or null
            } else if (field === "maxTokens") {
              const num = parseInt(val, 10);
              clone[idx].maxTokens = (!val || isNaN(num) || num <= 0) ? 8000 : num;
            } else if (field === "temperature") {
                const tempVal = parseFloat(val);
                clone[idx].temperature = (isNaN(tempVal) || tempVal < 0 || tempVal > 2) ? null : tempVal; // null for default
            } else {
              clone[idx][field] = val;
            }
            return clone;
          });
        }
        function addTemplateStep() {
          if (!selectedTemplate) {
            showSnackbar("No step template selected.", "info");
            return;
          }
          const template = stepTemplates.find((t) => t.label === selectedTemplate);
          if (!template) return;
          setSteps((prev) => [
            ...prev,
            {
              agentIdentifierObj: activeAgents.length > 0 ? activeAgents[0] : null,
              role: template.role,
              roleDescription: template.roleDescription,
              maxTokens: template.maxTokens,
              temperature: null
            }
          ]);
          setSelectedTemplate("");
          showSnackbar(`Added step: "${template.label}".`, "success");
        }

        function moveStep(idx, direction) {
            if (direction === 'up' && idx <=0) return;
            if (direction === 'down' && idx >= steps.length -1) return;

            setSteps(prevSteps => {
                const newSteps = [...prevSteps];
                const item = newSteps.splice(idx, 1)[0];
                if (direction === 'up') {
                    newSteps.splice(idx - 1, 0, item);
                } else {
                    newSteps.splice(idx + 1, 0, item);
                }
                return newSteps;
            });
        }

        function handleAddDeveloperFixStep(currentStepFailedIndex) {
          const fixStep = {
            agentIdentifierObj: activeAgents.length > 0 ? activeAgents[0] : null,
            role: "Developer (Fix)",
            roleDescription: `Address issues found by Tester in step ${currentStepFailedIndex + 1}. Review previous logs and code. Submit PR with fixes.`,
            maxTokens: 10000,
            temperature: null
          };
          setSteps((prev) => {
            const arr = [...prev];
            arr.splice(currentStepFailedIndex + 1, 0, fixStep);
            return arr;
          });
          const logMsg = `Auto-added "Developer (Fix)" Step after Tester (Step ${currentStepFailedIndex + 1}) reported issues.`;
          setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: logMsg}]);
          showSnackbar(logMsg, "info");
        }

        async function handleRunCommand(cmd, cmdConversationId = null) { // Added cmdConversationId
          if (!aggregatorUrl) {
              showSnackbar("Aggregator URL not set. Cannot run terminal command.", "error");
              setTerminalLogs(prev => [...prev.slice(-100), `[${new Date().toLocaleTimeString()}] CMD FAILED (no aggregator): ${cmd}`]);
              return;
          }
          const timestamp = new Date().toLocaleTimeString();
          const cmdLogEntry = `[${timestamp}] CMD (in ${cmdConversationId || 'global'} context): ${cmd}`;
          setTerminalLogs((prev) => [...prev.slice(-100), cmdLogEntry]);
          setAutoRunLogs(prev => [...prev.slice(-100), {role: "Terminal", content: cmdLogEntry}]);

          try {
            const { stdout, stderr, code } = await runTerminalCommand(aggregatorUrl, cmd, cmdConversationId); // Pass conversationId
            let outputMsg = "";
            if (stdout) outputMsg += `${stdout}`;
            if (stderr) outputMsg += `\n${stderr.startsWith("ERROR:") ? "" : "ERROR: "}${stderr}`;
            outputMsg += `\n(Exit code: ${code})`;

            setTerminalLogs((prev) => [...prev.slice(-100), outputMsg]);
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "Terminal", content: `OUTPUT (for ${cmd.substring(0,20)}...): ${outputMsg.substring(0, 200)}${outputMsg.length > 200 ? '...' : ''}`}]);
          } catch (error) {
            const errorOutput = `\nERROR executing command: ${error.message}\n(Exit code: -1)`;
            setTerminalLogs((prev) => [...prev.slice(-100), errorOutput]);
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "Terminal", content: `ERROR (for ${cmd.substring(0,20)}...): ${error.message}`}]);
            showSnackbar(`Terminal command "${cmd}" failed: ${error.message}`, "error");
          }
        }

        React.useEffect(() => {
            let isMounted = true;
            async function runCurrentAutoStep() {
                if (autoRunState === "running" && isMounted) {
                    if (currentStepIndex >= steps.length) {
                        setAutoRunState("stopped");
                        setInProgress(false);
                        const completionMsg = "All auto-run steps completed! Project is done.";
                        setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: completionMsg}]);
                        showSnackbar(completionMsg, "success");
                        setWorkspaces((prev) =>
                            prev.map((ws) => {
                                if (ws.title.toLowerCase().includes("readme")) {
                                return {
                                    ...ws,
                                    content: ws.content + "\n\n---\n**Project Auto-Run Summary (Completed " + new Date().toLocaleString() + ")**:\n" + accumulatedContext,
                                    versionHistory: [...(ws.versionHistory || []), {content: ws.content + "\n\n---\n**Project Auto-Run Summary**:\n" + accumulatedContext, timestamp: Date.now()}]
                                };
                                }
                                return ws;
                            })
                        );

                        if (conversationId) {
                          await handleLoadProjectFromAggregator(conversationId); // Final refresh after auto-run
                        }
                        return;
                    }
                    await autoRunStep(currentStepIndex);
                     if (isMounted && autoRunState === "running") { // Check again before incrementing
                        setCurrentStepIndex(prev => prev + 1);
                    }
                }
            }
            runCurrentAutoStep();
            return () => { isMounted = false; };
        }, [autoRunState, currentStepIndex]); // Dependencies should be minimal and accurate


        async function autoRunStep(idx) {
          const stepData = steps[idx];
          setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: `--- Starting Auto-Run Step ${idx + 1}: ${stepData.role} ---`}]);

          if (!stepData.agentIdentifierObj) { // Check for assigned agent object
            const noAgentMsg = `No agent assigned for step #${idx + 1} (${stepData.role}). Auto-run halted.`;
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: noAgentMsg}]);
            showSnackbar(noAgentMsg, "error");
            setAutoRunState("stopped");
            setInProgress(false);
            return;
          }

          let currentConversationHistory = [];
          const userMsgForAgent = idx === 0 ? initialPrompt : accumulatedContext;

          if (userMsgForAgent.trim()) {
            currentConversationHistory.push({ role: "User", content: userMsgForAgent.trim() });
            setAutoRunLogs((prev) => [...prev.slice(-100), { role: `User (to ${stepData.role})`, content: userMsgForAgent.trim().substring(0,300) + (userMsgForAgent.trim().length > 300 ? '...' : '') }]);
          } else if (idx > 0 && !accumulatedContext.trim()){
             setAutoRunLogs((prev) => [...prev.slice(-100), { role: `System (to ${stepData.role})`, content: "[No specific prior context to pass, proceeding with role's objective.]" }]);
          } else if (idx === 0 && !initialPrompt.trim()) {
             setAutoRunLogs((prev) => [...prev.slice(-100), { role: `System (to ${stepData.role})`, content: "[No initial prompt, proceeding with role's objective based on its description.]" }]);
          }


          try {
            const filteredWorkspaces = workspaces
              .filter((w) => w.type !== "folder")
              .map((w) => ({ type: w.type, title: w.title, content: w.content }));

            const result = await interactiveStepApi(aggregatorUrl, {
              conversation_id: conversationId,
              agentIdentifierObj: stepData.agentIdentifierObj, // Pass full object
              role: stepData.role,
              role_description: stepData.roleDescription,
              maxTokens: stepData.maxTokens,
              temperature: stepData.temperature, // Pass temperature
              workspaces: filteredWorkspaces,
              user_message: userMsgForAgent,
              last_agent_message: "", // No last_agent_message in auto-run simple model
              finish_step: false
            });

            const agentMsg = { role: stepData.role, content: result.answer };
            currentConversationHistory.push(agentMsg);
            setAutoRunLogs((prev) => [...prev.slice(-100), agentMsg]);

            if (stepData.role.toLowerCase().includes("developer")) {
              const codeBlocks = parseCodeBlocksGeneric(agentMsg.content, true).filter(b => b.content.trim() !== "");
              if (codeBlocks.length > 0) {
                await submitPullRequest(aggregatorUrl, conversationId, codeBlocks.map(cb => ({title: cb.title, content: cb.content})), `Auto-run: ${stepData.role} code changes (Step ${idx + 1})`);
                setAutoRunLogs(prev => [...prev.slice(-100), {role:"System", content: `[${stepData.role}] Submitted ${codeBlocks.length} code block(s) as a Pull Request.`}]);
              }
            } else {
              const parsedBlocks = parseForWorkspaces(agentMsg.content);
               if (parsedBlocks.length > 0) {
                 setAutoRunLogs(prev => [...prev.slice(-100), {role:"System", content: `[${stepData.role}] Proposed ${parsedBlocks.length} workspace update(s). Merging.`}]);
               }
              parsedBlocks.forEach((b) => {
                setWorkspaces((prevWs) => {
                  const existing = prevWs.find((x) => x.title === b.title);
                  if (existing) {
                    return prevWs.map((x) => x.id === existing.id ? { ...x, content: b.content, lang: b.lang || existing.lang, type: b.type || existing.type, versionHistory: [...(x.versionHistory || []), {content: b.content, timestamp: Date.now()}].slice(-20) } : x);
                  } else {
                    const newId = "ws_" + Date.now() + "_" + Math.random().toString(36).substr(2, 5);
                    return [...prevWs, { id: newId, title: b.title, type: b.type, lang: b.lang || "", content: b.content, parentId: null, versionHistory: [{content: b.content, timestamp: Date.now()}] }];
                  }
                });
              });
            }

            if (stepData.role.toLowerCase().includes("tester") && /\b(fail|failed|issue|bug)\b/i.test(agentMsg.content)) {
              handleAddDeveloperFixStep(idx);
            }

            // For auto-run, commands are handled by aggregator's background detector.
            // Client-side detection might be redundant or cause double execution if not careful.
            // await detectAndExecuteTerminalCommands(agentMsg.content, handleRunCommand, showSnackbar, conversationId);

            if (contextAgentIdentifier && aggregatorUrl) {
              let convStr = "";
              currentConversationHistory.forEach((m) => { convStr += `${m.role}: ${m.content}\n\n`; });
              await contextAgentCall(aggregatorUrl, conversationId, contextAgentIdentifier, convStr, `Context after auto-run step ${idx+1} (${stepData.role}) completed.`);
            }

            const finalAgentResponse = await interactiveStepApi(aggregatorUrl, {
              conversation_id: conversationId,
              agentIdentifierObj: stepData.agentIdentifierObj,
              role: stepData.role,
              role_description: stepData.roleDescription,
              maxTokens: stepData.maxTokens,
              temperature: stepData.temperature,
              workspaces: filteredWorkspaces,
              user_message: "[Auto-run step complete. Provide a final summary or concluding remarks for this step, including any files created or modified if not already explicitly stated.]",
              last_agent_message: stepResult.answer, finish_step: true
            });

            const finalAgentMsgContent = finalAgentResponse.answer || "[Agent provided no final summary for the step.]";
            currentConversationHistory.push({ role: "System", content: `[Auto-Run Step Finalized with Agent. Agent's final remarks: ${finalAgentMsgContent.substring(0,150)}...]` });
            setAutoRunLogs((prev) => [...prev.slice(-100), { role: "System", content: `[Auto-Run Step ${idx + 1} (${stepData.role}) finalized. Agent summary: ${finalAgentMsgContent.substring(0,150)}...]` }]);

            let fullTextForSummary = "";
            currentConversationHistory.forEach((c) => { fullTextForSummary += `${c.role}: ${c.content}\n\n`; });
            if (!fullTextForSummary.includes(finalAgentMsgContent)) {
                fullTextForSummary += `${stepData.role} (Final Remarks): ${finalAgentMsgContent}\n\n`;
            }

            const summary = await summarizeConversation(aggregatorUrl, fullTextForSummary, stepData.agentIdentifierObj, conversationId); // Pass agentIdentifierObj and conversationId

            const summaryLog = `Summary for Step ${idx + 1} (${stepData.role}): ${summary.substring(0,200)}${summary.length > 200 ? '...' : ''}`;
            setAutoRunLogs((prev) => [...prev.slice(-100), { role: "Context Summary", content: summaryLog }]);
            setAccumulatedContext((prev) => prev + `\n\n**From Step ${idx + 1} (${stepData.role}):**\n${summary}\n`);


          } catch (err) {
            console.error(`Error in autoRunStep ${idx + 1} (${stepData.role}):`, err);
            const errorMsg = `Auto-run step ${idx + 1} (${stepData.role}) FAILED: ${err.message}. Halting.`;
            setAutoRunLogs((prev) => [...prev.slice(-100), { role: "System", content: errorMsg }]);
            showSnackbar(errorMsg, "error");
            setAutoRunState("stopped");
            setInProgress(false);
            return;
          }
        }


        async function summarizeConversation(aggregatorUrl, conversationText, agentIdentifierObjForSummarization, convIdForLogging = null, globalContextAgentIdentifier = null, allActiveAgents = []) {
          let agentToUse = agentIdentifierObjForSummarization;
  
          if (!agentToUse) {
              // Use the globally selected context agent if provided and primary is not
              if (globalContextAgentIdentifier) {
                  agentToUse = globalContextAgentIdentifier;
              } else if (allActiveAgents.length > 0) { // Now uses the passed 'allActiveAgents' for ultimate fallback
                  // Fallback to the first available agent if no specific context agent is chosen
                  agentToUse = allActiveAgents[0];
                  // Optional: showSnackbar("No specific summarizer; using first available agent.", "info"); // Only show if necessary
              } else {
                  showSnackbar("No agent available for summarization (no primary, context, or fallback agents).", "warning");
                  return "Error: No agent available to summarize conversation.";
              }
          }
  
          const payload = {
            agentIdentifier: agentToUse,
            question: `Please provide a concise summary of the following interaction, focusing on key outcomes, decisions, and any files created or significantly modified. This summary will be passed to the next agent in a chain or used for overall project tracking:\n\n${conversationText}`,
            max_tokens: 500,
            conversation_id: convIdForLogging
          };
          try {
            // sendMessageToAgent already uses /message which calls call_agent_once_v1_5
            const data = await sendMessageToAgent(aggregatorUrl, payload);
            return data.answer || "[No summary provided by agent.]";
          } catch (error) {
            console.error("Summarization call failed:", error);
            showSnackbar(`Summarization failed: ${error.message}`, "error");
            return `[Error summarizing conversation: ${error.message}]`;
          }
        }

        function handlePlay() {
          if (!conversationId) {
            showSnackbar("Please select or create a Project ID first.", "warning");
            return;
          }
          if (!initialPrompt.trim() && steps.length > 0 && currentStepIndex === 0) {
            showSnackbar("Please provide an Initial Prompt before starting auto-run.", "warning");
            return;
          }
          if (steps.length === 0) {
            showSnackbar("Please add at least one step to the chain.", "warning");
            return;
          }
          if (steps.some(step => !step.agentIdentifierObj)) {
            showSnackbar("One or more steps do not have an agent assigned. Please assign agents to all steps.", "error");
            return;
          }
          if (currentStepIndex >= steps.length) {
            setCurrentStepIndex(0);
            setAccumulatedContext("");
            setAutoRunLogs([]);
          }
          setInProgress(true);
          setAutoRunState("running");
          const startMsg = `--- Auto-Run ${autoRunState === "paused" ? "Resumed" : "Started"} ---`;
          setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: startMsg}]);
          showSnackbar(startMsg, "info");
        }

        function handlePause() {
          if (autoRunState === "running") {
            setAutoRunState("paused");
            const pauseMsg = "--- Auto-Run Paused ---";
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: pauseMsg}]);
            showSnackbar(pauseMsg, "info");
          }
        }

        function handleStop() {
          setAutoRunState("stopped");
          setInProgress(false);
          const stopMsg = "--- Auto-Run Stopped by User ---";
          setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: stopMsg}]);
          showSnackbar(stopMsg, "info");
        }

        function handleReplay() {
          if (!conversationId) {
            showSnackbar("Please select or create a Project ID first.", "warning");
            return;
          }
           if (steps.length === 0) {
            showSnackbar("Cannot replay: No steps defined.", "warning");
            return;
          }
           if (steps.some(step => !step.agentIdentifierObj)) {
            showSnackbar("One or more steps do not have an agent assigned for replay. Please assign agents.", "error");
            return;
          }
          if (window.confirm("This will reset the current auto-run progress and start from the beginning. Are you sure?")) {
            setCurrentStepIndex(0);
            setAccumulatedContext("");
            setAutoRunLogs([{role: "System", content: "--- Auto-Run Replay Initialized ---"}]);
            setInProgress(true);
            setAutoRunState("running");
            showSnackbar("Auto-Run replay started.", "info");
          }
        }

        function startChain() {
          if (!conversationId) {
            showSnackbar("Please select or create a Project ID first.", "warning");
            return;
          }
          if (!initialPrompt.trim() && steps.length > 0) {
            showSnackbar("Please provide an Initial Prompt for manual mode.", "warning");
            return;
          }
           if (steps.length === 0) {
            showSnackbar("Please add at least one step to the chain.", "warning");
            return;
          }
          if (steps.some(step => !step.agentIdentifierObj)) {
            showSnackbar("One or more steps do not have an agent assigned for manual mode. Please assign agents.", "error");
            return;
          }
          setInProgress(true);
          setAutoRunState("stopped");
          setCurrentStepIndex(0);
          setAccumulatedContext("");
          const startMsg = "--- Manual Chain Started ---";
          setAutoRunLogs([{role:"System", content:startMsg}]);
          showSnackbar(startMsg, "info");
        }

        async function onFinishStep(messagesFromStepChat, agentIdentifierObjUsedInStep) { // agentIdentifierObj used
          let summarizationSuccessful = false; // Declare and initialize here
          try {
            let summary = "[Summary generation skipped due to error]"; // Default in case of error before call
            // The inner 'summarizationSuccessful' re-declaration was removed to avoid shadowing the outer one.
            // The outer 'summarizationSuccessful' (initialized to false) will now be correctly updated.
            let fullText = "";
            messagesFromStepChat.forEach((m) => {
              fullText += `${m.role}: ${m.content}\n\n`;
            });
            // Pass the specific agentIdentifierObj used in the step for summarization
            summary = await summarizeConversation(
                aggregatorUrl,
                fullText,
                agentIdentifierObjUsedInStep, // Primary agent from the step
                conversationId,
                contextAgentIdentifier,     // Pass ChainManager's prop (global context agent)
                activeAgents                // Pass ChainManager's state (list of all discovered agents)
            );

            // Check if the summary indicates an error
            if (summary.startsWith("[Error summarizing conversation:")) {
                setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: `Summarization failed for Manual Step ${currentStepIndex + 1} (${steps[currentStepIndex].role}): ${summary}`}]);
                showSnackbar(`Summarization failed for step ${currentStepIndex + 1}. Check logs.`, "error");
                // Do NOT append error string to accumulatedContext
            } else {
                setAutoRunLogs(prev => [...prev.slice(-100), {role: "Context Summary", content: `Summary for Manual Step ${currentStepIndex + 1} (${steps[currentStepIndex].role}): ${summary.substring(0,100)}...`}]);
                setAccumulatedContext((prev) => prev + `\n\n**From Manual Step ${currentStepIndex + 1} (${steps[currentStepIndex].role}):**\n${summary}\n`);
                summarizationSuccessful = true; // Mark as successful (sets the outer scoped variable)
            }
          } catch (err) { // This catch handles errors *during* the summarizeConversation call itself
            console.error("Error summarizing manual step (outer catch):", err);
            const errorMsg = `Error summarizing manual step (outer catch): ${err.message}`;
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: errorMsg}]);
            showSnackbar(errorMsg, "error");
            // 'summarizationSuccessful' (outer scope) remains false.
          }

          // Always proceed to the next step after attempting summarization.
          // Summarization success/failure is logged and shown via snackbar, but does not block chain progression.
          gotoNextStep();
        }

        function gotoNextStep() {
          if (currentStepIndex + 1 < steps.length) {
            setCurrentStepIndex((prev) => prev + 1);
            showSnackbar(`Moving to next manual step: ${steps[currentStepIndex + 1].role}`, "info");
          } else {
            const completionMsg = "All manual steps completed! Project is done.";
            showSnackbar(completionMsg, "success");
            setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: completionMsg}]);
            setInProgress(false);
            setWorkspaces((prev) =>
              prev.map((ws) => {
                if (ws.title.toLowerCase().includes("readme")) {
                  return {
                    ...ws,
                    content: ws.content + "\n\n---\n**Project Manual Run Summary (Completed " + new Date().toLocaleString() + ")**:\n" + accumulatedContext,
                    versionHistory: [...(ws.versionHistory||[]), {content: ws.content + "\n\n---\n**Project Manual Run Summary**:\n" + accumulatedContext, timestamp: Date.now()}]
                  };
                }
                return ws;
              })
            );
          }
        }

        function saveProjectToFile() {
          if (!conversationId) {
            showSnackbar("Please set a Project ID before saving to file.", "warning");
            return;
          }
          const data = {
            conversationId: conversationId || "untitled_project",
            initialPrompt,
            steps: steps.map(step => ({ ...step, agentIdentifierObj: step.agentIdentifierObj || null })), // Ensure object is saved
            workspaces,
            customOrgs
          };
          const json = JSON.stringify(data, null, 2);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `project_${conversationId || "untitled"}_${new Date().toISOString().slice(0,10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          const savedMsg = `Project "${conversationId}" saved to file.`;
          setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: `[${new Date().toLocaleTimeString()}] ${savedMsg}`}]);
          showSnackbar(savedMsg, "success");
        }

        function exportSettings() {
          const data = {
            customOrgs,
            stepTemplates
          };
          const json = JSON.stringify(data, null, 2);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `chain_settings_custom_orgs_${new Date().toISOString().slice(0,10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showSnackbar("Custom Orgs and Step Templates exported.", "success");
        }

        function handleLoadProjectFile(e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
            try {
              const data = JSON.parse(evt.target.result);
              if (!data || typeof data !== 'object') {
                  throw new Error("Invalid project file format.");
              }

              if (data.conversationId) {
                  setConversationId(data.conversationId); // This will trigger its own useEffect for server load if URL exists
              }

              // This data will effectively be used immediately if aggregatorUrl is not set or load fails
              setInitialPrompt(data.initialPrompt || "");
              const loadedSteps = (data.steps && data.steps.length > 0 ? data.steps : [{ agentIdentifierObj: null, role: "Developer", roleDescription: "Writes code", maxTokens: 10000, temperature: null }])
                .map(step => ({
                    ...step,
                    agentIdentifierObj: step.agentIdentifier || step.agentIdentifierObj || null,// Handle if it was saved as null
                    temperature: step.temperature === undefined ? null : step.temperature
                }));
              setSteps(loadedSteps);

              const loadedWorkspaces = (data.workspaces || []).map(ws => ({ ...ws, lang: ws.lang || "", id: ws.id || `ws_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`, parentId: ws.parentId === undefined ? null : ws.parentId, versionHistory: ws.versionHistory || (ws.content ? [{content: ws.content, timestamp: Date.now()}] : []) }));
              setWorkspaces(loadedWorkspaces.length > 0 ? loadedWorkspaces : [{ id: "readme_" + Date.now(), type: "text", title: "Project README.md", content: "", lang: "markdown", parentId: null, versionHistory: [] }]);
              setCustomOrgs(data.customOrgs || []);

              setInProgress(false);
              setCurrentStepIndex(0);
              setAutoRunLogs([ {role:"System", content:`Project "${data.conversationId || file.name}" loaded from file.`}]);
              setAccumulatedContext("");
              setTerminalLogs([`[${new Date().toLocaleTimeString()}] Project loaded from file: ${file.name}`]);
              showSnackbar(`Project "${data.conversationId || file.name}" loaded from file successfully!`, "success");

            } catch (err) {
              showSnackbar(`Error loading project from file: ${err.message}`, "error");
               setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: `[${new Date().toLocaleTimeString()}] FAILED to load project from file: ${err.message}`}]);
            }
          };
          reader.readAsText(file);
          e.target.value = null;
        }


        function buildAndLoadPreview() {
          const docHtml = buildPreviewDocument(workspaces);
          if (previewIframeRef.current) {
            const doc =
              previewIframeRef.current.contentDocument ||
              previewIframeRef.current.contentWindow.document;
            doc.open();
            doc.write(docHtml);
            doc.close();
            showSnackbar("In-memory preview updated.", "info", { autoHideDuration: 2000 });
          } else {
            showSnackbar("Preview iframe not available.", "warning");
          }
        }

        React.useEffect(() => {
          if (autoRefreshPreview && !inProgress) {
            buildAndLoadPreview();
          }
        }, [workspaces, autoRefreshPreview, inProgress]);

                // Memoize the function that opens the modal
                const openModalForSpecificContext = React.useCallback((fileOrFolderItem) => {
                  // Check if the modal is already open and the context item is the same
                  // Compare by item ID, assuming IDs are stable and unique identifiers for workspace items
                  const currentContextItem = wsModalContext?.selectedFiles?.[0];
      
                  // Only update state if the modal is closed OR the item being opened is different from the current one
                  if (!wsModalOpen || currentContextItem?.id !== fileOrFolderItem.id) {
                       // Create the new context object.
                       // We still need a new object and array reference here because we are setting state.
                       // The key is that we only do this if the item is different or the modal is closed.
                      const newContext = {
                          type: 'files',
                          selectedFiles: [fileOrFolderItem], // New array reference
                          // Include other context properties if needed, making sure they are also stable or derived
                          // e.g., mode: 'task' // Or derive mode based on file type/context
                      };
                      setWsModalContext(newContext); // This will be a new object reference if the condition above is true
                      setWsModalOpen(true);
                  }
              }, [wsModalOpen, wsModalContext]); // Dependencies: Need current state to check if update is necessary

        async function onFilesDropped(fileArray) {
          const TEXT_LIKE_EXTENSIONS = new Set([
            "txt", "md", "py", "js", "jsx", "ts", "tsx", "html", "css", "json",
            "sh", "java", "c", "cpp", "cs", "go", "rb", "php", "xml", "yaml", "yml"
          ]);

          const FILE_TYPE_MAP = {
            js: "code", jsx: "code", ts: "code", tsx: "code", py: "code",
            sh: "code", java: "code", c: "code", cpp: "code", cs: "code",
            go: "code", rb: "code", php: "code",
            html: "html", htm: "html",
            css: "css",
          };

          const generateWorkspaceId = (filename) =>
            `ws_dropped_${Date.now()}_${Math.random().toString(36).substr(2, 5)}_${filename.replace(/[^a-zA-Z0-9_.-]/g, '_')}`;

          for (const file of fileArray) {
            const ext = file.name.split(".").pop().toLowerCase();
            const isTextLike = TEXT_LIKE_EXTENSIONS.has(ext);

            const processFileContent = (fileContent) => {
              const workspaceType = FILE_TYPE_MAP[ext] || (isTextLike ? "text" : "text"); // Default to "text"
              const newId = generateWorkspaceId(file.name);
              const newWorkspaceItem = {
                id: newId,
                type: workspaceType,
                title: file.name,
                content: isTextLike && fileContent !== null
                  ? fileContent
                  : `[Binary file: ${file.name} (${(file.size / 1024).toFixed(2)} KB) - Content not displayed]`,
                lang: ext,
                parentId: null, // Dropped files go to root
                versionHistory: [{
                  content: isTextLike && fileContent !== null ? fileContent : `[Binary file: ${file.name}]`,
                  timestamp: Date.now()
                }]
              };
              setWorkspaces((prev) => [...prev, newWorkspaceItem]);
            };

            if (isTextLike) {
              const reader = new FileReader();
              reader.onload = (evt) => {
                processFileContent(evt.target.result);
              };
              reader.onerror = (errEvent) => {
                console.error(`Error reading file ${file.name}:`, errEvent);
                showSnackbar(`Error reading file "${file.name}". It might be corrupted or unreadable. Adding as placeholder.`, "error");
                processFileContent(null); // Process as if it's binary or unreadable
              };
              reader.readAsText(file);
            } else {
              // For non-text-like files or unreadable text files, directly process with null content
              processFileContent(null);
            }
          }
        }

        if (!conversationId && aggregatorUrl) {
             return (
                <Paper sx={{p:3, textAlign:'center', mt:2}} elevation={2} className="interactive-card non-interactive">
                    <Typography variant="h6" className={isDarkModeActive ? 'heading-glow' : ''}>No Project Selected</Typography>
                    <Typography sx={{color: 'text.secondary'}}>Please select an existing project or create a new one above to begin.</Typography>
                </Paper>
            );
        }
         if (!aggregatorUrl) {
             return (
                <Paper sx={{p:3, textAlign:'center', mt:2}} elevation={2} className="interactive-card non-interactive">
                    <Typography variant="h6" color="error" className={isDarkModeActive ? 'heading-glow' : ''}>Aggregator URL Not Set</Typography>
                    <Typography sx={{color: 'text.secondary'}}>Please enter the Aggregator URL at the top of the page to connect.</Typography>
                </Paper>
             );
         }



        return (
          <React.Fragment>
            <Paper sx={{ p: {xs: 1, sm: 2}, mb: 2.5 }} elevation={2} className="interactive-card non-interactive">
              <Typography variant="h5" gutterBottom className={isDarkModeActive ? 'heading-glow text-gradient-brand' : ''} sx={{ textAlign: 'center', mb:2 }}>
              Chain Configuration &amp; Control
            </Typography>

            <Box mb={2}>
              <FormControlLabel
                control={
                  <Switch
                    checked={useAgentDiscovery}
                    onChange={(e) => {
                        setUseAgentDiscovery(e.target.checked);
                        if(e.target.checked) {
                            loadAgents(); // Reload agents when discovery is turned on
                        } else {
                            setActiveAgents([]); // Clear agents if discovery is off
                        }
                    }}
                    color="primary"
                  />
                }
                label="Discover Agents from Aggregator"
              />
               {!useAgentDiscovery && <Typography variant="caption" display="block" sx={{color: 'text.secondary'}}>Agent assignment is manual if discovery is off.</Typography>}
               {useAgentDiscovery && activeAgents.length === 0 && <Typography variant="caption" display="block" sx={{color: 'warning.main'}}>No agents discovered. Check Aggregator and Model Server status, or ensure agents are registered.</Typography>}
               {useAgentDiscovery && activeAgents.length > 0 &&
                <Typography variant="caption" display="block" sx={{color: 'success.main'}}>
                    Discovered agents: {activeAgents.map(ag => ag.name || `Port ${ag.port}`).join(', ')}
                </Typography>}
            </Box>

            {autoRunState === "stopped" && !inProgress && (
              <Paper variant="outlined" sx={{ p: 2, mb: 2, borderColor: 'var(--card-border)'}} className="interactive-card non-interactive">
                <Typography variant="h6" gutterBottom className={isDarkModeActive ? 'heading-glow' : ''} sx={{mb:1.5}}>Organization &amp; Step Templates</Typography>
                <Box display="flex" gap={2} alignItems="center" mb={1.5} flexWrap="wrap">
                   <FormControl size="small" sx={{ minWidth: 240, flexGrow:1 }}>
                    <InputLabel id="load-org-template-label">Load Org Template</InputLabel>
                    <Select
                      labelId="load-org-template-label"
                      label="Load Org Template"
                      value={orgTemplateSelected}
                      onChange={(e) => handleOrgSelect(e.target.value)}
                    >
                      <MenuItem value=""><em>(Select Template or Custom Org)</em></MenuItem>
                      <ListSubheader sx={{fontWeight:'bold', color: 'text.disabled', bgcolor: 'transparent'}}>Standard Templates</ListSubheader>
                      {orgTemplates.map((org) => (
                        <MenuItem key={org.label} value={org.label}>
                          {org.label}
                        </MenuItem>
                      ))}
                      {customOrgs.length > 0 && <ListSubheader sx={{fontWeight:'bold', color: 'text.disabled', bgcolor: 'transparent', mt:1}}>Custom Orgs</ListSubheader>}
                      {customOrgs.map((org) => (
                        <MenuItem key={org.label} value={org.label}>
                          {org.label}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                  <Tooltip title="Save current steps configuration as a new custom organization template.">
                    <Button variant="outlined" onClick={saveOrg} size="small">
                        Save Current as Org
                    </Button>
                  </Tooltip>
                </Box>
                <Box display="flex" gap={2} alignItems="center" flexWrap="wrap">
                  <Typography variant="body2" sx={{color:'text.secondary'}}>
                    Import Custom Orgs:
                  </Typography>
                  <input
                    type="file"
                    accept="application/json"
                    id="importOrgsFileChainManager" // Unique ID for this input
                    style={{ display: "none" }}
                    onChange={handleImportOrgs}
                  />
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={() => document.getElementById("importOrgsFileChainManager").click()}
                  >
                    Import Orgs File
                  </Button>
                   <Tooltip title="Export your custom org templates and step templates to a JSON file.">
                    <Button variant="outlined" color="info" onClick={exportSettings} size="small">
                        Export Custom Settings
                    </Button>
                  </Tooltip>
                </Box>
              </Paper>
            )}

            {autoRunState === "stopped" && !inProgress && (
              <Box mb={2.5}>
                <TextField
                  label="Initial Prompt / Goal for the Chain"
                  multiline
                  minRows={3} maxRows={8}
                  variant="outlined"
                  fullWidth
                  value={initialPrompt}
                  onChange={(e) => setInitialPrompt(e.target.value)}
                  placeholder="e.g., Develop a Python Flask backend for a to-do list application with CRUD operations and user authentication. The app should have a simple HTML frontend to interact with the API."
                />
              </Box>
            )}

            <Typography variant="h6" gutterBottom className={isDarkModeActive ? 'heading-glow' : ''} sx={{my:1.5}}>Chain Steps Definition</Typography>
            {steps.map((step, idx) => (
              <Paper
                key={step.id || idx} // Prefer stable ID if available, fallback to index
                variant="outlined"
                sx={{
                    p:1.5, mb:1,
                    borderColor: idx === currentStepIndex && inProgress ? (isDarkModeActive? 'var(--logo-c-ai)' : 'primary.main') : 'var(--card-border)',
                    bgcolor: idx === currentStepIndex && inProgress ? (isDarkModeActive? `rgba(${getComputedStyle(document.documentElement).getPropertyValue('--logo-c-ai-rgb').trim()}, 0.1)` : (theme) => theme.palette.primary.light) : 'transparent',
                    borderLeft: idx === currentStepIndex && inProgress ? `5px solid ${isDarkModeActive ? 'var(--logo-c-ai)' : 'primary.main'}` : `5px solid transparent`,
                    transition: 'border-color 0.3s ease, background-color 0.3s ease, border-left-color 0.3s ease'
                }}
                className="interactive-card non-interactive"
            >
              <Box display="flex" alignItems="center" gap={1} flexWrap="wrap">
                <Typography sx={{ mr: 0.5, fontWeight:'medium', minWidth: '20px' }}>{idx + 1}.</Typography>
                <Box className="step-reorder-buttons" sx={{mr:1}}>
                  <Tooltip title="Move step up"><span><IconButton size="small" onClick={() => moveStep(idx, 'up')} disabled={idx === 0 || inProgress}><Typography>🔼</Typography></IconButton></span></Tooltip>
                  <Tooltip title="Move step down"><span><IconButton size="small" onClick={() => moveStep(idx, 'down')} disabled={idx === steps.length - 1 || inProgress}><Typography>🔽</Typography></IconButton></span></Tooltip>
                </Box>

                 <FormControl size="small" sx={{ minWidth: 180, mr: 1, flexBasis: {xs: '100%', sm: 180}, flexShrink:0 }}>
                    <InputLabel id={`agent-select-label-${idx}`}>Assign Agent</InputLabel>
                    <Select
                        labelId={`agent-select-label-${idx}`}
                        label="Assign Agent"
                        value={step.agentIdentifierObj ? getAgentIdentifierValueString(step.agentIdentifierObj) : ""}
                        onChange={(e) => {
                            const selectedValueString = e.target.value;
                            const selectedAgent = activeAgents.find(ag => getAgentIdentifierValueString(ag) === selectedValueString) || null;
                            handleStepChange(idx, "agentIdentifierObj", selectedAgent);
                        }}
                        disabled={inProgress || (!useAgentDiscovery && activeAgents.length === 0)}
                    >
                        <MenuItem value=""><em>(None / Unassigned)</em></MenuItem>
                        {activeAgents.map((agent) => {
                            const agentValue = getAgentIdentifierValueString(agent);
                            const displayName = agent.name || `Port ${agent.port}`;
                            const typeDisplay = agent.type ? `(${agent.type.replace("_main_server","").replace("specialist","Spec.").replace("orchestrator","Orch.").replace("network_scanned","Net")})` : '';
                            return (
                                <MenuItem key={agentValue} value={agentValue}>
                                    {displayName} <Typography variant="caption" sx={{ml:0.5, color:'text.secondary'}}>{typeDisplay}</Typography>
                                     {agent.role_description && <Tooltip title={agent.role_description}><IconButton size="small" sx={{ml:'auto', p:0.2}}><Typography sx={{fontSize:'0.7em'}}>ℹ️</Typography></IconButton></Tooltip>}
                                </MenuItem>
                            );
                        })}
                    </Select>
                </FormControl>

                <TextField label="Role Name" size="small" value={step.role} onChange={(e) => handleStepChange(idx, "role", e.target.value)} sx={{ width: {xs: 'calc(50% - 8px)', sm:180}, mr: 1, flexBasis:{xs: 'calc(50% - 8px)', sm:180}, flexShrink:0 }} variant="outlined" disabled={inProgress}/>
                <TextField label="Role Description / Instructions" size="small" value={step.roleDescription} onChange={(e) => handleStepChange(idx, "roleDescription", e.target.value)} sx={{ flexGrow:1, minWidth: {xs: '100%', sm:250}, mr: 1 }} variant="outlined" disabled={inProgress} multiline maxRows={3}/>
                <TextField label="Max Tokens" type="number" size="small" value={String(step.maxTokens)} onChange={(e) => handleStepChange(idx, "maxTokens", e.target.value)} sx={{ width: {xs:'calc(50% - 24px)', sm:100}, mr: 1, flexBasis:{xs:'calc(50% - 24px)', sm:100}, flexShrink:0 }} variant="outlined" disabled={inProgress} InputProps={{ inputProps: { min: 100, step: 100 } }}/>
                <TextField label="Temp (optional)" type="number" size="small" value={step.temperature === null || step.temperature === undefined ? '' : String(step.temperature)} onChange={(e) => handleStepChange(idx, "temperature", e.target.value)} sx={{ width: {xs:'calc(50% - 24px)', sm:100}, mr:1, flexBasis:{xs:'calc(50% - 24px)', sm:100}, flexShrink:0}} variant="outlined" disabled={inProgress} InputProps={{inputProps: {min:0, max:2, step:0.1}}} placeholder="Default"/>
                <Tooltip title="Remove this step">
                  <span>
                    <Button variant="outlined" color="secondary" size="small" onClick={() => removeStep(idx)} disabled={steps.length <=1 || inProgress}>Remove</Button>
                  </span>
                </Tooltip>
              </Box>
              </Paper>
            ))}

            {autoRunState === "stopped" && !inProgress && (
              <Box mt={2} mb={2} display="flex" gap={1.5} alignItems="center" flexWrap="wrap">
                <Button variant="contained" onClick={addStep} size="small">
                  + Add Empty Step
                </Button>
                <FormControl size="small" sx={{ minWidth: 200, flexGrow: {xs:1, sm:0} }}>
                  <InputLabel id="add-step-template-label">Add Step from Template</InputLabel>
                  <Select labelId="add-step-template-label" label="Add Step from Template" value={selectedTemplate} onChange={(e) => setSelectedTemplate(e.target.value)}>
                    <MenuItem value=""><em>(Select Template)</em></MenuItem>
                    {stepTemplates.map((tmpl) => (<MenuItem key={tmpl.label} value={tmpl.label}>{tmpl.label}</MenuItem>))}
                  </Select>
                </FormControl>
                <Button variant="outlined" onClick={addTemplateStep} size="small" disabled={!selectedTemplate}>
                  Add Template Step
                </Button>
              </Box>
            )}

             <Paper variant="outlined" sx={{ p: 2, mt: 2.5, mb: 2.5, borderColor: 'var(--card-border)' }} className="interactive-card non-interactive">
                <Typography variant="h6" gutterBottom className={isDarkModeActive ? 'heading-glow' : ''}>Execution Controls</Typography>
                <Box display="flex" gap={1.5} alignItems="center" flexWrap="wrap">
                    {!inProgress && (
                        <Tooltip title="Start interacting with the chain step-by-step manually.">
                            <span>
                                <Button variant="contained" color="primary" onClick={startChain} disabled={inProgress || steps.length === 0 || steps.some(s => !s.agentIdentifierObj)}>
                                    Start Chain (Manual Mode)
                                </Button>
                            </span>
                        </Tooltip>
                    )}
                     <Tooltip title="Automatically run through all defined steps.">
                        <span>
                            <Button variant="contained" color="success" onClick={handlePlay} disabled={(inProgress && autoRunState === "running") || steps.length === 0 || steps.some(s => !s.agentIdentifierObj)}>
                               {autoRunState === "paused" ? "Resume Auto-Run" : (autoRunState === "running" ? "Auto-Run Active" : "Start Auto-Run")}
                            </Button>
                        </span>
                     </Tooltip>
                    {inProgress && autoRunState === "running" && (
                        <Tooltip title="Pause the current auto-run process.">
                            <Button variant="contained" color="warning" onClick={handlePause}>
                                Pause Auto-Run
                            </Button>
                        </Tooltip>
                    )}
                    {inProgress && (
                        <Tooltip title="Stop the current chain (manual or auto-run).">
                            <Button variant="contained" color="error" onClick={handleStop}>
                                Stop Chain
                            </Button>
                        </Tooltip>
                    )}
                     <Tooltip title="Reset and replay the auto-run from the first step.">
                        <span>
                            <Button variant="outlined" color="secondary" onClick={handleReplay} disabled={(inProgress && autoRunState === "running") || steps.length === 0 || steps.some(s => !s.agentIdentifierObj)}>
                                Replay Auto-Run
                            </Button>
                        </span>
                     </Tooltip>
                </Box>
                {inProgress && <Typography variant="body2" sx={{mt:1, color: isDarkModeActive ? 'var(--text-secondary)' : 'text.secondary'}}>Mode: <strong style={{color: isDarkModeActive ? 'var(--text-heading-glow)': 'primary.main'}}>{autoRunState !== "stopped" ? `Auto-Run (${autoRunState})` : "Manual Mode"}</strong> (Current Step: {currentStepIndex + 1}/{steps.length})</Typography>}
             </Paper>


            {inProgress && autoRunState === "stopped" && currentStepIndex < steps.length && (
              <MemoizedStepChat
                key={`${conversationId}-${currentStepIndex}-${steps[currentStepIndex].agentIdentifierObj?.name || steps[currentStepIndex].agentIdentifierObj?.port || 'no-agent'}-${steps[currentStepIndex].role}`} // More robust key
                aggregatorUrl={aggregatorUrl}
                conversationId={conversationId}
                stepIndex={currentStepIndex}
                agentIdentifierObj={steps[currentStepIndex].agentIdentifierObj}
                role={steps[currentStepIndex].role}
                roleDescription={steps[currentStepIndex].roleDescription}
                maxTokens={steps[currentStepIndex].maxTokens}
                temperature={steps[currentStepIndex].temperature}
                workspaces={workspaces}
                initialUserMsg={ currentStepIndex === 0 ? initialPrompt.trim() : accumulatedContext.trim() }
                onFinishStep={onFinishStep}
                contextAgentIdentifier={contextAgentIdentifier}
                setWorkspaces={setWorkspaces}
                onAgentRunCommand={handleRunCommand}
                onAddDeveloperFixStep={handleAddDeveloperFixStep}
                showSnackbar={showSnackbar}
                isDarkMode={isDarkModeActive}
              />
            )}

            {(autoRunLogs.length > 0 || (inProgress && autoRunState !== "stopped")) && <AutoRunLogs logs={autoRunLogs} /> }

            <TerminalPanel
              aggregatorUrl={aggregatorUrl}
              conversationId={conversationId}
              terminalLogs={terminalLogs}
              onRunCommand={handleRunCommand}
              showSnackbar={showSnackbar}
            />

            <PullRequestPanel
              aggregatorUrl={aggregatorUrl}
              conversationId={conversationId}
              onMerged={() => {
                setAutoRunLogs(prev => [...prev.slice(-100), {role:"System", content: "A Pull Request was merged."}]);
                showSnackbar("A Pull Request was successfully merged!", "success");
                if (conversationId) {
                  setTimeout(() => {
                     handleLoadProjectFromAggregator(conversationId);
                  }, 500);
                }
              }}
              showSnackbar={showSnackbar}
            />

            <PipelinePanel
              aggregatorUrl={aggregatorUrl}
              conversationId={conversationId}
              showSnackbar={showSnackbar}
              onPipelineComplete={() => {
                  if(conversationId) {
                    setTimeout(() => {
                        handleLoadProjectFromAggregator(conversationId);
                    }, 500);
                  }
              }}
            />

            <StructuredDataPanel
              aggregatorUrl={aggregatorUrl}
              conversationId={conversationId}
              showSnackbar={showSnackbar}
            />

            <FileExplorer
                workspaces={workspaces}
                setWorkspaces={setWorkspaces}
                showSnackbar={showSnackbar}
                handleLoadProjectFromAggregator={handleLoadProjectFromAggregator}
                onTriggerTaskModal={openModalForSpecificContext} // This is ChainManager's internal modal trigger
                conversationId={conversationId}
            />
            <WorkspaceDropZone onFilesDropped={onFilesDropped} showSnackbar={showSnackbar} />

            <Box mt={4} className="interactive-card non-interactive">
              <Typography variant="h5" gutterBottom className={isDarkModeActive ? 'heading-glow' : ''} sx={{p:2, pb:0}}>Workspaces &amp; Preview</Typography>
              {workspaces
                .filter((w) => w.type !== "folder")
                .sort((a,b) => a.title.localeCompare(b.title))
                .map((ws) => {
                  const handleItemChange = (newContent) => {
                      if (newContent !== ws.content) {
                        setWorkspaces((prevWs) =>
                          prevWs.map((item) =>
                            item.id === ws.id
                              ? {
                                  ...item,
                                  content: newContent,
                                  versionHistory: [
                                    ...(item.versionHistory || []),
                                    { content: newContent, timestamp: Date.now() }
                                  ].slice(-20)
                                }
                              : item
                          )
                        );
                      }
                  };

                  if (["html","css","code"].includes(ws.type) || (ws.type === "text" && (ws.lang || ws.title.includes(".")))) {
                    return (
                      <CodeWorkspace
                        key={ws.id}
                        ws={ws}
                        onChange={handleItemChange}
                        darkMode={isDarkModeActive}
                        showSnackbar={showSnackbar}
                        onTriggerTaskModal={openModalForSpecificContext}
                      />
                    );
                  } else {
                    return (
                      <TextWorkspace
                        key={ws.id}
                        ws={ws}
                        onChange={handleItemChange}
                        showSnackbar={showSnackbar}
                      />
                    );
                  }
                })}

              <Box className="preview-section" component={Paper} sx={{p:2, mt:2}} elevation={2}>
                <Typography variant="h6" gutterBottom className={isDarkModeActive ? 'heading-glow' : ''}>Live Preview</Typography>
                <Box display="flex" alignItems="center" gap={1.5} mb={1.5} flexWrap="wrap">
                  <FormControlLabel
                    control={
                      <Switch
                        checked={autoRefreshPreview}
                        onChange={(e) => setAutoRefreshPreview(e.target.checked)}
                        color="primary"
                      />
                    }
                    label="Auto-Refresh In-Memory Preview"
                  />
                  <Tooltip title="Manually update the in-memory HTML/CSS/JS preview below.">
                    <Button variant="outlined" onClick={buildAndLoadPreview} size="small">
                        Force In-Memory Preview
                    </Button>
                  </Tooltip>
                  <Tooltip title="Load index.html from the project's workspace folder on the aggregator server.">
                    <span>
                        <Button
                            variant="outlined"
                            onClick={() => {
                            if (!conversationId) {
                                showSnackbar("No project selected! Cannot load live folder preview.", "warning");
                                return;
                            }
                            if (!aggregatorUrl) {
                                showSnackbar("Aggregator URL not set. Cannot load live folder preview.", "error");
                                return;
                            }
                            if (previewIframeRef.current) {
                                const previewUrl = `${aggregatorUrl}/workspaces/${conversationId}/index.html?t=${Date.now()}`;
                                previewIframeRef.current.src = previewUrl;
                                setAutoRunLogs(prev => [...prev.slice(-100), {role: "System", content: `[${new Date().toLocaleTimeString()}] Attempting to load live folder preview: ${previewUrl}`}]);
                                showSnackbar("Attempting to load live aggregator folder preview.", "info");
                            }
                            }}
                            size="small"
                            disabled={!aggregatorUrl || !conversationId}
                        >
                            Live Aggregator Folder Preview
                        </Button>
                    </span>
                  </Tooltip>
                </Box>
                <iframe
                    ref={previewIframeRef}
                    className="preview-iframe"
                    title="Live Preview Area"
                    sandbox="allow-scripts allow-same-origin allow-forms"
                    loading="lazy"
                ></iframe>
              </Box>
            </Box>

            <Paper sx={{p:2, mt:3, display:'flex', gap:1.5, flexWrap:'wrap', justifyContent:'center' }} elevation={2} className="interactive-card non-interactive">
              <Tooltip title="Save the current project configuration to a local JSON file.">
                <span>
                    <Button variant="outlined" color="success" onClick={saveProjectToFile} disabled={!conversationId}>
                        Save Project (to File)
                    </Button>
                </span>
              </Tooltip>

              <input
                type="file"
                accept="application/json"
                id="loadProjectFileChainManager" // Unique ID
                style={{ display: "none" }}
                onChange={handleLoadProjectFile}
              />
               <Tooltip title="Load a project from a previously saved JSON file.">
                <Button
                    variant="outlined"
                    onClick={() => document.getElementById("loadProjectFileChainManager").click()}
                >
                    Load Project (from File)
                </Button>
              </Tooltip>
            </Paper>
          </Paper>

          {/* ChainManager's internal WorkspaceTaskModal instance */}
          <WorkspaceTaskModal
            open={wsModalOpen} // Uses ChainManager's wsModalOpen state
            onClose={() => setWsModalOpen(false)}
            initialContext={wsModalContext} // Uses ChainManager's wsModalContext state
            aggregatorUrl={aggregatorUrl}
            conversationId={conversationId}
            activeAgents={activeAgents} // ChainManager's activeAgents
            showSnackbar={showSnackbar}
            onApplyChanges={(changes) => {
              setWorkspaces(currentChainWorkspaces => {
                let updatedChainWorkspaces = [...currentChainWorkspaces];
                const workspaceMap = new Map(updatedChainWorkspaces.map(ws => [ws.id, ws]));

                changes.forEach(change => {
                  if (workspaceMap.has(change.id)) {
                    const existingWs = workspaceMap.get(change.id);
                    Object.assign(existingWs, { // Update existing
                        content: change.newContent,
                        versionHistory: [...(existingWs.versionHistory || []), { content: change.newContent, timestamp: Date.now() }].slice(-20),
                        ...(change.title && { title: change.title }),
                        ...(change.lang && { lang: change.lang }),
                        ...(change.type && { type: change.type }),
                    });
                  } else if (change.isNew) {
                     // Add new file logic - ensure unique ID if ChainManager needs to generate it
                    const newFileId = change.id || generateUniqueId("modal_new_");
                    updatedChainWorkspaces.push({
                      id: newFileId,
                      title: change.title,
                      content: change.newContent,
                      lang: change.lang,
                      type: change.type,
                      parentId: null, // Or determine based on context
                      versionHistory: [{ content: change.newContent, timestamp: Date.now() }]
                    });
                  }
                });
                // If map was used for efficient updates, we might need to convert map values back to array
                // If updatedChainWorkspaces was directly mutated, this is fine.
                // For safety, if direct mutations on objects in array might not trigger rerender correctly:
                // return Array.from(workspaceMap.values());
                return updatedChainWorkspaces;
              });
              showSnackbar(`Applied ${changes.length} change(s) from Workspace Task Modal.`, 'success');
              setWsModalOpen(false);
            }}
          />
        </React.Fragment>
      );
    } // End of ChainManager component

      /***************************************************************
       * App Component
       ***************************************************************/
      function App() {
        const [aggregatorUrl, setAggregatorUrl] = React.useState(() => localStorage.getItem('aggregatorUrl') || "http://localhost:8000");
        const [conversationId, setConversationId] = React.useState("");
        const [contextAgentIdentifier, setContextAgentIdentifier] = React.useState(null); // Store full agent object
        const [activeAgentsForContextSelector, setActiveAgentsForContextSelector] = React.useState([]); // Dedicated list for context selector
        const userOS = detectOS();
        const [darkMode, setDarkMode] = React.useState(() => {
            const savedMode = localStorage.getItem('darkMode');
            return savedMode ? JSON.parse(savedMode) : true; // Default to true (dark mode)
        });

        // Snackbar state
        const [snackbarOpen, setSnackbarOpen] = React.useState(false);
        const [snackbarMessage, setSnackbarMessage] = React.useState("");
        const [snackbarSeverity, setSnackbarSeverity] = React.useState("info"); // "error", "warning", "info", "success"
        const [snackbarOptions, setSnackbarOptions] = React.useState({}); // For autoHideDuration etc.

        // State for App's global WorkspaceTaskModal instance
        // These are distinct from ChainManager's internal wsModalOpen and wsModalContext
        const [isAppGlobalModalOpen, setIsAppGlobalModalOpen] = React.useState(false);
        const [appGlobalModalInitialContext, setAppGlobalModalInitialContext] = React.useState(null);
        const [appGlobalModalOnApplyChangesCallback, setAppGlobalModalOnApplyChangesCallback] = React.useState(null);

        /**
         * Triggers App's global WorkspaceTaskModal.
         */
        const openAppGlobalWorkspaceModal = (context, onApplyChangesCallback) => {
            setAppGlobalModalInitialContext(context);
            // Store the callback function itself, not its result
            setAppGlobalModalOnApplyChangesCallback(() => onApplyChangesCallback);
            setIsAppGlobalModalOpen(true);
        };

        const closeAppGlobalWorkspaceModal = () => {
            setIsAppGlobalModalOpen(false);
            setAppGlobalModalInitialContext(null);
            setAppGlobalModalOnApplyChangesCallback(null);
        };


        React.useEffect(() => {
            localStorage.setItem('darkMode', JSON.stringify(darkMode));
            if (darkMode) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }, [darkMode]);

        React.useEffect(() => {
            localStorage.setItem('aggregatorUrl', aggregatorUrl);
        }, [aggregatorUrl]);

        const handleToggleDarkMode = () => {
            setDarkMode(prevMode => !prevMode);
        };

        // showSnackbar and handleSnackbarClose are now part of App's scope
        const showSnackbar = React.useCallback((message, severity = "info", options = {}) => {
            setSnackbarMessage(message);
            setSnackbarSeverity(severity);
            setSnackbarOptions(options);
            setSnackbarOpen(true);
        }, []); // Empty dependency array as it doesn't depend on App's state/props directly

        const handleSnackbarClose = React.useCallback((event, reason) => {
            if (reason === 'clickaway') {
                return;
            }
            setSnackbarOpen(false);
        }, []);


        React.useEffect(() => {
          async function loadAgentsForContextSelector() {
            if (!aggregatorUrl) {
                setActiveAgentsForContextSelector([]);
                setContextAgentIdentifier(null); // Clear selection if URL removed
                return;
            }
            try {
              const data = await fetchAgents(aggregatorUrl);
              const agents = data.active_agents || [];
              setActiveAgentsForContextSelector(agents);
              // Check if the currently selected context agent is still in the fetched list
              if (contextAgentIdentifier && !agents.some(ag => getAgentIdentifierValueString(ag) === getAgentIdentifierValueString(contextAgentIdentifier))) {
                  setContextAgentIdentifier(null); // Clear it if not found
                  showSnackbar("Previously selected context agent is no longer available.", "warning");
              }
            } catch (err) {
              console.error("Error fetching agents for context selector:", err);
              setActiveAgentsForContextSelector([]);
              setContextAgentIdentifier(null);
              // Do not show snackbar here if ChainManager's loadAgents might also show one.
              // Or, ensure only one component is responsible for this specific "discovery failed" message.
            }
          }
          // Debounce fetching to avoid rapid calls while typing URL
          const timerId = setTimeout(loadAgentsForContextSelector, 500);
          return () => clearTimeout(timerId);
        }, [aggregatorUrl, contextAgentIdentifier, showSnackbar]); // Added contextAgentIdentifier and showSnackbar to dep array for correctness

        const currentTheme = darkMode ? darkTheme : lightTheme;
        const isDarkModeActive = darkMode; // For clarity if darkMode prop is passed further down

        return (
          <ThemeProvider theme={currentTheme}>
            <React.Fragment>
              <Box sx={{bgcolor: 'background.default', color: 'text.primary', minHeight: '100vh', pb:4 }}>
                <Typography variant="h4" gutterBottom className={isDarkModeActive ? 'heading-glow text-gradient-brand' : ''} sx={{pt:1, textAlign:'center'}}>
                  Multi-Agent Interactive Chain
                </Typography>
                <Typography variant="subtitle1" gutterBottom sx={{textAlign:'center', mb:2, color: isDarkModeActive ? 'var(--text-secondary)' : 'text.secondary'}}>
                  Auto-Run, Terminal, Folders, Drag/Drop, Diff/Version, Autosave, Import Orgs, Live Preview
                </Typography>

                <Box sx={{px: {xs: 1, sm: 2} }}> {/* Responsive padding */}
                  <Paper sx={{p:1.5, mb:2, display:'flex', alignItems:'center', gap:1.5, flexWrap:'wrap'}} elevation={2} className="interactive-card non-interactive">
                      <TextField
                          label="Aggregator URL"
                          size="small"
                          value={aggregatorUrl}
                          onChange={(e) => setAggregatorUrl(e.target.value)}
                          sx={{ minWidth: {xs: 'calc(100% - 200px)', sm: 300}, flexGrow:1 }} // Adjusted width
                          variant="outlined"
                          helperText={userOS !== "other" ? `Detected OS: ${userOS}` : "Enter backend server address"}
                      />
                      <Button
                        variant="outlined"
                        size="small"
                        onClick={() => {
                          if (!aggregatorUrl) {
                            showSnackbar("Aggregator URL is not set.", "warning");
                            return;
                          }
                          // Explicitly trigger reload for context selector's agent list
                          fetchAgents(aggregatorUrl)
                            .then(data => {
                              const agents = data.active_agents || [];
                              setActiveAgentsForContextSelector(agents);
                               if (contextAgentIdentifier && !agents.some(ag => getAgentIdentifierValueString(ag) === getAgentIdentifierValueString(contextAgentIdentifier))) {
                                  setContextAgentIdentifier(null);
                                  showSnackbar("Previously selected context agent is no longer available after refresh.", "warning");
                              }
                              showSnackbar(`Context agent list refreshed (${agents.length} found).`, "success");
                            })
                            .catch(err => {
                              showSnackbar(`Failed to refresh context agents: ${err.message}`, "error");
                            });
                        }}
                        disabled={!aggregatorUrl}
                      >
                        Refresh Context Agents
                      </Button>

                  </Paper>
                  <ContextAgentSelector
                    activeAgents={activeAgentsForContextSelector}
                    contextAgentIdentifier={contextAgentIdentifier}
                    onChangeContextAgent={setContextAgentIdentifier}
                    showSnackbar={showSnackbar} // Pass down the App's showSnackbar
                  />

                  <ConversationSelector
                    aggregatorUrl={aggregatorUrl}
                    currentId={conversationId}
                    onChange={setConversationId}
                    showSnackbar={showSnackbar} // Pass down
                  />
                  <ChainManager
                    aggregatorUrl={aggregatorUrl}
                    conversationId={conversationId}
                    contextAgentIdentifier={contextAgentIdentifier}
                    darkMode={isDarkModeActive}
                    showSnackbar={showSnackbar} // Pass down
                    // If ChainManager needs to trigger App's global modal (optional):
                    // openAppGlobalWorkspaceModal={openAppGlobalWorkspaceModal}
                  />
                </Box>
              </Box>

              {/* Portal for the fixed AppHeader */}
              {ReactDOM.createPortal(
                  <AppHeader darkMode={isDarkModeActive} onToggleDarkMode={handleToggleDarkMode} />,
                  document.getElementById('app-header-container')
              )}

              {/* App's global WorkspaceTaskModal instance */}
              {isAppGlobalModalOpen && appGlobalModalInitialContext && (
                <WorkspaceTaskModal
                   open={isAppGlobalModalOpen}
                   onClose={closeAppGlobalWorkspaceModal}
                   initialContext={appGlobalModalInitialContext}
                   aggregatorUrl={aggregatorUrl}
                   conversationId={conversationId} // Or a different context if truly global
                   activeAgents={activeAgentsForContextSelector} // Use App's agent list for its modal
                   onApplyChanges={appGlobalModalOnApplyChangesCallback} // The callback stored in App's state
                   showSnackbar={showSnackbar} // Pass down
                />
              )}

              <Snackbar
                open={snackbarOpen}
                autoHideDuration={snackbarOptions.autoHideDuration || 6000}
                onClose={handleSnackbarClose}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
              >
                <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }} variant="filled">
                    {snackbarMessage}
                </Alert>
              </Snackbar>
            </React.Fragment>
          </ThemeProvider>
        );
      }
      // --- Top-Level React Render ---
      const rootElement = document.getElementById('root');
      if (rootElement) {
        const reactRoot = ReactDOM.createRoot(rootElement);
        reactRoot.render(<App />);
      } else {
        console.error("Fatal: Root element #root not found in the DOM.");
      }

      /***************************************************************
       * WorkspaceTaskModal
       ***************************************************************/

// --- Constants ---
const WSTM_LOCALSTORAGE_KEY_TEMPLATES = "wstm_chainTemplates_v5";
const WSTM_LOCALSTORAGE_KEY_PREFIX_STATE = "wstm_modalState_v5_"; // Incremented version for new state variables like autoApplyChanges
const WSTM_SCRATCHPAD_FILE_ID = "wstm_internal_scratchpad_file";

const WSTM_CONTEXT_STRATEGY = {
  FULL_SUMMARY: "Full Summary",
  LAST_STEP_OUTPUT_ONLY: "Last Step Output Only",
  RAW_LOG_LAST_3: "Raw Log (Last 3)",
};

const WSTM_STEP_ON_ERROR_ACTION = {
  HALT: "Halt",
  SKIP_AND_CONTINUE: "Skip and Continue",
  RETRY_ONCE_THEN_HALT: "Retry Once (then Halt)",
  PROMPT_USER: "Prompt User for Fix",
};

const WSTM_STEP_RUN_CONDITION_TYPE = {
  NONE: "None",
  PREVIOUS_OUTPUT_CONTAINS: "Previous Output Contains",
  PREVIOUS_OUTPUT_DOES_NOT_CONTAIN: "Previous Output Not Contains",
  FILE_EXISTS: "File Exists in Internal WS",
  FILE_NOT_EXISTS: "File Not Exists in Internal WS",
  SCRATCHPAD_CONTAINS: "Scratchpad Contains",
};

const WSTM_MAX_SELF_CORRECTION_RETRIES = 2;

// Helper: Generate unique ID
function wstmGenerateUniqueId(prefix = "wstm_id_") {
  return `${prefix}${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

// Helper: Parse explanation from agent response
function wstmParseExplanationFromAgentResponse(text) {
  if (typeof text !== 'string') return "";
  const explanationRegex = /(?:###\s*Explanation of Changes|EXPLANATION:|RATIONALE:|REASONING:|NOTE:|CHANGES_SUMMARY:)\s*\r?\n([\s\S]*?)(?=(\nEND_EXPLANATION|\n(?:###\s*|```|FILE:|TERMINAL_CMD:))|$)/im;
  const match = text.match(explanationRegex);
  return (match && match[1]) ? match[1].trim() : "";
}

// Helper: Extract overall explanation from logs
function wstmExtractOverallExplanationFromLogs(logs) {
  if (!Array.isArray(logs)) return "";
  for (const log of logs) {
      if (log && log.role !== "User" && log.role !== "System" && log.content) {
          const parsedOverall = wstmParseExplanationFromAgentResponse(log.content);
          if (parsedOverall) return parsedOverall;
      }
  }
  return "";
}

// Helper: Suggest agents based on keywords
function wstmGetSuggestedAgents(taskPrompt, stepRoleDesc, activeAgents) {
  const suggestions = new Set();
  if ((!taskPrompt && !stepRoleDesc) || !Array.isArray(activeAgents) || activeAgents.length === 0) return Array.from(suggestions);

  const combinedText = ((taskPrompt || "") + " " + (stepRoleDesc || "")).toLowerCase();
  // Enhanced keywords for better agent suggestion
  const keywords = new Set(combinedText.split(/\s+/).filter(kw => kw.length > 2));
  if (keywords.has("code")) { keywords.add("developer"); keywords.add("coder"); }
  if (keywords.has("test")) { keywords.add("tester"); keywords.add("qa"); }
  if (keywords.has("plan")) { keywords.add("planner"); keywords.add("orchestrator"); }
  if (keywords.has("explain")) { keywords.add("explainer"); keywords.add("analyst"); }
  if (keywords.has("review")) { keywords.add("reviewer"); keywords.add("quality"); }

  activeAgents.forEach(agent => {
      if (!agent) return;
      const agentDesc = (agent.role_description || "").toLowerCase();
      const agentName = (agent.name || "").toLowerCase();
      
      let matched = false;
      for(const kw of keywords) {
          if (agentDesc.includes(kw) || agentName.includes(kw)) {
              matched = true;
              break;
          }
      }
      // Also consider direct role match
      if (!matched && stepRoleDesc && agentName === stepRoleDesc.toLowerCase()) {
          matched = true;
      }

      if (matched) {
          suggestions.add(getAgentIdentifierValueString(agent)); // Assumes getAgentIdentifierValueString is global
      }
  });
  return Array.from(suggestions);
}

// Helper: Parse suggested steps from text
function wstmParseSuggestedSteps(text) {
  const steps = [];
  if (typeof text !== 'string') return steps;

  // Pattern 1: STEP <num>: <Role Name> \n Description: <Description Text> (more explicit format)
  // Non-greedy matches for description `[\s\S]+?` up to specific terminators or end of string
  const detailedStepRegex = /STEP\s*(?:\d+\.?\s*)?:\s*(?<role>.+?)\s*\n(?:Description|Instructions|Goal)\s*:\s*(?<description>[\s\S]+?)(?:\nMax Tokens\s*:\s*(?<maxTokens>\d+))?(?:\nTemperature\s*:\s*(?<temperature>[\d.]+))?(?=\n(?:STEP\s*(?:\d+\.?\s*)?:|###|\S*```|FILE:|TERMINAL_CMD:)|\nEND_STEPS|$)/gi;
  let match;
  while ((match = detailedStepRegex.exec(text)) !== null) {
    if (match.groups) {
      const { role, description, maxTokens, temperature } = match.groups;
      if (role && description) {
        steps.push({
          id: wstmGenerateUniqueId("suggested_step_"),
          agentIdentifierObj: null,
          role: role.trim(),
          roleDescription: description.trim(),
          maxTokens: maxTokens ? parseInt(maxTokens, 10) : 8000,
          temperature: temperature ? parseFloat(temperature) : null,
          isEnabled: true, lastError: null,
          runConditionType: WSTM_STEP_RUN_CONDITION_TYPE.NONE, runConditionValue: "",
          onErrorAction: WSTM_STEP_ON_ERROR_ACTION.HALT,
          runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null }
        });
      }
    }
  }

  // Pattern 2: Simple numbered or bulleted list (fallback if Pattern 1 fails)
  // Ensures `role` and `description` are properly captured and trim whitespace.
  // Stops `description` matching at next list item, #, ```, or end of string.
  if (steps.length === 0) {
    const simpleListRegex = /^\s*(?:\d+\.|-|\*)\s*(?<role>[^:]+?)\s*:\s*(?<description>[\s\S]+?)(?=\n\s*(?:\d+\.|-|\*|\S*```|#\S|FILE:|TERMINAL_CMD:)|\nEND_STEPS|$)/gm;
    while ((match = simpleListRegex.exec(text)) !== null) {
      if (match.groups) {
        const { role, description } = match.groups;
        if (role && description) {
          steps.push({
            id: wstmGenerateUniqueId("suggested_step_"),
            agentIdentifierObj: null, role: role.trim(), roleDescription: description.trim(),
            maxTokens: 8000, temperature: 0.5, isEnabled: true, lastError: null,
            runConditionType: WSTM_STEP_RUN_CONDITION_TYPE.NONE, runConditionValue: "",
            onErrorAction: WSTM_STEP_ON_ERROR_ACTION.HALT,
            runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null }
          });
        }
      }
    }
  }
  return steps;
}

// --- Chain State Reducer (prefixed to avoid global scope issues) ---
const WSTM_CHAIN_ACTION_TYPES = {
  START: 'WSTM_START', PAUSE: 'WSTM_PAUSE', RESUME: 'WSTM_RESUME', STOP: 'WSTM_STOP',
  NEXT_STEP: 'WSTM_NEXT_STEP', ADD_LOG: 'WSTM_ADD_LOG', SET_ACCUMULATED_CONTEXT: 'WSTM_SET_ACCUMULATED_CONTEXT',
  RESET_CHAIN_STATE: 'WSTM_RESET_CHAIN_STATE', INIT_STATE_FROM_SAVE: 'WSTM_INIT_STATE_FROM_SAVE',
  SET_USER_INPUT_MODE: 'WSTM_SET_USER_INPUT_MODE',
  SET_DRY_RUN_MODE: 'WSTM_SET_DRY_RUN_MODE',
};

const wstmInitialChainExecutionState = {
  isRunning: false, isPaused: false, currentMiniStepIndex: 0,
  miniChainLogs: [], accumulatedMiniContext: "",
  isAwaitingUserInput: false, userInputPrompt: "", userInputCallback: null,
  isDryRunMode: false,
};

function wstmChainStateReducer(state, action) {
  switch (action.type) {
      case WSTM_CHAIN_ACTION_TYPES.START:
          return { ...state, isRunning: true, isPaused: false, currentMiniStepIndex: 0, isAwaitingUserInput: false, miniChainLogs: [{ role: "System", content: `--- Mini-Chain Started${state.isDryRunMode ? " (Dry Run)" : ""}: ${action.payload.overallTaskPrompt.substring(0, 120)}... ---` }], accumulatedMiniContext: action.payload.overallTaskPrompt };
      case WSTM_CHAIN_ACTION_TYPES.PAUSE: return { ...state, isPaused: true, miniChainLogs: [...state.miniChainLogs.slice(-150), { role: "System", content: "--- Paused ---" }] };
      case WSTM_CHAIN_ACTION_TYPES.RESUME: return { ...state, isPaused: false, isAwaitingUserInput: false, miniChainLogs: [...state.miniChainLogs.slice(-150), { role: "System", content: "--- Resumed ---" }] };
      case WSTM_CHAIN_ACTION_TYPES.STOP: return { ...state, isRunning: false, isPaused: false, isAwaitingUserInput: false, miniChainLogs: [...state.miniChainLogs.slice(-150), { role: "System", content: `--- Stopped by ${action.payload.reason} ---` }] };
      case WSTM_CHAIN_ACTION_TYPES.NEXT_STEP: return { ...state, currentMiniStepIndex: state.currentMiniStepIndex + 1 };
      case WSTM_CHAIN_ACTION_TYPES.ADD_LOG: return { ...state, miniChainLogs: [...state.miniChainLogs.slice(-150), action.payload.logEntry] };
      case WSTM_CHAIN_ACTION_TYPES.SET_ACCUMULATED_CONTEXT: return { ...state, accumulatedMiniContext: action.payload.context };
      case WSTM_CHAIN_ACTION_TYPES.RESET_CHAIN_STATE:
            const resetAccumulatedContext = action.payload.overallTaskPrompt || wstmInitialChainExecutionState.accumulatedMiniContext;
            return { ...wstmInitialChainExecutionState, isDryRunMode: state.isDryRunMode, accumulatedMiniContext: resetAccumulatedContext, miniChainLogs: action.payload.overallTaskPrompt ? [] : wstmInitialChainExecutionState.miniChainLogs };
      case WSTM_CHAIN_ACTION_TYPES.INIT_STATE_FROM_SAVE: return { ...state, miniChainLogs: action.payload.miniChainLogs || [], accumulatedMiniContext: action.payload.accumulatedMiniContext || "", currentMiniStepIndex: 0, isAwaitingUserInput: false };
      case WSTM_CHAIN_ACTION_TYPES.SET_USER_INPUT_MODE: return { ...state, isAwaitingUserInput: action.payload.isAwaiting, userInputPrompt: action.payload.prompt, userInputCallback: action.payload.callback, isPaused: action.payload.isAwaiting };
      case WSTM_CHAIN_ACTION_TYPES.SET_DRY_RUN_MODE: return { ...state, isDryRunMode: action.payload.isDryRun };
      default: return state;
  }
}

// --- Internal Components (prefixed to avoid global scope issues) ---

const WstmInternalCodeWorkspace = React.memo(({ ws, onChange, showSnackbar }) => {
  const textAreaRef = React.useRef(null);
  const editorInstanceRef = React.useRef(null);
  const { content = "" } = ws;
  const theme = useTheme();
  const isDarkMode = theme.palette.mode === 'dark';

  React.useEffect(() => {
      let cmInstance;
      if (textAreaRef.current && !editorInstanceRef.current) {
          const mode = pickCodeMirrorMode(ws.lang || ws.title, content);
          cmInstance = window.CodeMirror.fromTextArea(textAreaRef.current, {
              lineNumbers: true, mode: mode, theme: isDarkMode ? 'material-darker' : 'default',
              autoCloseBrackets: true, matchBrackets: true, foldGutter: true,
              gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
              highlightSelectionMatches: { showToken: /\w/, annotateScrollbar: true },
          });
          cmInstance.setValue(content);
          cmInstance.on("change", (instance) => { onChange(instance.getValue()); });
          editorInstanceRef.current = cmInstance;
      }
      return () => { if (editorInstanceRef.current?.toTextArea) { editorInstanceRef.current.toTextArea(); editorInstanceRef.current = null; } };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  React.useEffect(() => {
      const editor = editorInstanceRef.current;
      if (editor) {
          if (editor.getValue() !== content) {
              const cursor = editor.getCursor();
              editor.setValue(content);
              editor.setCursor(cursor);
          }
          const currentTheme = editor.getOption('theme');
          const newTheme = isDarkMode ? 'material-darker' : 'default';
          if (currentTheme !== newTheme) editor.setOption('theme', newTheme);

          const newModeObj = pickCodeMirrorMode(ws.lang || ws.title, content);
          const currentModeObj = editor.getOption('mode');
          const currentModeStr = typeof currentModeObj === 'string' ? currentModeObj : JSON.stringify(currentModeObj);
          const newModeStr = typeof newModeObj === 'string' ? newModeObj : JSON.stringify(newModeObj);
          if (currentModeStr !== newModeStr) editor.setOption('mode', newModeObj);
      }
  }, [content, isDarkMode, ws.lang, ws.title]);

  const handleCopyCode = React.useCallback(() => {
    if (editorInstanceRef.current) {
        navigator.clipboard.writeText(editorInstanceRef.current.getValue())
            .then(() => showSnackbar(`Code from "${ws.title}" copied!`, "success"))
            .catch(err => showSnackbar(`Failed to copy: ${err.message}`, "error"));
    }
  }, [ws.title, showSnackbar]);

  return (
    <Box sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 1, overflow: 'hidden', display: 'flex', flexDirection: 'column', height: '100%' }}>
        <Box sx={{ p: 1, bgcolor: theme.palette.mode === 'dark' ? theme.palette.background.level2 : theme.palette.grey[100], display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="caption" sx={{ fontWeight: 'bold', color: theme.palette.text.secondary }}>{ws.title} ({ws.lang || 'text'})</Typography>
            <Tooltip title="Copy code"><IconButton onClick={handleCopyCode} size="small" sx={{ p: 0.5 }} aria-label={`Copy code from ${ws.title}`}><Typography sx={{ fontSize: '0.8em' }}>📋</Typography></IconButton></Tooltip>
        </Box>
        <Box sx={{ flexGrow: 1, '& .CodeMirror': { height: '100% !important' } }}>
          <textarea
              ref={textAreaRef}
              id={`wstm-internal-code-ws-${ws.id}`}
              name={`wstmInternalCodeWsName_${ws.id}`}
              aria-label={`Code editor for ${ws.title}`}
              defaultValue={content}
              style={{ display: "none" }}
          />
        </Box>
    </Box>
  );
});

const WstmInternalTextWorkspace = React.memo(({ ws, onChange, isScratchpad = false }) => {
  const theme = useTheme();
  const isDarkMode = theme.palette.mode === 'dark';
  const { content = "" } = ws;
  return (
    <Box sx={{ border: `1px solid ${theme.palette.divider}`, borderRadius: 1, overflow: 'hidden', bgcolor: isScratchpad ? (isDarkMode ? 'rgba(100,100,0,0.1)' : 'rgba(255,255,224,0.5)') : 'transparent', display: 'flex', flexDirection: 'column', height: '100%' }}>
        <Box sx={{ p: 1, bgcolor: isDarkMode ? theme.palette.background.level2 : theme.palette.grey[100] }}>
            <Typography variant="caption" sx={{ fontWeight: 'bold', color: theme.palette.text.secondary }}>{ws.title} {isScratchpad ? "(Scratchpad)" : "(Text)"}</Typography>
        </Box>
        <TextField
            id={`wstm-internal-text-ws-${ws.id}`}
            name={`wstmInternalTextWsName_${ws.id}`}
            aria-label={`Text editor for ${ws.title}${isScratchpad ? " (Scratchpad)" : ""}`}
            multiline
            variant="outlined"
            fullWidth
            value={content}
            onChange={(e) => onChange(e.target.value)}
            InputProps={{ sx: { fontFamily: 'monospace', fontSize: '0.85rem', p: '8px 12px', height: '100%' } }}
            sx={{ flexGrow: 1, '& .MuiOutlinedInput-root': { height: '100%', '& fieldset': { border: 'none' }, backgroundColor: isDarkMode ? 'rgba(0,0,0,0.1)' : 'white', p: 0 }, '.MuiInputBase-inputMultiline': { height: '100% !important', p: '8px 14px', boxSizing: 'border-box' } }}
        />
    </Box>
  );
});

const WstmInternalMiniChainPreviewPanel = React.memo(({ internalWorkspaces, onWorkspaceItemChange, showSnackbar, onRenameFile, onDuplicateFile, onDeleteFile }) => {
  const [expanded, setExpanded] = React.useState(true);
  const [selectedFileId, setSelectedFileId] = React.useState(null);
  const [selectedVersionTimestamp, setSelectedVersionTimestamp] = React.useState("");
  const [renamingFileId, setRenamingFileId] = React.useState(null);
  const [newFileName, setNewFileName] = React.useState("");

  const theme = useTheme();
  const isDarkMode = theme.palette.mode === 'dark';
  const currentFile = React.useMemo(() => internalWorkspaces.find(ws => ws.id === selectedFileId), [internalWorkspaces, selectedFileId]);
  const scratchpadFile = React.useMemo(() => internalWorkspaces.find(ws => ws.id === WSTM_SCRATCHPAD_FILE_ID), [internalWorkspaces]);
  const filesToDisplay = React.useMemo(() => internalWorkspaces.filter(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID && ws.type !== 'text_selection_context'), [internalWorkspaces]);
  const selectionContextFile = React.useMemo(() => internalWorkspaces.find(ws => ws.type === 'text_selection_context'), [internalWorkspaces]);


  const handleFileSelect = React.useCallback((fileId) => {
    setSelectedFileId(prev => (prev === fileId ? null : fileId));
    setSelectedVersionTimestamp("");
    setExpanded(true);
  }, []);

  const handleRevertVersion = React.useCallback(() => {
      if (!currentFile || !selectedVersionTimestamp) { showSnackbar("No file or version selected for revert.", "warning"); return; }
      const versionToRevert = currentFile.versionHistory.find(v => String(v.timestamp) === String(selectedVersionTimestamp));
      if (versionToRevert) { onWorkspaceItemChange(currentFile.id, versionToRevert.content, true); showSnackbar(`"${currentFile.title}" reverted to version from ${new Date(versionToRevert.timestamp).toLocaleString()}.`, "success"); }
      else showSnackbar("Selected version not found.", "error");
  }, [currentFile, selectedVersionTimestamp, onWorkspaceItemChange, showSnackbar]);

  const startRename = React.useCallback((fileId, currentName) => {
    setRenamingFileId(fileId);
    setNewFileName(currentName);
    setSelectedFileId(fileId);
  }, []);

  const confirmRename = React.useCallback(() => {
    if (renamingFileId && newFileName.trim()) {
        onRenameFile(renamingFileId, newFileName.trim());
    }
    setRenamingFileId(null);
    setNewFileName("");
  }, [renamingFileId, newFileName, onRenameFile]);

  const onInternalWorkspaceItemChangeLocal = React.useCallback((fileId, newContent, isRevert) => {
      onWorkspaceItemChange(fileId, newContent, isRevert);
  }, [onWorkspaceItemChange]);

  const hasFilesToList = filesToDisplay.length > 0 || !!selectionContextFile;

  return (
      <Paper variant="outlined" sx={{ p: 1.5, mb: 1, borderColor: theme.palette.divider, display: 'flex', flexDirection: 'column', height: '100%' }}>
          <Box display="flex" justifyContent="space-between" alignItems="center" sx={{ cursor: 'pointer', flexShrink: 0 }} onClick={() => setExpanded(!expanded)}>
            <Typography variant="subtitle1" sx={{ fontWeight: 'medium' }}>Internal Workspace</Typography>
            <IconButton size="small" aria-label={expanded ? "Collapse workspace preview" : "Expand workspace preview"}>{expanded ? '🔼' : '🔽'}</IconButton>
          </Box>
          <Collapse in={expanded} sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column', minHeight: 0, overflow: 'hidden' }}>
              <Box sx={{ mt: 1, display: 'flex', flexDirection: 'column', flexGrow: 1, minHeight: 0 }}>
                  {scratchpadFile && (
                      <Box sx={{ mb:1, flexShrink:0, height: '150px', display: 'flex', flexDirection: 'column' }}>
                          <WstmInternalTextWorkspace ws={scratchpadFile} onChange={(newContent) => onInternalWorkspaceItemChangeLocal(scratchpadFile.id, newContent, false)} isScratchpad={true} />
                      </Box>
                  )}
                   {(selectionContextFile || filesToDisplay.length > 0) && (
                        <Typography variant="caption" sx={{ fontWeight: 'bold', display: 'block', mb:0.5, flexShrink: 0 }}>
                          {selectionContextFile ? "Context Selection / Files:" : "Files:"}
                        </Typography>
                    )}
                  {hasFilesToList && (
                      <Box sx={{ maxHeight: '120px', overflowY: 'auto', flexShrink: 0, background: isDarkMode ? 'rgba(255,255,255,0.02)' : 'rgba(0,0,0,0.02)', borderRadius: 1, border: `1px solid ${theme.palette.divider}` }}>
                        <List dense disablePadding>
                            {selectionContextFile && (
                                <ListItem key={selectionContextFile.id} button onClick={() => handleFileSelect(selectionContextFile.id)} selected={selectedFileId === selectionContextFile.id} sx={{ py: 0.5, px: 1, borderBottom: `1px dotted ${theme.palette.divider}` }}>
                                    <ListItemText primary={`${selectionContextFile.title} (Context)`} primaryTypographyProps={{ variant: 'body2', fontWeight: 'medium', fontStyle:'italic' }} />
                                </ListItem>
                            )}
                            {filesToDisplay.map(ws => (
                                <ListItem key={ws.id} button onClick={() => handleFileSelect(ws.id)} selected={selectedFileId === ws.id} sx={{ py: 0.5, px: 1, borderBottom: `1px dotted ${theme.palette.divider}`, '&:last-child': { borderBottom: 'none' } }}
                                    secondaryAction={ selectedFileId === ws.id && ws.id !== WSTM_SCRATCHPAD_FILE_ID && ws.type !== 'text_selection_context' && (<>
                                        <Tooltip title="Rename"><IconButton edge="end" size="small" onClick={(e) => { e.stopPropagation(); startRename(ws.id, ws.title);}} aria-label={`Rename ${ws.title}`}><Typography sx={{fontSize:'0.7rem'}}>✏️</Typography></IconButton></Tooltip>
                                        <Tooltip title="Duplicate"><IconButton edge="end" size="small" onClick={(e) => { e.stopPropagation(); onDuplicateFile(ws.id);}} aria-label={`Duplicate ${ws.title}`}><Typography sx={{fontSize:'0.7rem'}}>📄</Typography></IconButton></Tooltip>
                                        <Tooltip title="Delete"><IconButton edge="end" size="small" onClick={(e) => { e.stopPropagation(); onDeleteFile(ws.id);}} aria-label={`Delete ${ws.title}`}><Typography sx={{fontSize:'0.7rem'}}>🗑️</Typography></IconButton></Tooltip>
                                    </>)} >
                                    <ListItemText primary={ws.title} secondary={<Typography variant="caption" sx={{ opacity: 0.7 }}>{ws.id.substring(0,15)}...</Typography>} primaryTypographyProps={{ variant: 'body2', fontWeight: 'medium' }} />
                                </ListItem>
                            ))}
                        </List>
                      </Box>
                  )}

                  {renamingFileId && selectedFileId === renamingFileId && (
                      <Box sx={{ mt: 1, display: 'flex', gap: 1, alignItems: 'center', flexShrink: 0 }}>
                          <TextField
                            id={`wstm-internal-rename-field-${renamingFileId}`}
                            name={`wstmInternalRenameFieldName_${renamingFileId}`}
                            size="small" label="New Name" value={newFileName}
                            onChange={(e) => setNewFileName(e.target.value)}
                            fullWidth sx={{fontSize:'0.8rem'}} />
                          <Button size="small" variant="contained" onClick={confirmRename}>Save</Button>
                          <Button size="small" variant="outlined" onClick={() => setRenamingFileId(null)}>Cancel</Button>
                      </Box>
                  )}

                  {currentFile && !renamingFileId && currentFile.id !== WSTM_SCRATCHPAD_FILE_ID && ( // Don't show editor for scratchpad here, it's already above
                    <Box sx={{ mt: 1, flexGrow: 1, display: 'flex', flexDirection: 'column', minHeight: 0 }}>
                        {currentFile.versionHistory && currentFile.versionHistory.length > 1 && (
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1, flexShrink: 0 }}>
                                <FormControl size="small" fullWidth>
                                    <InputLabel id={`wstm-internal-version-label-${currentFile.id}`} htmlFor={`wstm-internal-version-select-input-${currentFile.id}`} sx={{ fontSize: '0.8rem' }}>View/Revert Version</InputLabel>
                                    <Select
                                        labelId={`wstm-internal-version-label-${currentFile.id}`}
                                        id={`wstm-internal-version-select-input-${currentFile.id}`}
                                        name={`wstmInternalVersionSelectName_${currentFile.id}`}
                                        value={selectedVersionTimestamp} label="View/Revert Version"
                                        sx={{ fontSize: '0.8rem' }} onChange={e => setSelectedVersionTimestamp(e.target.value)} displayEmpty>
                                            <MenuItem value="" sx={{ fontSize: '0.8rem' }}><em>(Current Version)</em></MenuItem>
                                            {currentFile.versionHistory.slice().reverse().map(v => <MenuItem key={v.timestamp} value={String(v.timestamp)} sx={{ fontSize: '0.8rem' }}>{new Date(v.timestamp).toLocaleString()} ({v.content.length} chars)</MenuItem>)}
                                    </Select>
                                </FormControl>
                                <Tooltip title={!selectedVersionTimestamp ? "Select a version to revert" : "Revert to selected version"}>
                                  <span>
                                    <Button size="small" variant="outlined" onClick={handleRevertVersion} disabled={!selectedVersionTimestamp} sx={{ fontSize: '0.7rem', p: '2px 6px' }}>Revert</Button>
                                  </span>
                                </Tooltip>
                            </Box>
                        )}
                         <Box sx={{ flexGrow: 1, minHeight: '100px', display: 'flex', flexDirection: 'column' }}>
                            {(currentFile.type === 'code' || currentFile.type === 'html' || currentFile.type === 'css' || currentFile.type === 'text_selection_context') ?
                                <WstmInternalCodeWorkspace ws={currentFile} onChange={(newContent) => onInternalWorkspaceItemChangeLocal(currentFile.id, newContent, false)} showSnackbar={showSnackbar} />
                                : <WstmInternalTextWorkspace ws={currentFile} onChange={(newContent) => onInternalWorkspaceItemChangeLocal(currentFile.id, newContent, false)} />
                            }
                        </Box>
                    </Box>
                  )}
                   {(!scratchpadFile && !selectionContextFile && filesToDisplay.length === 0) && (
                        <Typography variant="body2" sx={{ mt: 1, color: 'text.secondary', textAlign: 'center', flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                            No files or context loaded. Use '+ File' or an agent may create files.
                        </Typography>
                    )}
              </Box>
          </Collapse>
      </Paper>
  );
});

const WstmMiniChainStepItem = React.memo(({ step, idx, miniChainSteps, activeAgents, suggestedAgents, isCurrentExecutingStep, isRunning, isDecomposingTask, isExplainMode, theme, isDarkMode, handleMiniStepChange, moveMiniStep, removeMiniStep, addMiniStep, handleToggleStepEnabled, isDryRunMode, stepExecutionProgress }) => {
  const handleFieldChangeLocal = React.useCallback((field, value) => handleMiniStepChange(step.id, field, value), [handleMiniStepChange, step.id]);
  const progress = isCurrentExecutingStep && stepExecutionProgress !== null ? stepExecutionProgress : 0;
  const commonButtonSx = { fontSize: '0.7rem', p: '2px 6px', minWidth: 'auto' };
  const commonTooltipButtonWrapperSx = { display: 'inline-flex' };

  // Stable IDs for each instance of the step item
  const agentSelectLabelId = `wstm-step-${step.id}-agent-label`;
  const agentSelectInputId = `wstm-step-${step.id}-agent-select`;
  const runConditionTypeLabelId = `wstm-step-${step.id}-runcond-label`;
  const runConditionTypeInputId = `wstm-step-${step.id}-runcond-select`;
  const onErrorActionLabelId = `wstm-step-${step.id}-onerror-label`;
  const onErrorActionInputId = `wstm-step-${step.id}-onerror-select`;

  const agentSelectLabelText = "Assign Agent";
  const runConditionLabelText = "Run Condition";
  const onErrorActionLabelText = "On Error";

  return (
      <Paper variant="outlined" sx={{ p: 0.5, mb: 0.5, borderColor: isCurrentExecutingStep ? theme.palette.primary.main : (step.lastError ? theme.palette.error.main : theme.palette.divider), bgcolor: isCurrentExecutingStep ? (isDarkMode ? 'rgba(144,202,249,0.08)' : 'rgba(25,118,210,0.04)') : 'transparent', borderLeft: `4px solid ${isCurrentExecutingStep ? theme.palette.primary.main : (step.lastError ? theme.palette.error.main : (step.isEnabled ? (isDarkMode ? theme.palette.success.light : theme.palette.success.dark) : theme.palette.grey[500]))}`, opacity: step.isEnabled ? 1 : 0.65, fontSize: '0.8rem' }}>
          <Grid container spacing={0.5} alignItems="flex-start">
              <Grid item xs={12} sm="auto" sx={{ display: 'flex', alignItems: 'center', pt: '4px' }}>
                  <Typography sx={{ fontWeight: 'medium', minWidth: '12px', fontSize: '0.85rem' }}>{idx + 1}.</Typography>
                  <Tooltip title="Move up">
                    <Box component="span" sx={commonTooltipButtonWrapperSx}>
                      <IconButton size="small" onClick={() => moveMiniStep(idx, 'up')} disabled={idx === 0 || isRunning || isDecomposingTask || isDryRunMode} aria-label={`Move step ${idx + 1} up`}><Typography sx={{ fontSize: '0.8rem' }}>🔼</Typography></IconButton>
                    </Box>
                  </Tooltip>
                  <Tooltip title="Move down">
                    <Box component="span" sx={commonTooltipButtonWrapperSx}>
                        <IconButton size="small" onClick={() => moveMiniStep(idx, 'down')} disabled={idx === miniChainSteps.length - 1 || isRunning || isDecomposingTask || isDryRunMode} aria-label={`Move step ${idx + 1} down`}><Typography sx={{ fontSize: '0.8rem' }}>🔽</Typography></IconButton>
                    </Box>
                  </Tooltip>
                  <Tooltip title={step.isEnabled ? "Disable step" : "Enable step"}>
                    <Box component="span" sx={commonTooltipButtonWrapperSx}>
                        <Switch size="small" inputProps={{ 'aria-label': `${step.isEnabled ? "Disable" : "Enable"} step ${idx + 1}`, name: `wstm-step-${step.id}-enabled-switch-name`, id: `wstm-step-${step.id}-enabled-switch-id` }} checked={step.isEnabled} onChange={() => handleToggleStepEnabled(step.id)} disabled={isRunning || isDecomposingTask || isExplainMode || isDryRunMode} />
                    </Box>
                  </Tooltip>
                  {step.lastError && <Tooltip title={`Error: ${step.lastError}`}><IconButton size="small" color="error" aria-label={`Error in step ${idx + 1}: ${step.lastError}`}><Typography sx={{ fontSize: '0.9rem' }}>⚠️</Typography></IconButton></Tooltip>}
              </Grid>
              <Grid item xs={12} sm={3} md={2.5}>
                  <FormControl size="small" fullWidth>
                      <InputLabel id={agentSelectLabelId} htmlFor={agentSelectInputId}>{agentSelectLabelText}</InputLabel> {/* Removed sx, added htmlFor */}
                      <Select
                          labelId={agentSelectLabelId}
                          id={agentSelectInputId}
                          name={`wstm-step-${step.id}-agent-select-name`}
                          value={step.agentIdentifierObj ? getAgentIdentifierValueString(step.agentIdentifierObj) : ""}
                          label={agentSelectLabelText /* Match InputLabel text */}
                          sx={{fontSize:'0.8rem'}}
                          onChange={(e) => handleFieldChangeLocal("agentIdentifierObj", activeAgents.find(ag => getAgentIdentifierValueString(ag) === e.target.value) || null)}
                          disabled={isRunning || isDecomposingTask || !activeAgents || activeAgents.length === 0 || isExplainMode || isDryRunMode}
                          renderValue={(selectedValue) => {
                              const agent = activeAgents && activeAgents.find(ag => getAgentIdentifierValueString(ag) === selectedValue);
                              return agent ? (agent.name || `Port ${agent.port}`) : <em style={{opacity:0.7}}>(Unassigned)</em>;
                          }}
                      >
                          <MenuItem value="" sx={{fontSize:'0.8rem'}}><em>(Unassigned)</em></MenuItem>
                          {suggestedAgents.length > 0 && <ListSubheader sx={{fontSize:'0.7rem', fontWeight:'bold', bgcolor: isDarkMode ? 'rgba(255,255,255,0.05)' : 'grey.100'}}>Suggested</ListSubheader>}
                          {suggestedAgents.map(agentVal => {
                              const agent = activeAgents && activeAgents.find(a => getAgentIdentifierValueString(a) === agentVal);
                              return agent ? (<MenuItem key={`suggested-${agentVal}`} value={agentVal} sx={{fontSize:'0.8rem', fontWeight: 'bold', color: isDarkMode ? theme.palette.success.light : theme.palette.success.dark }}>{agent.name || `Port ${agent.port}`} {agent.type ? `(${agent.type.replace(/_main_server|specialist|orchestrator|network_scanned/g, m => m[0].toUpperCase())})` : ''}{agent.role_description && <Tooltip title={agent.role_description}><IconButton size="small" sx={{ml: 'auto', p:0.1}} aria-label={`Agent ${agent.name || `Port ${agent.port}`} info`}><Typography sx={{fontSize:'0.65em'}}>ℹ️</Typography></IconButton></Tooltip>}</MenuItem>) : null;
                          })}
                          {suggestedAgents.length > 0 && <Divider />}
                          {activeAgents && activeAgents.filter(agent => !suggestedAgents.includes(getAgentIdentifierValueString(agent))).map(agent => {
                              const agentVal = getAgentIdentifierValueString(agent);
                              return (<MenuItem key={`other-${agentVal}`} value={agentVal} sx={{fontSize:'0.8rem'}}>{agent.name || `Port ${agent.port}`} {agent.type ? `(${agent.type.replace(/_main_server|specialist|orchestrator|network_scanned/g, m => m[0].toUpperCase())})` : ''}{agent.role_description && <Tooltip title={agent.role_description}><IconButton size="small" sx={{ml:'auto', p:0.1}} aria-label={`Agent ${agent.name || `Port ${agent.port}`} info`}><Typography sx={{fontSize:'0.65em'}}>ℹ️</Typography></IconButton></Tooltip>}</MenuItem>);
                          })}
                      </Select>
                  </FormControl>
              </Grid>
              <Grid item xs={12} sm={2.5} md={1.5}><TextField id={`wstm-step-${step.id}-role-input`} name={`wstm-step-${step.id}-role-name`} label="Role Name" size="small" fullWidth value={step.role} sx={{ '& .MuiInputBase-input': { fontSize: '0.8rem' } }} InputLabelProps={{ style: { fontSize: '0.8rem' } }} onChange={(e) => handleFieldChangeLocal("role", e.target.value)} disabled={isRunning || isDecomposingTask || isExplainMode || isDryRunMode} /></Grid>
              <Grid item xs={12} sm={6.5} md={3.5}><TextField id={`wstm-step-${step.id}-roleDescription-input`} name={`wstm-step-${step.id}-roleDescription-name`} label="Role Description" multiline minRows={1} maxRows={3} size="small" fullWidth value={step.roleDescription} sx={{ '& .MuiInputBase-input': { fontSize: '0.8rem' } }} InputLabelProps={{ style: { fontSize: '0.8rem' } }} onChange={(e) => handleFieldChangeLocal("roleDescription", e.target.value)} disabled={isRunning || isDecomposingTask || isExplainMode || isDryRunMode} helperText={isExplainMode ? "" : "Remind about EXPLANATIONs."} /></Grid>
              <Grid item xs={6} sm={3} md={1}><TextField id={`wstm-step-${step.id}-maxTokens-input`} name={`wstm-step-${step.id}-maxTokens-name`} label="Max Tokens" type="number" size="small" fullWidth value={String(step.maxTokens)} sx={{ '& .MuiInputBase-input': { fontSize: '0.8rem' } }} InputLabelProps={{ style: { fontSize: '0.8rem' } }} onChange={(e) => handleFieldChangeLocal("maxTokens", e.target.value)} disabled={isRunning || isDecomposingTask || isExplainMode || isDryRunMode} InputProps={{ inputProps: { min: 100 } }} /></Grid>
              <Grid item xs={6} sm={3} md={1}><TextField id={`wstm-step-${step.id}-temperature-input`} name={`wstm-step-${step.id}-temperature-name`} label="Temp" type="number" size="small" fullWidth value={step.temperature === null ? '' : String(step.temperature)} sx={{ '& .MuiInputBase-input': { fontSize: '0.8rem' } }} InputLabelProps={{ style: { fontSize: '0.8rem' } }} onChange={(e) => handleFieldChangeLocal("temperature", e.target.value)} placeholder="Def." disabled={isRunning || isDecomposingTask || isExplainMode || isDryRunMode} InputProps={{ inputProps: { min: 0, max: 2, step: 0.1 } }} /></Grid>
              {!isExplainMode && <Grid item xs={12} sm="auto" sx={{ display: 'flex', gap: 0.5, alignItems: 'center', pt: { xs: 0.5, sm: 0 } }}>
                  <Tooltip title="Duplicate step">
                    <Box component="span" sx={commonTooltipButtonWrapperSx}>
                        <Button variant="outlined" size="small" onClick={() => addMiniStep(step)} disabled={isRunning || isDecomposingTask || isDryRunMode} sx={commonButtonSx} aria-label={`Duplicate step ${idx + 1}`}>Copy</Button>
                    </Box>
                  </Tooltip>
                  <Tooltip title="Remove step">
                    <Box component="span" sx={commonTooltipButtonWrapperSx}>
                        <Button variant="outlined" color="secondary" size="small" onClick={() => removeMiniStep(step.id)} disabled={isRunning || isDecomposingTask || isDryRunMode} sx={commonButtonSx} aria-label={`Delete step ${idx + 1}`}>Del</Button>
                    </Box>
                  </Tooltip>
              </Grid>}

              {!isExplainMode && <Grid item xs={12}><Divider sx={{ my: 0.5 }} /></Grid>}
              {!isExplainMode && <Grid item xs={12} sm={4} md={3}>
                  <FormControl size="small" fullWidth>
                      <InputLabel id={runConditionTypeLabelId} htmlFor={runConditionTypeInputId}>{runConditionLabelText}</InputLabel> {/* Removed sx, added htmlFor */}
                      <Select labelId={runConditionTypeLabelId} id={runConditionTypeInputId} name={`wstm-step-${step.id}-runConditionType-name`} value={step.runConditionType || WSTM_STEP_RUN_CONDITION_TYPE.NONE} label={runConditionLabelText} sx={{ fontSize: '0.75rem' }} onChange={(e) => handleFieldChangeLocal("runConditionType", e.target.value)} disabled={isRunning || isDecomposingTask || isDryRunMode}> {Object.values(WSTM_STEP_RUN_CONDITION_TYPE).map(type => (<MenuItem key={type} value={type} sx={{ fontSize: '0.75rem' }}>{type}</MenuItem>))} </Select>
                  </FormControl>
              </Grid>}
              {!isExplainMode && step.runConditionType !== WSTM_STEP_RUN_CONDITION_TYPE.NONE && <Grid item xs={12} sm={4} md={5}>
                  <TextField id={`wstm-step-${step.id}-runConditionValue-input`} name={`wstm-step-${step.id}-runConditionValue-name`} label="Condition Value" size="small" fullWidth value={step.runConditionValue || ""} sx={{ '& .MuiInputBase-input': { fontSize: '0.75rem' } }} InputLabelProps={{ style: { fontSize: '0.75rem' } }} onChange={(e) => handleFieldChangeLocal("runConditionValue", e.target.value)} disabled={isRunning || isDecomposingTask || isDryRunMode} helperText={step.runConditionType === WSTM_STEP_RUN_CONDITION_TYPE.PREVIOUS_OUTPUT_CONTAINS ? "Keyword in last agent output" : step.runConditionType === WSTM_STEP_RUN_CONDITION_TYPE.SCRATCHPAD_CONTAINS ? "Keyword in Scratchpad" : "e.g., filename.txt"} />
              </Grid>}
              {!isExplainMode && <Grid item xs={12} sm={4} md={3}>
                  <FormControl size="small" fullWidth>
                      <InputLabel id={onErrorActionLabelId} htmlFor={onErrorActionInputId}>{onErrorActionLabelText}</InputLabel> {/* Removed sx, added htmlFor */}
                      <Select labelId={onErrorActionLabelId} id={onErrorActionInputId} name={`wstm-step-${step.id}-onErrorAction-name`} value={step.onErrorAction || WSTM_STEP_ON_ERROR_ACTION.HALT} label={onErrorActionLabelText} sx={{ fontSize: '0.75rem' }} onChange={(e) => handleFieldChangeLocal("onErrorAction", e.target.value)} disabled={isRunning || isDecomposingTask || isDryRunMode}> {Object.values(WSTM_STEP_ON_ERROR_ACTION).map(action => (<MenuItem key={action} value={action} sx={{ fontSize: '0.75rem' }}>{action}</MenuItem>))} </Select>
                  </FormControl>
              </Grid>}
              {isCurrentExecutingStep && !isDryRunMode && (
                  <Grid item xs={12} sx={{pt:0.5}}>
                      <LinearProgress variant={stepExecutionProgress === null ? "indeterminate" : "determinate"} value={progress} />
                      <Typography variant="caption" sx={{display:'block', textAlign:'center', mt:0.2}}>{stepExecutionProgress === null ? "Working..." : `Progress: ${progress}%`}</Typography>
                  </Grid>
              )}
          </Grid>
      </Paper>
  );
});

const WstmUserInputDialog = React.memo(({ open, title, message, onSubmit, onCancel }) => {
  const [inputValue, setInputValue] = React.useState("");
  const handleSubmit = React.useCallback(() => { onSubmit(inputValue); setInputValue(""); }, [onSubmit, inputValue]);
  const handleClose = React.useCallback(() => { onCancel(); setInputValue(""); }, [onCancel]);

  return (
      <Dialog open={open} onClose={handleClose} maxWidth="sm" fullWidth>
          <DialogTitle>{title || "User Input Required"}</DialogTitle>
          <DialogContent>
              <Typography gutterBottom>{message}</Typography>
              <TextField
                  autoFocus
                  multiline
                  minRows={3}
                  margin="dense"
                  id="wstm-user-input-dialog-textfield-id"
                  name="wstmUserInputDialogTextfieldName"
                  label="Your Response"
                  type="text"
                  fullWidth
                  variant="outlined"
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyPress={(e) => { if (e.key === 'Enter' && !e.shiftKey && inputValue.trim()) { e.preventDefault(); handleSubmit(); } }}
              />
          </DialogContent>
          <DialogActions>
              <Button onClick={handleClose}>Cancel</Button>
              <Button onClick={handleSubmit} variant="contained" disabled={!inputValue.trim()}>Submit</Button>
          </DialogActions>
      </Dialog>
  );
});


// --- WorkspaceTaskModal Component ---
function WorkspaceTaskModal({
  open,
  onClose,
  initialContext, // Should include uniqueTrigger: Date.now() from parent if force re-init desired
  aggregatorUrl,
  conversationId,
  activeAgents,
  onApplyChanges,
  showSnackbar: showSnackbarProp,
}) {

  const theme = useTheme();
  const isDarkMode = theme.palette.mode === 'dark';

  const showSnackbar = React.useCallback((message, severity = "info", options = {}) => {
      if (typeof showSnackbarProp === 'function') {
          showSnackbarProp(message, severity, options);
      } else {
          console.warn("WorkspaceTaskModal: showSnackbar prop not a function. Message:", message, severity, options);
      }
  }, [showSnackbarProp]);

  const defaultStepData = React.useMemo(() => ({
      lastError: null,
      runConditionType: WSTM_STEP_RUN_CONDITION_TYPE.NONE,
      runConditionValue: "",
      onErrorAction: WSTM_STEP_ON_ERROR_ACTION.HALT,
      runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null },
  }), []);

  // Memoize suggestAgentForRole for stability
  const suggestAgentForRole = React.useCallback((roleName = "", agents) => {
      if (!Array.isArray(agents) || agents.length === 0) return null;
      const lowerRole = roleName.toLowerCase();
      for (const agent of agents) {
          if (!agent) continue;
          const agentDesc = (agent.role_description || '').toLowerCase();
          const agentName = (agent.name || '').toLowerCase();
          if (lowerRole.includes("planner") && (agentDesc.includes("plan") || agentDesc.includes("decompose") || agentName.includes("planner"))) return agent;
          if (lowerRole.includes("explain") && (agentDesc.includes("explain") || agentName.includes("explainer"))) return agent;
          if ((lowerRole.includes("develop") || lowerRole.includes("coder")) && (agentDesc.includes("code") || agentName.includes("coder") || agentDesc.includes("develop"))) return agent;
          if (lowerRole.includes("review") && (agentDesc.includes("review") || agentDesc.includes("quality") || agentName.includes("reviewer"))) return agent;
      }
      return agents[0]; // Fallback to the first agent
  }, []);


  const explainThisDefaultSteps = React.useMemo(() => {
      const explainerAgent = suggestAgentForRole("Code/Text Explainer", activeAgents) || (activeAgents && activeAgents.length > 0 ? activeAgents[0] : null);
      return [{ id: wstmGenerateUniqueId("step_explain_"), agentIdentifierObj: explainerAgent, role: "Code/Text Explainer", roleDescription: "Explain the provided text/code snippet clearly, focusing on its purpose and key components.", maxTokens: 3000, temperature: 0.3, isEnabled: true, ...defaultStepData }];
  }, [activeAgents, defaultStepData, suggestAgentForRole]);

  const generalDefaultSteps = React.useMemo(() => {
      const codeEnhancerAgent = suggestAgentForRole("Code Enhancer", activeAgents) || (activeAgents && activeAgents.length > 0 ? activeAgents[0] : null);
      const qualityReviewerAgent = suggestAgentForRole("Quality Reviewer", activeAgents) || (activeAgents && activeAgents.length > 1 ? activeAgents[1] : codeEnhancerAgent);
      return [
          { id: wstmGenerateUniqueId("step_"), agentIdentifierObj: codeEnhancerAgent, role: "Code Enhancer", roleDescription: "Analyze code. Refactor. Add comments. IMPORTANT: Include 'EXPLANATION for filename.ext:\\n...\\nEND_EXPLANATION'.", maxTokens: 8000, temperature: 0.4, isEnabled: true, ...defaultStepData },
          { id: wstmGenerateUniqueId("step_"), agentIdentifierObj: qualityReviewerAgent, role: "Quality Reviewer", roleDescription: "Review changes. Identify issues. Output review/corrections WITH EXPLANATIONS using 'EXPLANATION for filename.ext:\\n...\\nEND_EXPLANATION'.", maxTokens: 6000, temperature: 0.3, isEnabled: true, ...defaultStepData },
      ];
  }, [activeAgents, defaultStepData, suggestAgentForRole]);

  const getLocalStorageKey = React.useCallback(() => {
      if (!conversationId || !initialContext) return null;
      const contextType = initialContext.type;
      let contextIdSuffix = 'generic';
      if (contextType === 'files' && initialContext.selectedFiles?.length > 0) {
          contextIdSuffix = initialContext.selectedFiles.map(f => f.id || f.title).sort().join('_');
      } else if (initialContext.fileId) {
          contextIdSuffix = initialContext.fileId;
      }

      // Add a hash of content only if it's short, to avoid overly long keys.
      // This part might be too sensitive; consider if it's truly needed for key uniqueness.
      if (initialContext.content && initialContext.content.length < 500) { // Arbitrary length limit
          let hash = 0;
          for (let i = 0; i < initialContext.content.length; i++) {
              hash = ((hash << 5) - hash) + initialContext.content.charCodeAt(i);
              hash |= 0; // Convert to 32bit integer
          }
          contextIdSuffix += `_c${hash}`;
      }
      return `${WSTM_LOCALSTORAGE_KEY_PREFIX_STATE}${conversationId}_${contextType}_${initialContext.mode || 'task'}_${contextIdSuffix.replace(/[^a-zA-Z0-9_-]/g, '')}`.substring(0, 150);
  }, [conversationId, initialContext]);

  const [overallTaskPrompt, setOverallTaskPrompt] = React.useState("");
  const [miniChainSteps, setMiniChainSteps] = React.useState([]);
  const [chainState, dispatchChainAction] = React.useReducer(wstmChainStateReducer, wstmInitialChainExecutionState);
  const [internalWorkspaces, setInternalWorkspaces] = React.useState([]);
  const [showDiffReview, setShowDiffReview] = React.useState(false);
  const [changesForDiff, setChangesForDiff] = React.useState([]);
  const miniChainLogsEndRef = React.useRef(null);
  const [originalFileContentsMap, setOriginalFileContentsMap] = React.useState({});
  const [contextStrategy, setContextStrategy] = React.useState(WSTM_CONTEXT_STRATEGY.LAST_STEP_OUTPUT_ONLY);
  const [chainTemplates, setChainTemplates] = React.useState([]);
  const [selectedChainTemplateName, setSelectedChainTemplateName] = React.useState("");
  const [planText, setPlanText] = React.useState("");
  const [isGeneratingPlan, setIsGeneratingPlan] = React.useState(false);
  const [orchestratorForPlan, setOrchestratorForPlan] = React.useState(null);
  const [showAllAgentsForPlan, setShowAllAgentsForPlan] = React.useState(false); // For plan agent selection
  // Removed: selectedInternalFileToDelete state - delete action will be contextual
  const [showFeedbackDialog, setShowFeedbackDialog] = React.useState(false);
  const [feedbackData, setFeedbackData] = React.useState({ rating: 0, comments: "", changesAccepted: false });
  const [isDecomposingTask, setIsDecomposingTask] = React.useState(false);
  const [autoScrollLogs, setAutoScrollLogs] = React.useState(false);
  const [stepExecutionProgress, setStepExecutionProgress] = React.useState(null);
  const [enableProactiveRetries, setEnableProactiveRetries] = React.useState(false);
  const [autoExecuteTermCmds, setAutoExecuteTermCmds] = React.useState(false);
  const [autoApplyChanges, setAutoApplyChanges] = React.useState(false); // NEW state for auto-apply

  const isInitializedRef = React.useRef(null); // Store { initialized: boolean, lastProcessedTrigger: any }

  const ensureScratchpadFile = React.useCallback(() => {
      setInternalWorkspaces(prevWs => {
          if (!prevWs.some(ws => ws.id === WSTM_SCRATCHPAD_FILE_ID)) {
              const scratchpadContent = "// Personal notes and temporary data for the chain.\n// Not automatically sent to agents unless referenced in prompts or conditions.\n";
              const scratchpad = { id: WSTM_SCRATCHPAD_FILE_ID, title: "Scratchpad", type: "text", content: scratchpadContent, lang: "text", parentId: null, versionHistory: [{ content: scratchpadContent, timestamp: Date.now() }], lastExplanation: "" };
              // Ensure scratchpad is added and existing scratchpads are removed if any accidental duplicates
              return [scratchpad, ...prevWs.filter(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID)];
          }
          return prevWs;
      });
  }, []);

  React.useEffect(() => { /* Load/Save Templates */
      try { const savedTemplates = localStorage.getItem(WSTM_LOCALSTORAGE_KEY_TEMPLATES); if (savedTemplates) setChainTemplates(JSON.parse(savedTemplates)); } catch (e) { console.error("Error loading chain templates:", e); setChainTemplates([]); }
  }, []);
  React.useEffect(() => { try { localStorage.setItem(WSTM_LOCALSTORAGE_KEY_TEMPLATES, JSON.stringify(chainTemplates)); } catch (e) { console.error("Error saving chain templates:", e); } }, [chainTemplates]);

  // PRIMARY INITIALIZATION EFFECT (Hook #3)
  React.useEffect(() => {
    if (open) {
        const currentTrigger = initialContext?.uniqueTrigger; // Parent should pass this to force re-init
        // Check if already initialized with this context, or if the context itself demands re-initialization
        if (!isInitializedRef.current || (isInitializedRef.current.initialized && initialContext && isInitializedRef.current.lastProcessedTrigger !== currentTrigger) ) {
            const storageKey = getLocalStorageKey(); let loadedState = null;
            if (storageKey) { try { const savedStateRaw = localStorage.getItem(storageKey); if (savedStateRaw) loadedState = JSON.parse(savedStateRaw); } catch (e) { console.error("Error loading modal state:", e); localStorage.removeItem(storageKey); }}

            const taskPromptToUse = loadedState?.overallTaskPrompt || "";
            setOverallTaskPrompt(taskPromptToUse);
            dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.RESET_CHAIN_STATE, payload: { overallTaskPrompt: taskPromptToUse } });
            setChangesForDiff([]); setOriginalFileContentsMap({});
            setInternalWorkspaces([]); // Clear first to ensure a clean state before adding scratchpad
            ensureScratchpadFile();    // This adds the scratchpad to the now-empty internalWorkspaces

            setContextStrategy(loadedState?.contextStrategy || WSTM_CONTEXT_STRATEGY.LAST_STEP_OUTPUT_ONLY);
            setPlanText(loadedState?.planText || ""); // Restore plan text if available
            setEnableProactiveRetries(loadedState?.enableProactiveRetries !== undefined ? loadedState.enableProactiveRetries : false);
            setAutoExecuteTermCmds(loadedState?.autoExecuteTermCmds !== undefined ? loadedState.autoExecuteTermCmds : false);
            setAutoScrollLogs(loadedState?.autoScrollLogs !== undefined ? loadedState.autoScrollLogs : false);
            setAutoApplyChanges(loadedState?.autoApplyChanges !== undefined ? loadedState.autoApplyChanges : false); // Restore auto-apply

            setIsGeneratingPlan(false); setIsDecomposingTask(false);

            if (loadedState && initialContext?.mode !== 'explain_this') {
                const loadedSteps = (loadedState.miniChainSteps || generalDefaultSteps).map(s => ({
                    ...defaultStepData, ...s,
                    id: s.id || wstmGenerateUniqueId("step_"),
                    agentIdentifierObj: s.agentIdentifierObj ? (activeAgents.find(a => getAgentIdentifierValueString(a) === getAgentIdentifierValueString(s.agentIdentifierObj)) || suggestAgentForRole(s.role, activeAgents)) : suggestAgentForRole(s.role, activeAgents),
                    isEnabled: s.isEnabled !== undefined ? s.isEnabled : true, lastError: null, runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null }
                }));
                setMiniChainSteps(loadedSteps);
                setInternalWorkspaces(prevWs => { // prevWs here is now [scratchpad] from `ensureScratchpadFile`
                    const existingScratchpad = prevWs.find(ws => ws.id === WSTM_SCRATCHPAD_FILE_ID);
                    const otherLoadedWs = (loadedState.internalWorkspaces || []).filter(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID);
                    return existingScratchpad ? [existingScratchpad, ...otherLoadedWs] : [...otherLoadedWs]; // Preserve scratchpad, merge loaded files
                });
                dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.INIT_STATE_FROM_SAVE, payload: { miniChainLogs: loadedState.miniChainLogs, accumulatedMiniContext: loadedState.accumulatedMiniContext } });
                showSnackbar("Loaded saved modal state.", "info");
            } else if (initialContext) { // Fresh initialization based on initialContext (no loadedState, or in 'explain_this' mode)
                let initialPromptTextValue = ""; let initialWorkspacesToLoad = []; const tempOriginalMap = {};

                if (initialContext.type === 'files' && initialContext.selectedFiles?.length > 0) {
                    const filesForModal = initialContext.selectedFiles.map(f => deepCopyWorkspaceItem(f));
                    filesForModal.forEach(f => tempOriginalMap[f.id] = f.content);
                    initialWorkspacesToLoad = filesForModal;
                    initialPromptTextValue = `Context: Files (${filesForModal.map(f => f.title || f.id).join(', ')}). Overall Task:\n[Your task here, e.g., Refactor and add docstrings.]`;
                } else if (initialContext.type === 'text_selection' || initialContext.type === 'explain_selection') {
                    const conceptualFile = {
                        id: initialContext.fileId || wstmGenerateUniqueId("selection_"), type: 'text_selection_context',
                        title: `Selection from ${initialContext.fileId?.split('/').pop() || 'unknown'}`,
                        content: initialContext.content, lang: initialContext.lang || "text", parentId: null,
                        versionHistory: [{ content: initialContext.content, timestamp: Date.now() }]
                    };
                    tempOriginalMap[conceptualFile.id] = conceptualFile.content;
                    initialWorkspacesToLoad = [conceptualFile];
                    initialPromptTextValue = initialContext.type === 'explain_selection'
                        ? `Explain this selected text/code from ${initialContext.fileId || 'context'}:\n\n---\n${initialContext.content}\n---`
                        : `Context: Text selection from ${initialContext.fileId}.\nOverall Task:\n[Your task here, e.g., Analyze and summarize.]`;
                } else {
                    showSnackbar("Modal opened without valid file/text context.", "error"); onClose(); return;
                }
                setOverallTaskPrompt(initialPromptTextValue); setOriginalFileContentsMap(tempOriginalMap);
                setInternalWorkspaces(prevWs => { // prevWs here is [scratchpad]
                    const existingScratchpad = prevWs.find(ws => ws.id === WSTM_SCRATCHPAD_FILE_ID);
                    return existingScratchpad ? [existingScratchpad, ...initialWorkspacesToLoad] : [...initialWorkspacesToLoad];
                });
                dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.RESET_CHAIN_STATE, payload: { overallTaskPrompt: initialPromptTextValue } });
                const currentModeSteps = initialContext?.mode === 'explain_this' ? explainThisDefaultSteps : generalDefaultSteps;
                setMiniChainSteps( currentModeSteps.map(s => ({ ...s, agentIdentifierObj: s.agentIdentifierObj || suggestAgentForRole(s.role, activeAgents) })) );
            }
            isInitializedRef.current = { initialized: true, lastProcessedTrigger: currentTrigger };
        }
    } else { // Modal is not open, reset initialization flag for next time
        isInitializedRef.current = null;
    }
  }, [
    open, initialContext, getLocalStorageKey, defaultStepData, explainThisDefaultSteps,
    generalDefaultSteps, activeAgents, showSnackbar, onClose, ensureScratchpadFile, suggestAgentForRole
  ]);

  React.useEffect(() => { /* Save current modal state to localStorage */
      if (open && !chainState.isRunning && !isDecomposingTask && initialContext?.mode !== 'explain_this' && isInitializedRef.current?.initialized) {
          const storageKey = getLocalStorageKey();
          if (storageKey) {
              const stateToSave = {
                  overallTaskPrompt, miniChainSteps: miniChainSteps.map(s => ({ ...s, lastError: null, runtimeData: undefined })),
                  internalWorkspaces, miniChainLogs: chainState.miniChainLogs,
                  accumulatedMiniContext: chainState.accumulatedMiniContext, contextStrategy,
                  planText, enableProactiveRetries, autoExecuteTermCmds, autoScrollLogs,
                  autoApplyChanges // NEW: Save autoApplyChanges state
              };
              try { localStorage.setItem(storageKey, JSON.stringify(stateToSave)); }
              catch (e) { console.error("Error saving modal state:", e); showSnackbar("Could not save modal state.", "warning"); }
          }
      }
  }, [
      open, overallTaskPrompt, miniChainSteps, internalWorkspaces, chainState.miniChainLogs,
      chainState.accumulatedMiniContext, contextStrategy, planText, enableProactiveRetries,
      autoExecuteTermCmds, autoScrollLogs, autoApplyChanges, getLocalStorageKey, chainState.isRunning,
      isDecomposingTask, initialContext?.mode, showSnackbar
  ]);

  React.useEffect(() => { /* Auto-scroll logs */
      if (autoScrollLogs && miniChainLogsEndRef.current) { miniChainLogsEndRef.current.scrollIntoView({ behavior: "smooth" }); }
  }, [chainState.miniChainLogs, autoScrollLogs]);
  React.useEffect(() => { /* Task prompt length warning */
      if (!open) return; const charCount = overallTaskPrompt.length; const estimatedTokens = Math.ceil(charCount / 4);
      if (estimatedTokens > 4000) { showSnackbar(`Warning: Task prompt is ~${estimatedTokens} tokens. Consider shortening.`, "warning", { autoHideDuration: 8000 }); }
  }, [overallTaskPrompt, showSnackbar, open]);

  const handleRunMiniChain = React.useCallback(() => {
      if (!overallTaskPrompt.trim()) { showSnackbar("Provide overall task prompt.", "warning"); return; }
      const enabledSteps = miniChainSteps.filter(s => s.isEnabled);
      if (enabledSteps.length === 0) { showSnackbar("No enabled steps.", "warning"); return; }
      if (enabledSteps.some(step => !step.agentIdentifierObj)) { showSnackbar("Enabled steps lack agent assignment.", "error"); return; }
      // Warn if files needed but none provided (excluding scratchpad)
      if (initialContext?.mode !== 'explain_this' && internalWorkspaces.filter(f => f.id !== WSTM_SCRATCHPAD_FILE_ID && f.type !== 'text_selection_context').length === 0 && initialContext?.type !== 'text_selection') {
          const requiresFiles = enabledSteps.some(s => (s.roleDescription || "").toLowerCase().match(/file|code|script|document/));
          if (requiresFiles) showSnackbar("No files in context (excluding scratchpad & selection), but steps may need them.", "warning");
      }
      setMiniChainSteps(prev => prev.map(s => ({ ...s, lastError: null, runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null } })));
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.START, payload: { overallTaskPrompt } });
      showSnackbar(`Mini-chain started${chainState.isDryRunMode ? " (Dry Run)" : ""}.`, "info");
  }, [overallTaskPrompt, miniChainSteps, initialContext, internalWorkspaces, showSnackbar, chainState.isDryRunMode]);

  const handlePauseMiniChain = React.useCallback(() => dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.PAUSE }), []);
  const handleResumeMiniChain = React.useCallback(() => dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.RESUME }), []);
  const handleStopMiniChain = React.useCallback((reason = "User") => {
    dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason } });
    setStepExecutionProgress(null); // Clear progress on stop
  }, []);

  const _callAgentForCurrentStep = React.useCallback(async (stepData, currentPrompt, lastAgentMessage) => {
      // THIS FUNCTION IS INTENDED FOR ACTUAL MINI-CHAIN EXECUTION STEPS
      // It MUST use interactiveStepApi as it relies on backend's context management,
      // directive parsing, file operations, and summarization within the step.
      const apiWorkspaces = internalWorkspaces
          .filter(ws => ws.type !== 'text_selection_context' || initialContext?.mode === 'explain_this') // Send selection context if in explain mode
          .filter(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID) // DO NOT send scratchpad content directly via API
          .map(w => ({ title: w.id, content: w.content, type: w.type, lang: w.lang }));

      let userMessageForAgent = currentPrompt;
      // Remind agent to include explanations for file changes
      if (initialContext?.mode !== 'explain_this') {
        userMessageForAgent += `\n\nIMPORTANT: When making file changes, include an explanation using 'EXPLANATION for filename.ext:\\n...\\nEND_EXPLANATION'. For changes to selections, use 'EXPLANATION for selection in original_filename.ext:'.`;
      }

      // Explicitly inject scratchpad content into prompt if agent's role description or prompt indicates
      const scratchpad = internalWorkspaces.find(ws => ws.id === WSTM_SCRATCHPAD_FILE_ID);
      if (scratchpad && (stepData.roleDescription?.toLowerCase().includes("scratchpad") || userMessageForAgent.toLowerCase().includes("scratchpad"))) {
          userMessageForAgent += `\n\n--- SCRATCHPAD CONTENT ---\n${scratchpad.content}\n--- END SCRATCHPAD ---`;
      }

      const contextSnapshot = {
          userMessagePreview: userMessageForAgent.substring(0,500) + (userMessageForAgent.length > 500 ? "..." : ""),
          workspaces: apiWorkspaces.map(ws => ({ title: ws.title, type: ws.type, lang: ws.lang, contentPreview: ws.content.substring(0, 200) + (ws.content.length > 200 ? "..." : "") })),
          lastAgentMessagePreview: lastAgentMessage.substring(0, 200) + (lastAgentMessage.length > 200 ? "..." : ""),
      };
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System (Context Snapshot)", content: `Context for Agent ${stepData.role}:\nUser Message Preview: ${contextSnapshot.userMessagePreview}\nWorkspaces: ${contextSnapshot.workspaces.map(w=>w.title).join(', ')}\nLast Agent Msg Preview: ${contextSnapshot.lastAgentMessagePreview}`, isContextSnapshot: true } } });

      if (chainState.isDryRunMode) {
          showSnackbar(`Dry Run: Step "${stepData.role}" would execute.`, "info", {autoHideDuration: 1500});
          setStepExecutionProgress({ stepId: stepData.id, progress: 100 });
          await new Promise(resolve => setTimeout(resolve, 300)); // Shorter delay for dry run
          return "[Dry Run: Agent would respond here.]";
      }

      setStepExecutionProgress({ stepId: stepData.id, progress: null }); // Indeterminate
      let progressInterval;
      // Rough estimate for progress bar: 3s per 4k tokens, minimum 1 second for any progress display
      const estimatedDuration = Math.max(1000, (stepData.maxTokens / 4000) * 3000); 
      if (estimatedDuration > 1000) { 
           progressInterval = setInterval(() => {
              setStepExecutionProgress(prev => {
                if (!prev || prev.stepId !== stepData.id) return prev; // Stale update or step changed
                return { stepId: stepData.id, progress: Math.min(95, (prev.progress === null ? 0 : prev.progress) + 5) }; // Cap at 95%
              });
          }, Math.max(200, estimatedDuration / 20)); // Update ~20 times over estimated duration
      }

      try {
          const apiFunc = window.interactiveStepApi || interactiveStepApi; // Ensure interactiveStepApi is accessible
          if (typeof apiFunc !== 'function') throw new Error("interactiveStepApi function is not available.");
          
          const result = await apiFunc(aggregatorUrl, { 
            conversation_id: `modal_task_${conversationId}_${stepData.id}_${Date.now()}`, 
            agentIdentifierObj: stepData.agentIdentifierObj, 
            role: stepData.role, 
            role_description: stepData.roleDescription, 
            max_tokens: stepData.maxTokens || 8000, 
            temperature: stepData.temperature, 
            workspaces: apiWorkspaces, // Crucial for passing files to /interactive_step
            user_message: userMessageForAgent, 
            last_agent_message: lastAgentMessage, 
            finish_step: false // This must be false for normal interactive steps
          });
          return result.answer || "[Agent provided no answer]";
      } finally {
          if (progressInterval) clearInterval(progressInterval);
          setStepExecutionProgress({ stepId: stepData.id, progress: 100 }); // Mark as complete
      }
  }, [aggregatorUrl, conversationId, internalWorkspaces, initialContext?.mode, dispatchChainAction, chainState.isDryRunMode, showSnackbar]);

  const _writeFilesFromAgentOutput = React.useCallback((agentMsgContent, stepRole) => {
      const parsedBlocks = parseCodeBlocksGeneric(agentMsgContent, true); // Assuming global or imported
      const filesChanged = [];
      if (chainState.isDryRunMode) {
          if(parsedBlocks.length > 0) dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Dry Run: Agent proposed ${parsedBlocks.length} workspace update(s). Would merge.]` } } });
          return filesChanged;
      }
      if (parsedBlocks.length > 0) {
          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Agent proposed ${parsedBlocks.length} workspace update(s). Merging.]` } } });
          setInternalWorkspaces(prevInternalWs => {
              let updatedWs = prevInternalWs.map(ws => deepCopyWorkspaceItem(ws)); // Use deep copy to ensure reactivity
              parsedBlocks.forEach(block => {
                  let targetFileId = (block.title || "untitled").replace(/[<>:"/\\|?*]+/g, '_'); // Use block.title (filename from comment or lang) for ID candidate
                  
                  // Extract general explanation
                  let blockSpecificExplanation = wstmParseExplanationFromAgentResponse(agentMsgContent); 
                  // Try to find a more specific explanation for this file from the agent's response
                  const specificExplanationRegex = new RegExp(`EXPLANATION for ${targetFileId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}:\\s*\\n([\\s\\S]*?)(?:\\nEND_EXPLANATION|\\nEXPLANATION for|\\n\`\`\`|\\n## |$)`, "im");
                  const specificMatch = agentMsgContent.match(specificExplanationRegex);
                  if (specificMatch?.[1]) blockSpecificExplanation = specificMatch[1].trim();
                  else if (!blockSpecificExplanation) { 
                    blockSpecificExplanation = "[No specific explanation by agent]";
                    dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Warning] Agent changed '${targetFileId}', but no explanation provided.`, status: "warning" } } });
                  }

                  const textSelectionContextFile = updatedWs.find(ws => ws.type === 'text_selection_context');
                  if (initialContext?.type === 'text_selection' && textSelectionContextFile) { // If it's an update to the original text selection context
                      // Update the content of the special text selection file in the internal workspace
                      if (textSelectionContextFile.content !== block.content) {
                          textSelectionContextFile.content = block.content;
                          textSelectionContextFile.versionHistory = [...(textSelectionContextFile.versionHistory || []), { content: block.content, timestamp: Date.now() }].slice(-20); // Keep history to last 20
                          textSelectionContextFile.lastExplanation = blockSpecificExplanation;
                          // filesChanged reports the actual content and explanation, for parent to use in applying changes
                          filesChanged.push({ id: textSelectionContextFile.id, title: textSelectionContextFile.title, type: textSelectionContextFile.type, lang: textSelectionContextFile.lang, newContent: block.content, oldContent: originalFileContentsMap[textSelectionContextFile.id] || "", explanation: blockSpecificExplanation, isSelectionUpdate: true });
                      }
                  } else { // Handle regular files (non-selection context files)
                      const fileIndex = updatedWs.findIndex(ws => ws.id === targetFileId);
                      if (fileIndex !== -1) { // Existing file found by ID
                          if (updatedWs[fileIndex].content !== block.content) {
                              updatedWs[fileIndex].content = block.content;
                              updatedWs[fileIndex].versionHistory = [...(updatedWs[fileIndex].versionHistory || []), { content: block.content, timestamp: Date.now() }].slice(-20);
                              updatedWs[fileIndex].lastExplanation = blockSpecificExplanation;
                              filesChanged.push({ id: updatedWs[fileIndex].id, title: updatedWs[fileIndex].title, type: updatedWs[fileIndex].type, lang: updatedWs[fileIndex].lang, newContent: block.content, oldContent: originalFileContentsMap[updatedWs[fileIndex].id] || "", explanation: blockSpecificExplanation });
                          }
                      } else { // New file created by agent
                          let newIdCandidate = targetFileId;
                          let suffixCounter = 1;
                          // Ensure new file ID is unique among *all* internal workspaces
                          while (updatedWs.some(ws => ws.id === newIdCandidate)) {
                            newIdCandidate = `${targetFileId}_${suffixCounter++}`;
                          }
                          if (newIdCandidate !== targetFileId) {
                              dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Notice] Filename '${targetFileId}' (from agent output) resulted in new file ID '${newIdCandidate}' to avoid collision.`, status: "info" } } });
                          }
                          targetFileId = newIdCandidate; // Update targetFileId to the unique one

                          // Extract basename and parentId for structured data
                          const newTitle = targetFileId.includes('/') ? targetFileId.substring(targetFileId.lastIndexOf('/') + 1) : targetFileId;
                          const newParentId = targetFileId.includes('/') ? targetFileId.substring(0, targetFileId.lastIndexOf('/')) : null;
                          const newFileEntry = {
                              id: targetFileId, title: newTitle,
                              type: determineTypeFromFilename(newTitle, block.lang), // Assuming global
                              lang: block.lang || (newTitle.includes('.') ? newTitle.split('.').pop() : ""),
                              content: block.content, parentId: newParentId,
                              versionHistory: [{ content: block.content, timestamp: Date.now() }],
                              lastExplanation: blockSpecificExplanation
                          };
                          updatedWs.push(newFileEntry);
                          filesChanged.push({ ...newFileEntry, isNew: true, newContent: block.content, oldContent: "", explanation: blockSpecificExplanation }); // Include newContent for apply changes
                      }
                  }
              });
              return updatedWs;
          });
      }
      return filesChanged;
  }, [initialContext?.type, dispatchChainAction, chainState.isDryRunMode, originalFileContentsMap]); // Added originalFileContentsMap to deps

  const _runCommandsFromAgentOutput = React.useCallback(async (agentMsgContent) => {
      const commandsToRun = []; const termCmdPattern = /TERMINAL_CMD:\s*(.+)/g; let match;
      while ((match = termCmdPattern.exec(agentMsgContent)) !== null) commandsToRun.push(match[1].trim());
      const shellBlockPattern = /```(?:bash|shell|sh)\s*\n([\s\\S]*?)\n```/g; // Also parse bash/shell blocks
      while ((match = shellBlockPattern.exec(agentMsgContent)) !== null) {
          const codeBlock = match[1].trim();
          for (const line of codeBlock.split(/\r?\n/)) {
              const cmdLine = line.trim();
              if (cmdLine && !cmdLine.startsWith("#")) commandsToRun.push(cmdLine);
          }
      }

      if (commandsToRun.length === 0) return;

      if (chainState.isDryRunMode || !autoExecuteTermCmds) {
          const prefix = chainState.isDryRunMode ? "[Dry Run: Would execute]" : "[Auto-execute OFF: Would execute]";
          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `${prefix} ${commandsToRun.length} terminal command(s): ${commandsToRun.join('; ')}` } } });
          if (!autoExecuteTermCmds && !chainState.isDryRunMode) showSnackbar("Terminal commands logged, auto-execution is off.", "info");
          return;
      }

      const runCmdFunc = window.runTerminalCommand || runTerminalCommand; // Assuming global or imported
      if (typeof runCmdFunc === 'function') {
          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Agent proposed ${commandsToRun.length} terminal command(s). Executing.]` } } });
          for (const cmd of commandsToRun) {
              try {
                  const result = await runCmdFunc(aggregatorUrl, cmd, conversationId);
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[CMD: "${cmd.substring(0, 50)}..."] STDOUT: ${result.stdout.substring(0, 100)}... STDERR: ${result.stderr.substring(0, 100)}... RC: ${result.code}` } } });
              } catch (err) {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[CMD Error: "${cmd.substring(0, 50)}..."] ${err.message}`, status: "error" } } });
                  showSnackbar(`Terminal command failed: ${err.message}`, "error");
              }
          }
      } else {
          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: "[TERMINAL_CMD detected but runTerminalCommand not available.]", status: "warning" } } });
      }
  }, [aggregatorUrl, conversationId, showSnackbar, dispatchChainAction, chainState.isDryRunMode, autoExecuteTermCmds]);

  const _simulateAgentAssessment = React.useCallback((agentResponse, agentRole) => {
      const assessment = { status: "LOOKS_ACCEPTABLE", feedback: [], needsProactiveRetry: false, needsUserClarification: false, clarificationPrompt: "" };
      const responseLower = agentResponse.toLowerCase();
      // Heuristic checks
      if (agentResponse.endsWith("?") || /(could you please clarify|what about|how should i proceed|i need more information)/i.test(responseLower)) { assessment.status = "NEEDS_CLARIFICATION"; assessment.feedback.push("Agent seems to be asking a question."); assessment.needsUserClarification = true; assessment.clarificationPrompt = `Agent "${agentRole}" asked: ${agentResponse}`; }
      if (/(as an ai language model|i cannot fulfill|i am unable to|\/\/ todo|\# todo|\[insert your code here\])/i.test(responseLower)) { assessment.status = "POTENTIAL_QUALITY_ISSUE"; assessment.feedback.push("Response contains refusal or placeholder."); assessment.needsProactiveRetry = true; }
      if (agentRole.toLowerCase().includes("developer") && !parseCodeBlocksGeneric(agentResponse).length && assessment.status === "LOOKS_ACCEPTABLE") { assessment.status = "POTENTIAL_QUALITY_ISSUE"; assessment.feedback.push("Developer role did not produce code."); assessment.needsProactiveRetry = true; }
      if (agentRole.toLowerCase().includes("tester") && !/(pass|fail|passed|failed)/i.test(responseLower) && assessment.status === "LOOKS_ACCEPTABLE") { assessment.status = "POTENTIAL_QUALITY_ISSUE"; assessment.feedback.push("Tester role unclear on pass/fail."); }
      return assessment;
  }, []);

  const _processAgentOutput = React.useCallback(async (agentMsgContent, stepData) => {
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: stepData.role, content: agentMsgContent } } });
      const assessmentResult = _simulateAgentAssessment(agentMsgContent, stepData.role);
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Assessment for ${stepData.role}: ${assessmentResult.status}, Feedback: ${assessmentResult.feedback.join(', ')}]` } } });
      if (chainState.isDryRunMode) { return { shouldProactivelyRetry: false, needsUserClarification: false, filesChangedByAgent: [] }; }

      await _runCommandsFromAgentOutput(agentMsgContent);
      const filesChangedByAgent = _writeFilesFromAgentOutput(agentMsgContent, stepData.role);

      let shouldProactivelyRetry = false;
      if (initialContext?.mode !== 'explain_this' && assessmentResult.needsUserClarification) {
           return { shouldProactivelyRetry: false, needsUserClarification: true, clarificationPrompt: assessmentResult.clarificationPrompt, filesChangedByAgent };
      }
      if (enableProactiveRetries && initialContext?.mode !== 'explain_this' && assessmentResult.needsProactiveRetry) {
          if (stepData.runtimeData.selfCorrectionRetries < WSTM_MAX_SELF_CORRECTION_RETRIES) {
              setMiniChainSteps(prevSteps => prevSteps.map(s => s.id === stepData.id ? { ...s, runtimeData: { ...s.runtimeData, selfCorrectionRetries: s.runtimeData.selfCorrectionRetries + 1 } } : s));
              shouldProactivelyRetry = true;
              dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Agent response flagged: ${assessmentResult.status}. Proactive retry ${stepData.runtimeData.selfCorrectionRetries + 1}/${WSTM_MAX_SELF_CORRECTION_RETRIES} for step.]` } } });
          } else {
              dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Agent response flagged: ${assessmentResult.status}. Max proactive retries reached. Proceeding.]`, status: "warning" } } });
          }
      }
      return { shouldProactivelyRetry, needsUserClarification: false, filesChangedByAgent };
  }, [_runCommandsFromAgentOutput, _writeFilesFromAgentOutput, _simulateAgentAssessment, initialContext?.mode, dispatchChainAction, chainState.isDryRunMode, enableProactiveRetries]);

  const _summarizeAndAdvance = React.useCallback(async (agentMsgContent, userPromptForStep, stepData) => {
      let contextForNextStep;
      const currentStepInteractionLog = `Task Context:\n${userPromptForStep}\n\nAgent ${stepData.role} responded:\n${agentMsgContent}`;
      const summarizerFunc = window.summarizeConversation || summarizeConversation; // Assuming global or imported

      if (chainState.isDryRunMode) {
          contextForNextStep = `[Dry Run: Context for next step would be based on '${contextStrategy}' and output from ${stepData.role}]`;
      } else if (typeof summarizerFunc !== 'function') {
          showSnackbar("Summarization function not available, using raw output.", "warning");
          contextForNextStep = `Output from (${stepData.role}):\n${agentMsgContent}`;
      } else if (contextStrategy === WSTM_CONTEXT_STRATEGY.FULL_SUMMARY) {
          // summarizeConversation internally uses sendMessageToAgent, which is good.
          contextForNextStep = await summarizerFunc(aggregatorUrl, currentStepInteractionLog, stepData.agentIdentifierObj, `modal_summary_${conversationId}_${stepData.id}`, null, activeAgents);
      } else if (contextStrategy === WSTM_CONTEXT_STRATEGY.LAST_STEP_OUTPUT_ONLY) {
          contextForNextStep = `Output from (${stepData.role}):\n${agentMsgContent}`;
      } else if (contextStrategy === WSTM_CONTEXT_STRATEGY.RAW_LOG_LAST_3) {
          const lastLogs = chainState.miniChainLogs.slice(-3).map(l => `${l.role}: ${l.content}`).join("\n---\n");
          contextForNextStep = `Recent log:\n${lastLogs}\n\nOutput from (${stepData.role}):\n${agentMsgContent}`;
      } else { // Default to full summary if strategy is unrecognized
          contextForNextStep = await summarizerFunc(aggregatorUrl, currentStepInteractionLog, stepData.agentIdentifierObj, `modal_summary_${conversationId}_${stepData.id}`, null, activeAgents);
      }
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.SET_ACCUMULATED_CONTEXT, payload: { context: contextForNextStep } });
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Context for next step (${contextStrategy}): ${contextForNextStep.substring(0, 150)}...]` } } });
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.NEXT_STEP });
  }, [aggregatorUrl, conversationId, activeAgents, contextStrategy, chainState.miniChainLogs, dispatchChainAction, chainState.isDryRunMode, showSnackbar]);

  // Main chain execution useEffect
  React.useEffect(() => {
      let isMounted = true;
      const executeStep = async () => {
          const activeEnabledSteps = miniChainSteps.filter(s => s.isEnabled);
          if (!chainState.isRunning || chainState.isPaused || chainState.currentMiniStepIndex >= activeEnabledSteps.length || !isMounted) {
              // Condition for chain completion
              if (chainState.isRunning && !chainState.isPaused && chainState.currentMiniStepIndex >= activeEnabledSteps.length) {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason: `All Steps Completed${chainState.isDryRunMode ? " (Dry Run)" : ""}` } });
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `--- All Enabled Steps Completed${chainState.isDryRunMode ? " (Dry Run)" : ""} ---` } } });
                  showSnackbar(`Mini-chain finished${chainState.isDryRunMode ? " (Dry Run)" : ""}!`, "success");
                  // If auto-apply is enabled, trigger it here upon successful chain completion
                  if (!chainState.isDryRunMode && !isExplainMode && autoApplyChanges) {
                    // Timeout to ensure state updates (like logs) are rendered before final apply
                    setTimeout(() => prepareChangesAndApply(true), 100); 
                  }
              }
              return;
          }
          let stepData = activeEnabledSteps[chainState.currentMiniStepIndex];
          setStepExecutionProgress({ stepId: stepData.id, progress: 0});
          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `--- Step ${chainState.currentMiniStepIndex + 1}/${activeEnabledSteps.length} (ID: ${stepData.id}): ${stepData.role} ---` } } });

          // Run Condition check
          if (stepData.runConditionType !== WSTM_STEP_RUN_CONDITION_TYPE.NONE && stepData.runConditionValue) {
              let conditionMet = true;
              const lastAgentLog = chainState.miniChainLogs.filter(log => log.role !== "System" && log.role !== "User" && !log.isContextSnapshot).pop();
              const lastAgentOutput = lastAgentLog ? lastAgentLog.content.toLowerCase() : "";
              const conditionValueLower = stepData.runConditionValue.toLowerCase();
              const scratchpad = internalWorkspaces.find(ws => ws.id === WSTM_SCRATCHPAD_FILE_ID);

              switch (stepData.runConditionType) {
                  case WSTM_STEP_RUN_CONDITION_TYPE.PREVIOUS_OUTPUT_CONTAINS: conditionMet = lastAgentOutput.includes(conditionValueLower); break;
                  case WSTM_STEP_RUN_CONDITION_TYPE.PREVIOUS_OUTPUT_DOES_NOT_CONTAIN: conditionMet = !lastAgentOutput.includes(conditionValueLower); break;
                  case WSTM_STEP_RUN_CONDITION_TYPE.FILE_EXISTS: conditionMet = internalWorkspaces.some(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID && ws.id.toLowerCase() === conditionValueLower || ws.title.toLowerCase() === conditionValueLower); break; // Check both ID and Title
                  case WSTM_STEP_RUN_CONDITION_TYPE.FILE_NOT_EXISTS: conditionMet = !internalWorkspaces.some(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID && ws.id.toLowerCase() === conditionValueLower || ws.title.toLowerCase() === conditionValueLower); break; // Check both ID and Title
                  case WSTM_STEP_RUN_CONDITION_TYPE.SCRATCHPAD_CONTAINS: conditionMet = scratchpad ? scratchpad.content.toLowerCase().includes(conditionValueLower) : false; break;
                  default: break;
              }

              if (!conditionMet) {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[${chainState.isDryRunMode ? "Dry Run: Would skip" : "Skipping"} Step: Condition '${stepData.runConditionType}: ${stepData.runConditionValue}' not met.]`, status: "info" } } });
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.NEXT_STEP });
                  if (isMounted) setTimeout(executeStep, chainState.isDryRunMode ? 100 : 0);
                  return;
              }
          }

          try {
              const userPromptForStep = chainState.accumulatedMiniContext;
              const lastAgentMessageInHistory = chainState.miniChainLogs.filter(l => l.role === stepData.role && !l.isContextSnapshot).pop()?.content || "";
              const agentMsgContent = await _callAgentForCurrentStep(stepData, userPromptForStep, lastAgentMessageInHistory);

              if (initialContext?.mode === 'explain_this') {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: stepData.role, content: agentMsgContent } } });
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason: "ExplanationComplete" } });
                  return;
              }

              const { shouldProactivelyRetry, needsUserClarification, clarificationPrompt, filesChangedByAgent } = await _processAgentOutput(agentMsgContent, stepData);

              if (needsUserClarification && stepData.onErrorAction === WSTM_STEP_ON_ERROR_ACTION.PROMPT_USER && !chainState.isDryRunMode) {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.SET_USER_INPUT_MODE, payload: { isAwaiting: true, prompt: clarificationPrompt || `Agent "${stepData.role}" needs clarification. How should it proceed? (e.g., provide a rephrased task for the agent)`, callback: (userInput) => {
                      const supplementedAgentOutput = `${agentMsgContent}\n\n--- USER CLARIFICATION ---\n${userInput}\n--- END USER CLARIFICATION ---`;
                      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "User (Clarification)", content: userInput }}});
                      // If the user clarifies, we treat it as part of the last agent's response for the next summary, and re-run the same step
                      if(isMounted) _summarizeAndAdvance(supplementedAgentOutput, userPromptForStep, stepData).then(() => { if(isMounted) setTimeout(executeStep, 0); });
                  }}});
                  return; // Pause chain, await user input
              }

              if (shouldProactivelyRetry) {
                  showSnackbar(`Agent response suggests potential issues. Retrying step ${stepData.runtimeData.selfCorrectionRetries}/${WSTM_MAX_SELF_CORRECTION_RETRIES}.`, "info");
                  if (isMounted) setTimeout(executeStep, chainState.isDryRunMode ? 100 : 0); // Re-execute current step
              } else {
                  await _summarizeAndAdvance(agentMsgContent, userPromptForStep, stepData);
                  if (isMounted) setTimeout(executeStep, chainState.isDryRunMode ? 100 : 0); // Advance to next step
              }
          } catch (err) {
               if (chainState.isDryRunMode) {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Dry Run: Would encounter error for ${stepData.role}: ${err.message}. Halting.]`, status: "error" } } });
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason: "DryRunError" } });
                  return;
               }
              console.error(`Error in Step ${chainState.currentMiniStepIndex + 1}:`, err);
              let errorDetail = err.message;
              // Attempt to extract more specific error detail from HTTP response if available
              if (err.response?.data?.detail) errorDetail = err.response.data.detail;
              else if (err.message && err.message.includes("Error: ")) errorDetail = err.message.substring(err.message.indexOf("Error: ") + 7);

              const errorMsg = `[Error (${stepData.role}): ${errorDetail}.]`;
              dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: errorMsg, status: "error" } } });
              setMiniChainSteps(prev => prev.map(s => s.id === stepData.id ? { ...s, lastError: errorDetail } : s));
              showSnackbar(`Mini-chain error: ${errorDetail}`, "error");

              if (stepData.onErrorAction === WSTM_STEP_ON_ERROR_ACTION.PROMPT_USER) {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.SET_USER_INPUT_MODE, payload: { isAwaiting: true, prompt: `Step "${stepData.role}" failed with error: ${errorDetail}. How to proceed? (e.g., provide corrected input, or type 'SKIP' or 'STOP')`, callback: (userInput) => {
                      if (userInput.toUpperCase() === 'SKIP') {
                          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Skipping step ${stepData.role} based on user input.]`, status: "info" } } });
                          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.NEXT_STEP });
                          if (isMounted) setTimeout(executeStep, 0);
                      } else if (userInput.toUpperCase() === 'STOP') {
                          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason: "UserStopOnError" } });
                      } else {
                          const modifiedContext = `${chainState.accumulatedMiniContext}\n\n--- USER PROVIDED CORRECTION/INPUT FOR FAILED STEP ---\n${userInput}\n--- END USER CORRECTION ---`;
                          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.SET_ACCUMULATED_CONTEXT, payload: { context: modifiedContext } });
                          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "User (Error Override)", content: userInput }}});
                          setMiniChainSteps(prev => prev.map(s => s.id === stepData.id ? {...s, lastError: null, runtimeData: {...s.runtimeData, errorActionRetries: (s.runtimeData.errorActionRetries || 0) + 1 } } : s)); // Clear error, increment retry
                          if (isMounted) setTimeout(executeStep, 0); // Re-execute current step
                      }
                  }}});
                  return;
              } else if (stepData.onErrorAction === WSTM_STEP_ON_ERROR_ACTION.SKIP_AND_CONTINUE) {
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Skipping step due to error as per configuration.]`, status: "warning" } } });
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.NEXT_STEP });
                  if (isMounted) setTimeout(executeStep, 0);
              } else if (stepData.onErrorAction === WSTM_STEP_ON_ERROR_ACTION.RETRY_ONCE_THEN_HALT) {
                  if (stepData.runtimeData.errorActionRetries < 1) {
                      setMiniChainSteps(prevSteps => prevSteps.map(s => s.id === stepData.id ? { ...s, runtimeData: { ...s.runtimeData, errorActionRetries: (s.runtimeData.errorActionRetries || 0) + 1 } } : s));
                      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Retrying step 1/1 due to error as per configuration.]`, status: "info" } } });
                      if (isMounted) setTimeout(executeStep, 0); // Re-execute current step
                  } else {
                      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Halting: Max error retries reached for step.]`, status: "error" } } });
                      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason: "ErrorMaxRetries" } });
                  }
              } else { // Default: HALT
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `[Halting chain due to error.]`, status: "error" } } });
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason: "Error" } });
              }
          }
      };
      if (chainState.isRunning && !chainState.isPaused && isMounted) {
          setTimeout(executeStep, chainState.isDryRunMode ? 50 : 0); // Shorter delay for dry run step progression
      }
      return () => { isMounted = false; };
  }, [
    chainState.isRunning, chainState.isPaused, chainState.currentMiniStepIndex, chainState.accumulatedMiniContext,
    chainState.miniChainLogs, miniChainSteps, showSnackbar, initialContext?.mode, _callAgentForCurrentStep,
    _processAgentOutput, _summarizeAndAdvance, dispatchChainAction, internalWorkspaces, chainState.isDryRunMode,
    enableProactiveRetries, isExplainMode, autoApplyChanges, prepareChangesAndApply
  ]);

  const addMiniStep = React.useCallback((stepToDuplicate = null) => {
      const newStepBase = stepToDuplicate ? { ...deepCopyWorkspaceItem(stepToDuplicate), id: wstmGenerateUniqueId("step_"), role: `${stepToDuplicate.role} (Copy)`, runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null }, lastError: null }
          : { id: wstmGenerateUniqueId("step_"), agentIdentifierObj: suggestAgentForRole("New Task Step", activeAgents), role: "New Task Step", roleDescription: "Define instructions. Ask for EXPLANATIONs.", maxTokens: 8000, temperature: 0.5, isEnabled: true, ...defaultStepData };
      setMiniChainSteps(prev => [...prev, newStepBase]); showSnackbar("New step added.", "info");
  }, [defaultStepData, suggestAgentForRole, activeAgents, showSnackbar]);

  const removeMiniStep = React.useCallback((stepId) => {
    setMiniChainSteps(prev => prev.filter(s => s.id !== stepId));
    showSnackbar("Step removed.", "info");
  }, [showSnackbar]);

  const handleMiniStepChange = React.useCallback((stepId, field, value) => {
      setMiniChainSteps(prev => prev.map(step => {
          if (step.id === stepId) {
              const updatedStep = { ...step, [field]: value };
              if (field === "maxTokens") updatedStep[field] = (!value || isNaN(parseInt(value, 10)) || parseInt(value, 10) <= 0) ? 8000 : parseInt(value, 10);
              else if (field === "temperature") updatedStep[field] = (isNaN(parseFloat(value)) || parseFloat(value) < 0 || parseFloat(value) > 2) ? null : parseFloat(value);
              return updatedStep;
          }
          return step;
      }));
  }, []);

  const moveMiniStep = React.useCallback((idx, direction) => {
      if ((direction === 'up' && idx === 0) || (direction === 'down' && idx === miniChainSteps.length - 1)) return;
      setMiniChainSteps(prevSteps => { const newSteps = [...prevSteps]; const item = newSteps.splice(idx, 1)[0]; newSteps.splice(idx + (direction === 'down' ? 1 : -1), 0, item); return newSteps; });
      showSnackbar("Step reordered.", "info");
  }, [miniChainSteps, showSnackbar]);

  const handleToggleStepEnabled = React.useCallback((stepId) => setMiniChainSteps(prev => prev.map(step => step.id === stepId ? { ...step, isEnabled: !step.isEnabled } : step)), []);

  const handleClearCachedState = React.useCallback(() => {
      const storageKey = getLocalStorageKey();
      if (storageKey) {
          localStorage.removeItem(storageKey);
          showSnackbar("Cleared cached state for this context.", "info");
          isInitializedRef.current = null; // Forces re-initialization on next open/render cycle

          // Reset all pertinent states to their initial/default values
          setOverallTaskPrompt("");
          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.RESET_CHAIN_STATE, payload: { overallTaskPrompt: "" } });
          setChangesForDiff([]);
          setOriginalFileContentsMap({});
          setInternalWorkspaces([]); // Clear workspaces
          ensureScratchpadFile();    // Then ensure scratchpad is added back
          setContextStrategy(WSTM_CONTEXT_STRATEGY.LAST_STEP_OUTPUT_ONLY);
          setPlanText("");
          setIsGeneratingPlan(false);
          setIsDecomposingTask(false);
          setEnableProactiveRetries(false);
          setAutoExecuteTermCmds(false);
          setAutoScrollLogs(false);
          setAutoApplyChanges(false); // Reset auto-apply

          // Reset miniChainSteps to appropriate default steps
          const newDefaultSteps = (initialContext?.mode === 'explain_this' ? explainThisDefaultSteps : generalDefaultSteps).map(s => ({
                ...s, // Includes defaults from generalDefaultSteps like defaultStepData
                id: wstmGenerateUniqueId("step_"), // Generate new ID
                runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null },
                agentIdentifierObj: s.agentIdentifierObj || suggestAgentForRole(s.role, activeAgents) // Re-evaluate agent assignment
            }));
          setMiniChainSteps(newDefaultSteps);
      } else {
          showSnackbar("No cached state found for this context.", "info");
      }
  }, [
      getLocalStorageKey, showSnackbar, initialContext?.mode, explainThisDefaultSteps,
      generalDefaultSteps, suggestAgentForRole, activeAgents, ensureScratchpadFile
  ]);

  // Unified function to prepare changes and either show diff or auto-apply
  const prepareChangesAndApply = React.useCallback((isAutoApply) => {
    if (chainState.isRunning) { showSnackbar("Mini-chain running. Stop it first.", "warning"); return; }
    if (chainState.isDryRunMode) { showSnackbar(`Cannot ${isAutoApply ? 'auto-apply' : 'review changes'} in Dry Run mode.`, "info"); return; }

    const currentChanges = [];
    internalWorkspaces.filter(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID).forEach(modalWs => {
        const originalContent = originalFileContentsMap[modalWs.id] || (initialContext?.type === 'text_selection' && modalWs.type === 'text_selection_context' ? initialContext.content : null);
        const isNewFile = !originalFileContentsMap[modalWs.id] && modalWs.type !== 'text_selection_context';
        const isSelectionUpdate = initialContext?.type === 'text_selection' && modalWs.type === 'text_selection_context';
        const explanation = modalWs.lastExplanation || "No specific explanation for this change.";
        // Only include if content actually changed or it's a new, non-empty file
        if (isNewFile && modalWs.content.trim() !== "") currentChanges.push({ fileId: modalWs.id, title: modalWs.title, oldContent: "", newContent: modalWs.content, explanation, isNew: true, type: modalWs.type, lang: modalWs.lang });
        else if (isSelectionUpdate && originalContent !== modalWs.content) currentChanges.push({ fileId: modalWs.id, title: modalWs.title, oldContent: originalContent, newContent: modalWs.content, explanation, isSelectionUpdate: true, type: modalWs.type, lang: modalWs.lang });
        else if (originalContent !== null && originalContent !== modalWs.content) currentChanges.push({ fileId: modalWs.id, title: modalWs.title, oldContent: originalContent, newContent: modalWs.content, explanation, type: modalWs.type, lang: modalWs.lang });
    });

    if (currentChanges.length === 0) { showSnackbar(`Mini-chain made no changes to ${isAutoApply ? 'auto-apply' : 'review'}.`, "info"); return; }

    // If auto-applying, all changes are accepted. Otherwise, they are ready for manual review (default accepted).
    const changesToProcess = currentChanges.map(c => ({ ...c, accepted: true }));
    setChangesForDiff(changesToProcess);

    if (isAutoApply) {
        // Directly confirm application, bypassing diff review dialog
        handleConfirmApplyChangesFromDiff(changesToProcess); // Pass auto-accepted changes
    } else {
        // Show the diff review dialog for manual acceptance
        setShowDiffReview(true);
    }
  }, [chainState.isRunning, chainState.isDryRunMode, internalWorkspaces, originalFileContentsMap, initialContext, showSnackbar]);

  // Modified to accept an optional 'autoAppliedChanges' argument for direct application
  const handleConfirmApplyChangesFromDiff = React.useCallback((autoAppliedChanges = null) => {
      const changesToApply = autoAppliedChanges || changesForDiff.filter(change => change.accepted);

      if (onApplyChanges && changesToApply.length > 0) {
          if (initialContext?.type === 'text_selection' && internalWorkspaces.find(ws => ws.type === 'text_selection_context')) {
              // Handle text selection update specifically
              const acceptedSelectionChange = changesToApply.find(c => c.isSelectionUpdate);
              if (acceptedSelectionChange) {
                // For text selections, onApplyChanges expects the original full content and line numbers,
                // plus the new partial content.
                onApplyChanges([{ 
                  id: acceptedSelectionChange.fileId, 
                  newContent: acceptedSelectionChange.newContent, 
                  isPartialUpdate: true, 
                  originalFullContent: initialContext.originalFullContent, 
                  lineStart: initialContext.lineStart, 
                  lineEnd: initialContext.lineEnd, 
                  explanation: acceptedSelectionChange.explanation 
                }]);
              }
          } else {
              // Handle general file changes (id, content, isNew, title, explanation, type, lang)
              onApplyChanges(changesToApply.map(change => ({ 
                id: change.fileId, 
                content: change.newContent, 
                isNew: change.isNew || false, 
                title: change.title, 
                explanation: change.explanation, 
                type: change.type, 
                lang: change.lang 
              })));
          }
          showSnackbar(`Applied ${changesToApply.length} change(s)${autoAppliedChanges ? ' automatically' : ''}.`, "success");
          setFeedbackData(prev => ({ ...prev, changesAccepted: true }));
      } else {
          showSnackbar(changesToApply.length === 0 && (autoAppliedChanges || changesForDiff).length > 0 ? "No changes selected." : "No changes to apply.", "info");
          setFeedbackData(prev => ({ ...prev, changesAccepted: false }));
      }
      setShowDiffReview(false); // Always close diff review if it was open
      setShowFeedbackDialog(true); // Proceed to feedback dialog
  }, [changesForDiff, onApplyChanges, initialContext, internalWorkspaces, showSnackbar]);


  const handleCancelDiffReview = React.useCallback(() => {
    setShowDiffReview(false);
    showSnackbar("Changes discarded.", "info");
    setFeedbackData(prev => ({ ...prev, changesAccepted: false })); // Mark changes as not accepted for feedback
    setShowFeedbackDialog(true); // Proceed to feedback dialog
  }, [showSnackbar]);

  const handleAddInternalFile = React.useCallback(() => {
      const fileName = prompt("New file name (e.g., script.py):"); if (!fileName?.trim()) return;
      const newFile = { id: wstmGenerateUniqueId("internal_") + fileName.replace(/[^a-zA-Z0-9_.-]/g, '_'), title: fileName, type: determineTypeFromFilename(fileName), content: `// New file: ${fileName}\n`, lang: fileName.split('.').pop() || "", parentId: null, versionHistory: [{ content: `// New file: ${fileName}\n`, timestamp: Date.now() }], lastExplanation: "Manually added file." };
      setInternalWorkspaces(prev => [...prev, newFile]); showSnackbar(`Added "${fileName}" to internal workspace.`, "info");
  }, [showSnackbar]);

    const handleDeleteInternalFile = React.useCallback((fileIdToDelete) => {
      if (!fileIdToDelete || fileIdToDelete === WSTM_SCRATCHPAD_FILE_ID) {
        showSnackbar(fileIdToDelete === WSTM_SCRATCHPAD_FILE_ID ? "Cannot delete Scratchpad." : "No internal file selected for deletion.", "warning");
        return;
      }
      if (initialContext?.selectedFiles?.some(f => f.id === fileIdToDelete)) {
        // Confirm if it was one of the initially selected files (part of the problem's context)
        if (!window.confirm(`"${internalWorkspaces.find(ws => ws.id === fileIdToDelete)?.title || fileIdToDelete}" was part of the initial problem context. Deleting it will prevent diffing against its original state. Continue?`)) {
          return;
        }
      }
      const fileName = internalWorkspaces.find(ws => ws.id === fileIdToDelete)?.title || fileIdToDelete;
      setInternalWorkspaces(prev => prev.filter(ws => ws.id !== fileIdToDelete));
      showSnackbar(`Removed "${fileName}" from internal workspace.`, "info");
    }, [initialContext?.selectedFiles, internalWorkspaces, showSnackbar]);


  const onInternalWorkspaceItemChange = React.useCallback((fileId, newContent, isRevert = false) => {
      setInternalWorkspaces(prevWs => prevWs.map(ws => {
          if (ws.id === fileId) {
              const newVersionHistory = isRevert ?
                  [...(ws.versionHistory || []), { content: newContent, timestamp: Date.now(), note: "Reverted to earlier version" }] :
                  [...(ws.versionHistory || []), { content: newContent, timestamp: Date.now() }];
              return { ...ws, content: newContent, versionHistory: newVersionHistory.slice(-20) }; // Keep history to last 20 entries
          }
          return ws;
      }));
  }, []);

  const handleRenameInternalFile = React.useCallback((fileId, newName) => {
      if (fileId === WSTM_SCRATCHPAD_FILE_ID) { showSnackbar("Cannot rename Scratchpad.", "warning"); return; }
      setInternalWorkspaces(prevWs => prevWs.map(ws => ws.id === fileId ? { ...ws, title: newName, type: determineTypeFromFilename(newName, ws.lang) } : ws));
      showSnackbar(`File renamed to "${newName}".`, "info");
  }, [showSnackbar]);

  const handleDuplicateInternalFile = React.useCallback((fileId) => {
      const fileToDuplicate = internalWorkspaces.find(ws => ws.id === fileId);
      if (!fileToDuplicate) return;
      const newFile = { ...deepCopyWorkspaceItem(fileToDuplicate), id: wstmGenerateUniqueId("internal_dup_") + fileToDuplicate.title.replace(/[^a-zA-Z0-9_.-]/g, '_'), title: `${fileToDuplicate.title} (copy)`, versionHistory: [{ content: fileToDuplicate.content, timestamp: Date.now() }] };
      setInternalWorkspaces(prev => [...prev, newFile]);
      showSnackbar(`"${fileToDuplicate.title}" duplicated.`, "info");
  }, [internalWorkspaces, showSnackbar]);


  const handleSaveChainTemplate = React.useCallback(() => {
      const name = prompt("Template name:"); if (!name?.trim()) { showSnackbar("Template name cannot be empty.", "warning"); return; }
      if (chainTemplates.some(t => t.name === name.trim())) if (!window.confirm(`Template "${name.trim()}" exists. Overwrite?`)) return;
      const newTemplate = { name: name.trim(), overallTaskPrompt, steps: miniChainSteps.map(s => ({ agentIdentifierObj: s.agentIdentifierObj, role: s.role, roleDescription: s.roleDescription, maxTokens: s.maxTokens, temperature: s.temperature, isEnabled: s.isEnabled, runConditionType: s.runConditionType, runConditionValue: s.runConditionValue, onErrorAction: s.onErrorAction })) };
      setChainTemplates(prev => { const existingIndex = prev.findIndex(t => t.name === newTemplate.name); if (existingIndex > -1) { const updated = [...prev]; updated[existingIndex] = newTemplate; return updated; } return [...prev, newTemplate]; });
      showSnackbar(`Template "${name.trim()}" saved.`, "success");
  }, [chainTemplates, overallTaskPrompt, miniChainSteps, showSnackbar]);

  const handleLoadChainTemplate = React.useCallback((templateName) => {
      if (!templateName) { showSnackbar("No template name provided to load.", "warning"); return; }
      const template = chainTemplates.find(t => t.name === templateName);
      if (template) { setOverallTaskPrompt(template.overallTaskPrompt || ""); setMiniChainSteps((template.steps || []).map(s => ({ ...defaultStepData, ...s, id: wstmGenerateUniqueId("step_"), lastError: null, agentIdentifierObj: s.agentIdentifierObj || suggestAgentForRole(s.role, activeAgents), runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null } }))); setSelectedChainTemplateName(""); showSnackbar(`Loaded template "${template.name}".`, "success"); }
      else { showSnackbar(`Template "${templateName}" not found.`, "error"); }
  }, [chainTemplates, defaultStepData, suggestAgentForRole, activeAgents, showSnackbar]);

  const handleExportChainTemplate = React.useCallback(() => {
      if (!selectedChainTemplateName.trim()) { showSnackbar("Select a template to export or provide a name to save current as.", "warning"); return; }
      let templateToExport = chainTemplates.find(t => t.name === selectedChainTemplateName.trim());
      if (!templateToExport) {
          if (window.confirm(`Template "${selectedChainTemplateName.trim()}" not found. Save current chain configuration as this template and export?`)) {
              const currentConfigAsTemplate = { name: selectedChainTemplateName.trim(), overallTaskPrompt, steps: miniChainSteps.map(s => ({ agentIdentifierObj: s.agentIdentifierObj, role: s.role, roleDescription: s.roleDescription, maxTokens: s.maxTokens, temperature: s.temperature, isEnabled: s.isEnabled, runConditionType: s.runConditionType, runConditionValue: s.runConditionValue, onErrorAction: s.onErrorAction })) };
              setChainTemplates(prev => { const existingIndex = prev.findIndex(t => t.name === currentConfigAsTemplate.name); if (existingIndex > -1) { const updated = [...prev]; updated[existingIndex] = currentConfigAsTemplate; return updated; } return [...prev, currentConfigAsTemplate]; });
              templateToExport = currentConfigAsTemplate;
              showSnackbar(`Template "${selectedChainTemplateName.trim()}" saved.`, "success");
          } else { return; }
      }
      if (templateToExport) {
          const jsonTemplate = JSON.stringify(templateToExport, null, 2);
          const blob = new Blob([jsonTemplate], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = `${templateToExport.name.replace(/[^a-z0-9]/gi, '_')}_chain_template.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
          showSnackbar(`Template "${templateToExport.name}" exported.`, "info");
      }
  }, [selectedChainTemplateName, chainTemplates, overallTaskPrompt, miniChainSteps, showSnackbar]);

  const handleImportChainTemplate = React.useCallback((event) => {
      const file = event.target.files[0];
      if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
              try {
                  const importedTemplate = JSON.parse(e.target.result);
                  if (importedTemplate.name && importedTemplate.steps) {
                      if (chainTemplates.some(t => t.name === importedTemplate.name)) {
                          if (!window.confirm(`Template "${importedTemplate.name}" already exists. Overwrite?`)) { event.target.value = null; return; }
                      }
                      setChainTemplates(prev => { const existingIndex = prev.findIndex(t => t.name === importedTemplate.name); if (existingIndex > -1) { const updated = [...prev]; updated[existingIndex] = importedTemplate; return updated; } return [...prev, importedTemplate]; });
                      handleLoadChainTemplate(importedTemplate.name);
                      showSnackbar(`Template "${importedTemplate.name}" imported successfully.`, "success");
                  } else { showSnackbar("Invalid template file format.", "error"); }
              } catch (err) { showSnackbar(`Error importing template: ${err.message}`, "error"); }
              event.target.value = null; // Clear file input
          };
          reader.readAsText(file);
      }
  }, [chainTemplates, handleLoadChainTemplate, showSnackbar]);


  // handleGeneratePlan: Now uses sendMessageToAgent for a direct query to the agent
  const handleGeneratePlan = React.useCallback(async () => {
      if (!orchestratorForPlan) { showSnackbar("Select Orchestrator for planning.", "warning"); return; }
      if (!overallTaskPrompt.trim()) { showSnackbar("Overall task prompt needed.", "warning"); return; }
      setIsGeneratingPlan(true); setPlanText("Generating plan...");
      
      // Use sendMessageToAgent (which calls the /message endpoint) for this single query
      const apiFunc = window.sendMessageToAgent || sendMessageToAgent; // Ensure sendMessageToAgent is accessible
      if (typeof apiFunc !== 'function') {
        setPlanText("Error: sendMessageToAgent function is not available."); showSnackbar("Planning API not available.", "error"); setIsGeneratingPlan(false); return;
      }

      try {
          // Construct the prompt for the agent
          const planPrompt = `Overall task: "${overallTaskPrompt}"\nDefined steps:\n${miniChainSteps.filter(s => s.isEnabled).map((s, i) => `${i + 1}. ${s.role}: ${s.roleDescription}`).join("\n")}\n\nGenerate a high-level execution plan. Focus on clarity and conciseness for the plan output.`;
          
          // Prepare payload for sendMessageToAgent (simpler payload)
          const payload = {
              agentIdentifierObj: orchestratorForPlan,
              question: planPrompt,
              max_tokens: 2000, // Adjust as needed for plan length
              conversation_id: `modal_plan_${conversationId}_${wstmGenerateUniqueId()}`, // For backend logging traceability
              temperature: 0.5 // Adjust as needed
          };

          const result = await apiFunc(aggregatorUrl, payload); // Call sendMessageToAgent
          
          setPlanText(result.answer || "Agent did not provide a plan."); 
          showSnackbar("Plan generated.", "success");
      } catch (err) { 
          const errorMsg = `Error generating plan: ${err.message}`;
          setPlanText(`Error: ${errorMsg}`); 
          showSnackbar(errorMsg, "error"); 
      } finally { 
          setIsGeneratingPlan(false); 
      }
  }, [orchestratorForPlan, overallTaskPrompt, miniChainSteps, aggregatorUrl, conversationId, showSnackbar]);

  const handleExportLogs = React.useCallback(() => {
      const jsonLogs = JSON.stringify(chainState.miniChainLogs, null, 2); const blob = new Blob([jsonLogs], { type: 'application/json' }); const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `mini_chain_logs_${conversationId}_${Date.now()}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showSnackbar("Logs exported.", "info");
  }, [chainState.miniChainLogs, conversationId, showSnackbar]);

  const handleFeedbackSubmit = React.useCallback(async () => {
      if (feedbackData.rating === 0 && !feedbackData.comments.trim()) { setShowFeedbackDialog(false); onClose(); return; }
      try {
          const feedbackApiFunc = window.storeFeedbackApi || storeFeedbackApi; // Assuming global or imported
          if (typeof feedbackApiFunc === 'function') {
              await feedbackApiFunc(aggregatorUrl, { conversation_id: conversationId, task_id: initialContext.type + "_" + (initialContext.fileId || "multifile"), step_id: "overall_mini_chain_completion", agent_identifier_obj: null, rating: feedbackData.rating, comments: feedbackData.comments, context_snapshot: JSON.stringify({ overallTaskPrompt, initialContextSummary: initialContext.content ? initialContext.content.substring(0, 100) : "files" }), logs_snapshot: JSON.stringify(chainState.miniChainLogs.slice(-5)) });
              showSnackbar("Feedback submitted.", "success");
          } else { showSnackbar("Feedback API not available.", "warning"); console.warn("Feedback API not implemented."); }
      } catch (err) { showSnackbar(`Error submitting feedback: ${err.message}`, "error"); console.error("Error submitting feedback:", err); }
      setShowFeedbackDialog(false); onClose();
  }, [feedbackData, aggregatorUrl, conversationId, initialContext, overallTaskPrompt, chainState.miniChainLogs, showSnackbar, onClose]);

  const handleSkipFeedback = React.useCallback(() => { setShowFeedbackDialog(false); onClose(); }, [onClose]);

  // handleAutoDecomposeTask: Now uses sendMessageToAgent for step suggestion
  const handleAutoDecomposeTask = React.useCallback(async () => {
      // Logic to select the appropriate planner agent for decomposition
      const plannerAgentForDecomposition = suggestAgentForRole("Planner", activeAgents) ||
                                           suggestAgentForRole("Task Decomposer", activeAgents) ||
                                           orchestratorForPlan || // Fallback to what's selected in GEN PLAN UI if more specific not found
                                           (activeAgents && activeAgents.length > 0 ? activeAgents[0] : null); // Ultimate fallback

      if (!plannerAgentForDecomposition) { showSnackbar("No suitable Planner/Decomposer agent found or selected.", "warning"); return; }
      if (!overallTaskPrompt.trim()) { showSnackbar("Overall task prompt is needed.", "warning"); return; }
      setIsDecomposingTask(true);
      
      // Use sendMessageToAgent (which calls the /message endpoint) for this single query
      const apiFunc = window.sendMessageToAgent || sendMessageToAgent; // Ensure sendMessageToAgent is accessible
      if (typeof apiFunc !== 'function') {
        showSnackbar("Decomposition API not available.", "error"); setIsDecomposingTask(false); return;
      }

      // Construct a detailed prompt for decomposition, emphasizing the exact format.
      // Include relevant workspace file names (but not content for sendMessageToAgent)
      const workspaceFilenames = internalWorkspaces.filter(ws => ws.id !== WSTM_SCRATCHPAD_FILE_ID && ws.type !== 'text_selection_context').map(f => f.title).join(', ');
      const decompositionPrompt = `Given the overall task: "${overallTaskPrompt}".
${workspaceFilenames ? `Consider the following files in the workspace: ${workspaceFilenames}.` : ''}
Decompose this into a sequence of distinct agent steps. For each step, strictly output a numbered list using the format:
<NUMBER>. Role Name: Role Description
Do not add any other explanatory text, greetings, or conclusions outside of this numbered list format. If you cannot provide steps, output an empty response.`;

      try {
          // Prepare payload for sendMessageToAgent
          const payload = {
              agentIdentifierObj: plannerAgentForDecomposition,
              question: decompositionPrompt,
              max_tokens: 1500, // Adjust as needed
              conversation_id: `modal_decompose_${conversationId}_${wstmGenerateUniqueId()}`, // For backend logging
              temperature: 0.6 // Adjust as needed
          };

          const result = await apiFunc(aggregatorUrl, payload); // Call sendMessageToAgent
          const suggestedStepsText = result.answer;

          if (suggestedStepsText) {
              const parsedNewSteps = wstmParseSuggestedSteps(suggestedStepsText);
              if (parsedNewSteps.length > 0) {
                  const stepsWithAgent = parsedNewSteps.map(s => ({ 
                      ...defaultStepData, 
                      ...s, 
                      id: wstmGenerateUniqueId("step_"), 
                      agentIdentifierObj: s.agentIdentifierObj || suggestAgentForRole(s.role, activeAgents) || (activeAgents && activeAgents.length > 0 ? activeAgents[0] : null), 
                      runtimeData: { selfCorrectionRetries: 0, errorActionRetries: 0, progress: null } 
                  }));
                  if (window.confirm(`Planner suggested ${stepsWithAgent.length} steps. Replace current steps?`)) { 
                      setMiniChainSteps(stepsWithAgent); 
                      showSnackbar("Task decomposed into steps.", "success"); 
                  } else { 
                      showSnackbar("Suggested steps discarded.", "info"); 
                  }
              } else { 
                  showSnackbar("Planner did not return valid steps. Check modal logs for raw output.", "warning"); 
                  dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `Planner's decomposition output (no steps parsed):\n${suggestedStepsText}` } } }); 
              }
          } else { 
              showSnackbar("Planner provided no decomposition.", "warning"); 
          }
      } catch (err) { 
          const errorMsg = `Error decomposing task: ${err.message}`;
          showSnackbar(errorMsg, "error"); 
          dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: `Error during task decomposition: ${errorMsg}` } } }); 
      } finally { 
          setIsDecomposingTask(false); 
      }
  }, [
    activeAgents, overallTaskPrompt, aggregatorUrl, conversationId, internalWorkspaces,
    defaultStepData, showSnackbar, dispatchChainAction, suggestAgentForRole, orchestratorForPlan
  ]);


  const isExplainMode = initialContext?.mode === 'explain_this';
  const disableChainControls = chainState.isRunning || isDecomposingTask || chainState.isDryRunMode;
  const disableApplyButtons = chainState.isRunning || isExplainMode || isDecomposingTask || chainState.isDryRunMode; // Auto-apply button also disabled here.
  const activeEnabledSteps = React.useMemo(() => miniChainSteps.filter(s => s.isEnabled), [miniChainSteps]);

  const currentExecutingStepObject = React.useMemo(() => {
      return chainState.isRunning && chainState.currentMiniStepIndex < activeEnabledSteps.length ? activeEnabledSteps[chainState.currentMiniStepIndex] : null;
  }, [chainState.isRunning, chainState.currentMiniStepIndex, activeEnabledSteps]);

  const suggestedAgentsForCurrentStepUI = React.useMemo(() => {
      // Suggest agents for currently active step if available, otherwise for a generic "New Task Step"
      const currentRoleDesc = currentExecutingStepObject ? currentExecutingStepObject.roleDescription : "New Task Step";
      return wstmGetSuggestedAgents(overallTaskPrompt, currentRoleDesc, activeAgents);
  }, [currentExecutingStepObject, overallTaskPrompt, activeAgents]);

  const currentStepExecutionProgress = React.useMemo(() => {
      return currentExecutingStepObject && stepExecutionProgress?.stepId === currentExecutingStepObject.id ? stepExecutionProgress.progress : 0;
  }, [currentExecutingStepObject, stepExecutionProgress]);

  const handleUserInputSubmit = React.useCallback((userInput) => {
      if (chainState.userInputCallback) { chainState.userInputCallback(userInput); }
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.SET_USER_INPUT_MODE, payload: { isAwaiting: false, prompt: "", callback: null } });
  }, [chainState.userInputCallback]);

  const handleUserInputCancel = React.useCallback(() => {
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.ADD_LOG, payload: { logEntry: { role: "System", content: "[User cancelled input prompt. Chain stopped.]", status: "warning" }}});
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.STOP, payload: { reason: "UserInputCancelled" } });
      dispatchChainAction({ type: WSTM_CHAIN_ACTION_TYPES.SET_USER_INPUT_MODE, payload: { isAwaiting: false, prompt: "", callback: null } });
  }, []);

  const dragItem = React.useRef(null);
  const dragOverItem = React.useRef(null);

  const handleSortSteps = React.useCallback(() => {
      if (dragItem.current === null || dragOverItem.current === null || dragItem.current === dragOverItem.current) return;
      setMiniChainSteps(prevSteps => {
          const _steps = [...prevSteps];
          const draggedItemContent = _steps.splice(dragItem.current, 1)[0];
          _steps.splice(dragOverItem.current, 0, draggedItemContent);
          return _steps;
      });
      dragItem.current = null;
      dragOverItem.current = null;
      showSnackbar("Steps reordered.", "info");
  }, [showSnackbar]);

  // Stable IDs for labels
  const contextStrategyLabelId = "wstm-context-strategy-label";
  const loadTemplateLabelId = "wstm-load-template-label";
  const orchestratorForPlanLabelId = "wstm-orchestrator-plan-label";


  return (
      <React.Fragment>
          <Dialog open={open} onClose={() => { if (!chainState.isRunning && !isDecomposingTask) onClose(); else showSnackbar("Cannot close: task running.", "warning"); }} maxWidth="xl" fullWidth scroll="paper" PaperProps={{ sx: { height: '95vh', display: 'flex', flexDirection: 'column' } }}>
              <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', bgcolor: isDarkMode ? theme.palette.background.level1 : theme.palette.grey[100], borderBottom: `1px solid ${theme.palette.divider}`, flexShrink: 0, p: '12px 16px' }}>
                  <Typography className={isDarkMode ? 'heading-glow' : ''} sx={{typography: 'h6'}}>Contextual Mini-Chain Task Editor {isExplainMode ? "(Explain Mode)" : ""} {chainState.isDryRunMode ? "(Dry Run Mode)" : ""}</Typography>
                  <Tooltip title="Close Task Editor">
                    <span>
                        <IconButton onClick={() => { if (!chainState.isRunning && !isDecomposingTask) onClose(); else showSnackbar("Cannot close: task running.", "warning"); }} size="small" disabled={chainState.isRunning && !chainState.isPaused && !isDecomposingTask} aria-label="Close task editor"><Typography>❌</Typography></IconButton>
                    </span>
                  </Tooltip>
              </DialogTitle>
              <DialogContent dividers sx={{ display: 'flex', flexDirection: 'column', flexGrow: 1, overflowY: 'auto', p: theme.spacing(1.5), bgcolor: isDarkMode ? theme.palette.background.default : theme.palette.background.paper }}>

                  {/* Top section (Workspaces, Task Goal, Plan) */}
                  <Grid container spacing={1.5} sx={{ mb: 1.5, flexShrink: 0, minHeight: {xs: 'auto', md: '300px'}, height: 'auto' /* Let content define height */}}>
                      {/* Internal Mini-Chain Workspace Column */}
                      <Grid item xs={12} md={4} sx={{ display: 'flex', flexDirection: 'column', height: '100%', minHeight: '280px' /* Ensure some min height */ }}>
                          <WstmInternalMiniChainPreviewPanel
                            internalWorkspaces={internalWorkspaces}
                            onWorkspaceItemChange={onInternalWorkspaceItemChange}
                            showSnackbar={showSnackbar}
                            onRenameFile={handleRenameInternalFile}
                            onDuplicateFile={handleDuplicateInternalFile}
                            onDeleteFile={handleDeleteInternalFile} // Pass delete handler
                           />
                          {!isExplainMode && (
                            <Box display="flex" gap={0.5} mt={0.5} flexWrap="wrap" sx={{flexShrink: 0}}>
                                <Tooltip title={disableChainControls ? "Controls disabled" : "Add new file to internal workspace"}>
                                  <span>
                                    <Button size="small" variant="outlined" onClick={handleAddInternalFile} disabled={disableChainControls} sx={{ fontSize: '0.7rem', p: '2px 6px' }}>+ Add File</Button>
                                  </span>
                                </Tooltip>
                                {/* Contextual delete is now on each file item in WstmInternalMiniChainPreviewPanel */}
                            </Box>
                          )}
                      </Grid>

                      {/* Overall Task / Goal Column */}
                      <Grid item xs={12} md={4} sx={{ display: 'flex', flexDirection: 'column', height: '100%', minHeight: '280px' }}>
                          <TextField
                            id="wstm-overall-task-prompt-input"
                            name="wstmOverallTaskPromptName"
                            label="Overall Task / Goal for Mini-Chain"
                            multiline
                            variant="outlined" fullWidth value={overallTaskPrompt}
                            onChange={(e) => setOverallTaskPrompt(e.target.value)}
                            sx={{ flexGrow: 1, '& .MuiInputBase-root': { height: '100%', display: 'flex', flexDirection: 'column' }, '& .MuiInputBase-inputMultiline': { flexGrow: 1, overflowY: 'auto !important', fontSize: '0.9rem' } }}
                            disabled={disableChainControls || isExplainMode} helperText={`~${Math.ceil((overallTaskPrompt || "").length / 4)} est. tokens`} />
                          {!isExplainMode &&
                            <Tooltip title={disableChainControls ? "Controls disabled" : (!overallTaskPrompt.trim() ? "Enter task prompt first" : "Suggest steps using a planner agent")}>
                              <span style={{display:'block', width: '100%'}}>
                                <Button fullWidth variant="outlined" onClick={handleAutoDecomposeTask} disabled={disableChainControls || !overallTaskPrompt.trim() || (!activeAgents || activeAgents.length === 0)} sx={{ mt: 1, fontSize: '0.8rem', flexShrink: 0 }} startIcon={isDecomposingTask ? <CircularProgress size={16} /> : null}>Suggest Steps (Planner)</Button>
                              </span>
                            </Tooltip>
                          }
                      </Grid>

                      {/* Execution Plan (Conceptual) Column */}
                      <Grid item xs={12} md={4} sx={{ display: 'flex', flexDirection: 'column', height: '100%', minHeight: '280px' }}>
                          <Paper variant="outlined" sx={{ p: 1, flexGrow: 1, display: 'flex', flexDirection: 'column', minHeight: 0 }}>
                              <Typography variant="subtitle1" sx={{ fontWeight: 'medium', fontSize: '0.95rem', flexShrink: 0 }}>Execution Plan (Conceptual):</Typography>
                              <Box display="flex" gap={0.5} alignItems="center" mb={0.5} flexWrap="wrap" sx={{flexShrink: 0}}>
                                  <FormControl size="small" sx={{ minWidth: 130, flexGrow: 1 }}>
                                    <InputLabel id={orchestratorForPlanLabelId} htmlFor="wstm-orchestrator-plan-select">Orchestrator for Plan</InputLabel>
                                    <Select
                                        labelId={orchestratorForPlanLabelId}
                                        id="wstm-orchestrator-plan-select"
                                        name="wstmOrchestratorSelectName"
                                        value={orchestratorForPlan ? getAgentIdentifierValueString(orchestratorForPlan) : ""}
                                        label="Orchestrator for Plan"
                                        sx={{ fontSize: '0.8rem' }}
                                        onChange={(e) => setOrchestratorForPlan(activeAgents.find(ag => getAgentIdentifierValueString(ag) === e.target.value) || null)}
                                        disabled={isGeneratingPlan || isDecomposingTask || !activeAgents || activeAgents.length === 0}
                                    >
                                        <MenuItem value="" sx={{ fontSize: '0.8rem' }}><em>(Select Agent)</em></MenuItem>
                                        {showAllAgentsForPlan && <ListSubheader sx={{fontSize:'0.7rem', fontWeight:'bold'}}>All Agents</ListSubheader>}
                                        {(showAllAgentsForPlan ? activeAgents : activeAgents.filter(a => a.type.includes("orchestrator") || a.role_description?.toLowerCase().includes("plan")))
                                          .map(ag => (<MenuItem key={getAgentIdentifierValueString(ag)} value={getAgentIdentifierValueString(ag)} sx={{ fontSize: '0.8rem' }}>{ag.name || `Port ${ag.port}`}</MenuItem>))}
                                    </Select>
                                  </FormControl>
                                  <Tooltip title={disableChainControls ? "Controls disabled" : (!orchestratorForPlan || !overallTaskPrompt.trim() ? "Select orchestrator and enter task prompt" : "Generate conceptual plan")}>
                                      <span>
                                          <Button
                                            id="wstm-generate-plan-btn-id"
                                            name="wstmGeneratePlanBtnName"
                                            size="small" variant="outlined" onClick={handleGeneratePlan}
                                            disabled={isGeneratingPlan || isDecomposingTask || !orchestratorForPlan || !overallTaskPrompt.trim() || isExplainMode}
                                            sx={{ fontSize: '0.7rem', p: '2px 6px' }}
                                            startIcon={isGeneratingPlan ? <CircularProgress size={14} color="inherit" /> : null}
                                          >
                                            Gen Plan
                                          </Button>
                                      </span>
                                  </Tooltip>
                              </Box>
                               <FormControlLabel
                                control={<Switch checked={showAllAgentsForPlan} onChange={(e) => setShowAllAgentsForPlan(e.target.checked)} size="small" />}
                                label={<Typography variant="caption">Show all agents for plan</Typography>}
                                sx={{ flexShrink: 0, mb: 0.5, ml: -1 }}
                                disabled={isGeneratingPlan || isDecomposingTask || !activeAgents || activeAgents.length === 0}
                               />
                              <Box component="pre" sx={{ whiteSpace: 'pre-wrap', flexGrow: 1, overflowY: 'auto', background: isDarkMode ? 'rgba(255,255,255,0.05)' : 'grey.50', p: 0.5, borderRadius: 1, fontSize: '0.7rem', minHeight: '50px' }}>{planText || "(Plan will appear here after generation)"}</Box>
                          </Paper>
                      </Grid>
                  </Grid>

                  {/* Mini-Chain Steps Definition Section */}
                  <Paper variant="outlined" sx={{p:1.5, flexShrink: 0, mb: 1.5, borderColor: theme.palette.divider}}>
                    <Typography variant="h6" gutterBottom sx={{ fontSize: '1.1rem', color: isDarkMode ? theme.palette.text.primary : theme.palette.primary.main }}>Mini-Chain Steps Definition:</Typography>
                    {!isExplainMode &&
                     <React.Fragment>
                        <Grid container spacing={1} alignItems="flex-start" sx={{ mb: 1 }}>
                            <Grid item xs={12} sm="auto">
                                <Tooltip title={disableChainControls ? "Controls disabled" : "Add a new step to the chain"}>
                                <span>
                                    <Button variant="outlined" startIcon={<Typography sx={{ fontSize: '0.9rem' }}>+</Typography>} onClick={() => addMiniStep()} size="small" disabled={disableChainControls} sx={{ fontSize: '0.8rem' }}>Add Step</Button>
                                </span>
                                </Tooltip>
                            </Grid>
                            <Grid item xs={12} sm>
                                <FormControl size="small" fullWidth>
                                    <InputLabel id={contextStrategyLabelId} htmlFor="wstm-context-strategy-select">Context Strategy</InputLabel>
                                    <Select
                                        labelId={contextStrategyLabelId}
                                        id="wstm-context-strategy-select"
                                        name="wstmContextStrategySelectName"
                                        value={contextStrategy} label="Context Strategy" sx={{ fontSize: '0.8rem' }}
                                        onChange={e => setContextStrategy(e.target.value)} disabled={disableChainControls}>
                                        {Object.values(WSTM_CONTEXT_STRATEGY).map(csVal => <MenuItem key={csVal} value={csVal} sx={{ fontSize: '0.8rem' }}>{csVal}</MenuItem>)}
                                    </Select>
                                </FormControl>
                            </Grid>
                        </Grid>
                        {/* Template Management - Row 1 */}
                        <Grid container spacing={1} alignItems="center" sx={{ mb: 1 }}>
                            <Grid item xs={12} sm={6} md>
                                <TextField id="wstm-template-name-input-id" name="wstmTemplateNameInputName" label="Template Name" size="small" fullWidth value={selectedChainTemplateName} onChange={e => setSelectedChainTemplateName(e.target.value)} disabled={disableChainControls} sx={{ '& .MuiInputBase-input': { fontSize: '0.8rem' } }} InputLabelProps={{ style: { fontSize: '0.8rem' } }} />
                            </Grid>
                            <Grid item xs={6} sm={3} md="auto">
                                <Tooltip title={disableChainControls ? "Controls disabled" : (!selectedChainTemplateName.trim() ? "Enter template name to save" : "Save current steps as template")}>
                                <span>
                                    <Button fullWidth variant="outlined" onClick={handleSaveChainTemplate} size="small" disabled={disableChainControls || !selectedChainTemplateName.trim()} sx={{ fontSize: '0.8rem' }}>Save</Button>
                                </span>
                                </Tooltip>
                            </Grid>
                            <Grid item xs={6} sm={3} md>
                              <FormControl size="small" fullWidth>
                                <InputLabel id={loadTemplateLabelId} htmlFor="wstm-load-template-select">Load Template</InputLabel>
                                <Select
                                    labelId={loadTemplateLabelId}
                                    id="wstm-load-template-select"
                                    name="wstmLoadTemplateSelectName"
                                    value={chainTemplates.find(t => t.name === selectedChainTemplateName)?.name || ""}
                                    label="Load Template" // Ensures label is present for notch effect
                                    onChange={e => handleLoadChainTemplate(e.target.value)}
                                    disabled={disableChainControls || chainTemplates.length === 0}
                                    displayEmpty // Crucial: allows label to shrink even if value is ""
                                    renderValue={(selected) => {
                                        if (selected.length === 0) {
                                            return ""; // CHANGED: Return an empty string to hide the placeholder
                                        }
                                        // When a value is selected, display it (adjust font if needed for selected items)
                                        const selectedTemplate = chainTemplates.find(t => t.name === selected);
                                        const selectedValueStyle = { fontSize: '0.75rem', lineHeight: '1.4' }; // Style for selected text if needed
                                        return <span style={selectedValueStyle}>{selectedTemplate ? selectedTemplate.name : selected}</span>;
                                    }}
                                    // sx prop on Select itself can style the overall box if needed,
                                    // but renderValue now controls the displayed content.
                                    // Example: sx={{ '& .MuiSelect-select': { fontSize: '0.75rem' } }} if selected values also need this size.
                                >
                                    {/* The first MenuItem is what appears in the dropdown for "empty" selection.
                                        It can still have the placeholder text for UX within the dropdown. */}
                                    <MenuItem value="" sx={{ fontSize: '0.75rem', fontStyle: 'italic', opacity: 0.7 }}>
                                        (Select Saved Template)
                                    </MenuItem>
                                    {chainTemplates.map(t => (
                                        <MenuItem key={t.name} value={t.name} sx={{ fontSize: '0.75rem' }}>
                                            {t.name}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                            </Grid>
                        </Grid>
                         {/* Template Management - Row 2 */}
                        <Grid container spacing={1} alignItems="center" sx={{ mb: 1 }}>
                            <Grid item xs={6} sm="auto">
                                <Tooltip title={disableChainControls ? "Controls disabled" : ((!selectedChainTemplateName.trim() && miniChainSteps.length === 0) ? "Select or define a template to export" : "Export selected/current template")}>
                                <span>
                                    <Button fullWidth variant="outlined" onClick={handleExportChainTemplate} size="small" disabled={disableChainControls || (!selectedChainTemplateName.trim() && miniChainSteps.length === 0)} sx={{ fontSize: '0.8rem' }}>Export Template</Button>
                                </span>
                                </Tooltip>
                            </Grid>
                            <Grid item xs={6} sm="auto">
                                <Tooltip title={disableChainControls ? "Controls disabled" : "Import chain template from file"}>
                                <span>
                                    <Button component="label" htmlFor="wstm-import-template-file-input-id" fullWidth variant="outlined" size="small" disabled={disableChainControls} sx={{ fontSize: '0.8rem' }}>
                                        Import Template
                                        <input type="file" id="wstm-import-template-file-input-id" name="wstmImportTemplateFileInputName" aria-label="Import chain template file" accept=".json" hidden onChange={handleImportChainTemplate} />
                                    </Button>
                                </span>
                                </Tooltip>
                            </Grid>
                        </Grid>
                     </React.Fragment>
                    }

                    {/* Mini-Chain Steps List - has its own scroll */}
                    <Box sx={{ maxHeight: isExplainMode ? 'calc(80vh - 400px)' : '220px', overflowY: 'auto', mb: 1.5, p: 0.5, border: `1px solid ${theme.palette.divider}`, borderRadius: 1 }}>
                        {miniChainSteps.length === 0 && !isExplainMode && (
                            <Typography variant="caption" sx={{ p:1, display:'block', textAlign:'center', color:'text.secondary'}}>
                                No steps defined. Click 'Add Step' or 'Suggest Steps'.
                            </Typography>
                        )}
                        {miniChainSteps.map((step, idx) => {
                            const isCurrentExecutingStep = chainState.isRunning && !chainState.isPaused && activeEnabledSteps.length > 0 && chainState.currentMiniStepIndex < activeEnabledSteps.length && activeEnabledSteps[chainState.currentMiniStepIndex].id === step.id;
                            return (
                                <div key={step.id} draggable={!disableChainControls && !isExplainMode} onDragStart={(e) => dragItem.current = idx} onDragEnter={(e) => dragOverItem.current = idx} onDragEnd={handleSortSteps} onDragOver={(e) => e.preventDefault()} style={{ cursor: (!disableChainControls && !isExplainMode) ? 'grab' : 'default' }}>
                                    <WstmMiniChainStepItem
                                        step={step} idx={idx} miniChainSteps={miniChainSteps} activeAgents={activeAgents}
                                        suggestedAgents={suggestedAgentsForCurrentStepUI} isCurrentExecutingStep={isCurrentExecutingStep}
                                        isRunning={chainState.isRunning} isDecomposingTask={isDecomposingTask} isExplainMode={isExplainMode}
                                        theme={theme} isDarkMode={isDarkMode} handleMiniStepChange={handleMiniStepChange}
                                        moveMiniStep={moveMiniStep} removeMiniStep={removeMiniStep} addMiniStep={addMiniStep}
                                        handleToggleStepEnabled={handleToggleStepEnabled} isDryRunMode={chainState.isDryRunMode}
                                        stepExecutionProgress={currentStepExecutionProgress}
                                    />
                                </div>
                            );
                        })}
                    </Box>
                    {!isExplainMode && (
                        <Box display="flex" gap={1} alignItems="center" flexWrap="wrap" sx={{mb:1}}>
                            <FormControlLabel control={<Switch checked={enableProactiveRetries} onChange={(e) => setEnableProactiveRetries(e.target.checked)} size="small" id="wstm-enable-proactive-retries-switch-id" name="wstmEnableProactiveRetriesName" disabled={disableChainControls}/>} label={<Typography variant="caption">Enable Proactive Agent Retries</Typography>} />
                            <FormControlLabel control={<Switch checked={autoExecuteTermCmds} onChange={(e) => setAutoExecuteTermCmds(e.target.checked)} size="small" id="wstm-auto-execute-term-cmds-switch-id" name="wstmAutoExecuteTermCmdsName" disabled={disableChainControls}/>} label={<Typography variant="caption">Auto-execute Terminal CMDs</Typography>} />
                        </Box>
                    )}
                  </Paper>

                  {/* Mini-Chain Logs Section - grows to fill space, has its own scroll */}
                  <Box sx={{ display: 'flex', flexDirection: 'column', flexGrow: 1, minHeight: '150px' /* Ensure logs area always has some space */ }}>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mt: 1, flexShrink: 0 }}>
                          <Typography variant="h6" gutterBottom sx={{ fontSize: '1.1rem', color: isDarkMode ? theme.palette.text.primary : theme.palette.primary.main, mb: 0 }}>
                            Mini-Chain Logs:
                            <Tooltip title="Export logs">
                              <span>
                                <IconButton size="small" onClick={handleExportLogs} sx={{ ml: 0.5 }} disabled={chainState.miniChainLogs.length === 0} aria-label="Export mini-chain logs"><Typography sx={{ fontSize: '0.9rem' }}>💾</Typography></IconButton>
                              </span>
                            </Tooltip>
                          </Typography>
                          <FormControlLabel control={<Switch checked={autoScrollLogs} onChange={(e) => setAutoScrollLogs(e.target.checked)} size="small" id="wstm-auto-scroll-logs-switch-id" name="wstmAutoScrollLogsSwitchName" inputProps={{'aria-label': 'Auto-scroll logs'}} />} label={<Typography variant="caption">Auto-scroll</Typography>} sx={{ mr: 0 }}/>
                      </Box>
                      <Box className="auto-run-logs" sx={{ flexGrow: 1, background: isDarkMode ? 'rgba(255,255,255,0.05)' : 'grey.50', border: `1px solid ${theme.palette.divider}`, borderRadius: 1, overflowY: 'auto', p: 1 }}>
                          {chainState.miniChainLogs.map((msg, idx) => {
                            const isAgentMessage = msg.role !== "User" && msg.role !== "System" && msg.role !== "system" && !msg.isContextSnapshot;
                            const isSystemMessage = msg.role === "System" || msg.role === "system" || msg.isContextSnapshot;
                            const bubbleColor = isSystemMessage ? (isDarkMode ? 'rgba(70,70,70,0.5)' : '#e0e0e0') : (isDarkMode ? theme.palette.background.level1 : theme.palette.grey[50]);
                            const textColor = isSystemMessage ? theme.palette.text.secondary : theme.palette.text.primary;
                              return (<Box key={idx} className="chat-msg" sx={{ mb: 0.5, textAlign: 'left' }}>
                                <Paper elevation={0} sx={{ p: 0.75, display: 'inline-block', maxWidth: '98%', bgcolor: bubbleColor, color: textColor, borderRadius: '8px', border: msg.status === 'warning' ? (isDarkMode ? '1px solid orange' : '1px solid #ffc107') : (msg.status === 'error' ? (isDarkMode ? '1px solid red' : '1px solid #d32f2f') : 'none'), opacity: msg.status === 'sending' ? 0.7 : 1 }}>
                                  <Typography variant="caption" display="block" sx={{ fontWeight: 'bold', color: isAgentMessage ? (isDarkMode ? theme.palette.secondary.light : theme.palette.secondary.main) : theme.palette.text.disabled }}>
                                    {msg.role} {msg.status === 'sending' ? '(Sending...)' : msg.status === 'warning' ? '(Warning)' : (msg.status === 'error' ? '(Error)' : '')}
                                  </Typography>
                                  <ChatMessageContent rawContent={msg.content} role={msg.role} isDarkMode={isDarkMode} /> {/* Assumed global or imported */}
                                </Paper>
                              </Box>);
                          })}
                          <div ref={miniChainLogsEndRef} /> {/* For auto-scrolling */}
                          {chainState.miniChainLogs.length === 0 && <Typography variant="caption" sx={{ p:1, color: 'text.secondary', textAlign:'center', display:'block' }}>(Logs will appear here)</Typography>}
                      </Box>
                  </Box>
              </DialogContent>
              {/* DialogActions: Bottom controls */}
              <DialogActions sx={{ p: '8px 12px', justifyContent: 'space-between', borderTop: `1px solid ${theme.palette.divider}`, bgcolor: isDarkMode ? theme.palette.background.level1 : theme.palette.grey[100], flexWrap: 'wrap', gap: 1, flexShrink: 0 }}>
                  {/* Left Group: Close, Clear Cache, Dry Run */}
                  <Box display="flex" alignItems="center" gap={0.5} flexWrap="wrap">
                    <Tooltip title={(chainState.isRunning && !chainState.isPaused && !isDecomposingTask) ? "Cannot close while task is actively running (pause first)" : "Cancel and close the task editor"}>
                        <span>
                          <Button onClick={() => { if (!chainState.isRunning && !isDecomposingTask) onClose(); else showSnackbar("Cannot close: task running.", "warning"); }} disabled={chainState.isRunning && !chainState.isPaused && !isDecomposingTask} color="inherit" size="small">Cancel/Close</Button>
                        </span>
                    </Tooltip>
                    <Tooltip title={disableChainControls ? "Controls disabled" : "Clear cached state for this modal context"}>
                      <span>
                        <Button onClick={handleClearCachedState} color="warning" size="small" disabled={disableChainControls}>Clear Cache</Button>
                      </span>
                    </Tooltip>
                    <FormControlLabel
                        control={<Switch checked={chainState.isDryRunMode} onChange={(e) => dispatchChainAction({type: WSTM_CHAIN_ACTION_TYPES.SET_DRY_RUN_MODE, payload: { isDryRun: e.target.checked }})} size="small" id="wstm-dry-run-switch-id" name="wstmDryRunSwitchName" inputProps={{'aria-label': 'Toggle dry run mode'}} />}
                        label={<Typography variant="caption">Dry Run</Typography>} sx={{ml:1, flexShrink:0}} disabled={chainState.isRunning} />
                  </Box>
                  {/* Right Group: Run/Pause/Stop, Auto-Apply, Review & Apply */}
                  <Box display="flex" gap={1} alignItems="center" flexWrap="wrap" justifyContent="flex-end">
                      <FormControlLabel control={<Switch checked={autoApplyChanges} onChange={(e) => setAutoApplyChanges(e.target.checked)} size="small" id="wstm-auto-apply-switch-id" name="wstmAutoApplySwitchName" disabled={disableChainControls || isExplainMode}/>} label={<Typography variant="caption">Auto-Apply</Typography>} sx={{flexShrink:0}} />
                      {!chainState.isRunning && (
                        <Tooltip title={miniChainSteps.filter(s => s.isEnabled).length === 0 ? "No enabled steps" : (miniChainSteps.filter(s => s.isEnabled).some(s => !s.agentIdentifierObj) ? "Assign agents to all enabled steps" : (!overallTaskPrompt.trim() ? "Enter task prompt" : "Run the defined mini-chain"))}>
                          <span>
                            <Button variant="contained" color="primary" onClick={handleRunMiniChain} disabled={miniChainSteps.filter(s => s.isEnabled).length === 0 || miniChainSteps.filter(s => s.isEnabled).some(s => !s.agentIdentifierObj) || !overallTaskPrompt.trim() || isDecomposingTask} size="small"> Run Chain </Button>
                          </span>
                        </Tooltip>
                      )}
                      {chainState.isRunning && !chainState.isPaused && !chainState.isAwaitingUserInput && (<Button variant="contained" color="warning" onClick={handlePauseMiniChain} size="small" sx={{flexShrink:0}}>Pause</Button>)}
                      {chainState.isRunning && (chainState.isPaused || chainState.isAwaitingUserInput) && (<Button variant="contained" color="success" onClick={handleResumeMiniChain} size="small" disabled={chainState.isAwaitingUserInput} sx={{flexShrink:0}}>Resume</Button>)}
                      {chainState.isRunning && (
                        <Tooltip title="Stop the current mini-chain execution">
                            <Button variant="outlined" color="error" onClick={() => handleStopMiniChain("User")} size="small" sx={{flexShrink:0}}>Stop</Button>
                        </Tooltip>
                      )}
                      {(chainState.isRunning || isDecomposingTask) && <CircularProgress size={20} color="inherit" sx={{ ml: 0.5, flexShrink:0 }} />}
                      {(!isExplainMode &&
                        <Tooltip title={disableApplyButtons ? "Controls disabled" : ( (internalWorkspaces.filter(f => f.id !== WSTM_SCRATCHPAD_FILE_ID).every(ws => { const originalContent = originalFileContentsMap[ws.id]; return (originalContent && originalContent === ws.content) || (ws.type === 'text_selection_context' && ws.content === initialContext?.content) || (!originalContent && ws.content.trim() === ""); }) && internalWorkspaces.filter(f => f.id !== WSTM_SCRATCHPAD_FILE_ID).length === Object.keys(originalFileContentsMap).length) ? "No changes to review" : autoApplyChanges ? "Automatically apply all changes made by the mini-chain" : "Review changes before applying them to your workspace")}>
                          <span>
                            <Button
                              variant="contained"
                              color="success"
                              onClick={() => prepareChangesAndApply(autoApplyChanges)} // Call unified function
                              disabled={disableApplyButtons || (internalWorkspaces.filter(f => f.id !== WSTM_SCRATCHPAD_FILE_ID).every(ws => { const originalContent = originalFileContentsMap[ws.id]; return (originalContent && originalContent === ws.content) || (ws.type === 'text_selection_context' && ws.content === initialContext?.content) || (!originalContent && ws.content.trim() === ""); }) && internalWorkspaces.filter(f => f.id !== WSTM_SCRATCHPAD_FILE_ID).length === Object.keys(originalFileContentsMap).length)}
                              size="small"
                              sx={{flexShrink:0}}
                            >
                              {autoApplyChanges ? 'Auto-Apply Changes' : 'Review & Apply'}
                            </Button>
                          </span>
                        </Tooltip>
                      )}
                      {isExplainMode && !chainState.isRunning && chainState.miniChainLogs.length > 0 && (
                          <Tooltip title="Copy explanation to clipboard">
                            <Button
                                variant="contained"
                                color="info"
                                size="small"
                                onClick={() => {
                                    const explanationLog = chainState.miniChainLogs.find(log => log.role !== "System" && log.role !== "User");
                                    if (explanationLog && explanationLog.content) {
                                        navigator.clipboard.writeText(explanationLog.content)
                                            .then(() => showSnackbar("Explanation copied to clipboard!", "success"))
                                            .catch(err => showSnackbar("Failed to copy explanation: " + err.message, "error"));
                                    } else {
                                        showSnackbar("No explanation found in logs to copy.", "warning");
                                    }
                                }}
                            >
                                Copy Explanation
                            </Button>
                          </Tooltip>
                      )}
                  </Box>
              </DialogActions>
          </Dialog>

          {/* Diff Review Dialog */}
          {showDiffReview && !isExplainMode && (
              <Dialog open={showDiffReview} onClose={handleCancelDiffReview} maxWidth="xl" fullWidth scroll="paper">
                  <DialogTitle className={isDarkMode ? 'heading-glow' : ''} sx={{ bgcolor: isDarkMode ? theme.palette.background.level1 : theme.palette.grey[100], borderBottom: `1px solid ${theme.palette.divider}` }}>Review & Accept Changes</DialogTitle>
                  <DialogContent dividers sx={{ p: 2, bgcolor: isDarkMode ? theme.palette.background.default : theme.palette.background.paper }}>
                      <Alert severity="info" sx={{ mb: 2 }}>Review changes. Toggle to accept/reject. Only accepted changes apply.</Alert>
                      <Typography variant="subtitle1" gutterBottom sx={{ fontWeight: 'bold' }}>Overall Explanation Snippet:</Typography>
                      <Paper variant="outlined" sx={{ p: 1.5, mb: 3, background: isDarkMode ? 'rgba(255,255,255,0.05)' : 'grey.50', border: `1px solid ${theme.palette.divider}`, maxHeight: '150px', overflowY: 'auto' }}>
                        <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap' }}>{wstmExtractOverallExplanationFromLogs(chainState.miniChainLogs) || (changesForDiff.length > 0 && changesForDiff[0].explanation) || "No overall explanation. Review individual items."}</Typography>
                      </Paper>
                      {changesForDiff.length === 0 ? (<Typography>No file changes proposed.</Typography>) : (changesForDiff.map((change, idx) => (
                        <Paper key={change.fileId + "_" + idx} variant="outlined" sx={{ mb: 2.5, borderColor: theme.palette.divider }}>
                          <Box sx={{ p: 1.5, background: isDarkMode ? theme.palette.background.level2 : theme.palette.grey[200], borderBottom: `1px solid ${theme.palette.divider}`, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Typography variant="subtitle1" sx={{ fontWeight: 'medium' }}>
                              {change.isNew ? "NEW: " : "MOD: "} {change.title || change.fileId}
                            </Typography>
                            <FormControlLabel
                                control={<Switch checked={change.accepted} onChange={() => setChangesForDiff(prev => prev.map((c, i) => i === idx ? { ...c, accepted: !c.accepted } : c))} id={`wstm-diff-accept-switch-id-${change.fileId}-${idx}`} name={`wstmDiffAcceptSwitchName_${change.fileId}_${idx}`} inputProps={{'aria-label': `Accept changes for ${change.title || change.fileId}`}} />}
                                label={change.accepted ? "Accept" : "Reject"}
                                labelPlacement="start"
                            />
                          </Box>
                          {change.explanation && (<Box sx={{ p: 1.5, background: isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(200,200,255,0.1)', borderBottom: `1px solid ${theme.palette.divider}` }}><Typography variant="body2" sx={{ fontWeight: 'bold' }}>Agent's Explanation:</Typography><Typography variant="caption" component="pre" sx={{ whiteSpace: 'pre-wrap', display: 'block', mt: 0.5, maxHeight: '120px', overflowY: 'auto', color: 'text.secondary' }}>{change.explanation}</Typography></Box>)}
                          <Box sx={{ maxHeight: '60vh', overflowY: 'auto', fontFamily: 'monospace', fontSize: '0.8rem' }}>{diffUsingJsDiff(change.oldContent, change.newContent).map((part, partIdx) => (<Box component="span" key={partIdx} className={`diff-line ${part.added ? 'diff-added' : part.removed ? 'diff-removed' : 'diff-common'}`} sx={{ display: 'block', whiteSpace: 'pre-wrap', fontFamily: 'monospace', bgcolor: part.added ? (isDarkMode ? 'rgba(0,255,0,0.1)' : '#e6ffed') : part.removed ? (isDarkMode ? 'rgba(255,0,0,0.1)' : '#ffeef0') : 'transparent', color: part.added ? (isDarkMode ? '#a5d6a7' : '#2e7d32') : part.removed ? (isDarkMode ? '#ef9a9a' : '#c62828') : 'inherit', pl: 1, borderLeft: part.added ? `3px solid ${theme.palette.success.main}` : part.removed ? `3px solid ${theme.palette.error.main}` : '3px solid transparent', }}>{part.text || (part.type === "added" || part.type === "removed" ? " " : "")}</Box>))}</Box>
                        </Paper>
                      )))}
                  </DialogContent>
                  <DialogActions sx={{ p: 2, borderTop: `1px solid ${theme.palette.divider}`, bgcolor: isDarkMode ? theme.palette.background.level1 : theme.palette.grey[100] }}>
                    <Button onClick={handleCancelDiffReview}>Cancel All & Discard</Button>
                    <Tooltip title={changesForDiff.filter(c => c.accepted).length === 0 ? "No changes selected to apply" : `Apply ${changesForDiff.filter(c => c.accepted).length} accepted changes`}>
                      <span>
                        <Button onClick={() => handleConfirmApplyChangesFromDiff()} variant="contained" color="primary" disabled={changesForDiff.filter(c => c.accepted).length === 0}>Apply Accepted ({changesForDiff.filter(c => c.accepted).length})</Button>
                      </span>
                    </Tooltip>
                  </DialogActions>
              </Dialog>
          )}

          <WstmUserInputDialog
              open={chainState.isAwaitingUserInput}
              title="User Input Required"
              message={chainState.userInputPrompt}
              onSubmit={handleUserInputSubmit}
              onCancel={handleUserInputCancel}
          />

          <Dialog open={showFeedbackDialog} onClose={handleSkipFeedback} maxWidth="sm" fullWidth>
              <DialogTitle sx={{ bgcolor: isDarkMode ? theme.palette.background.level1 : theme.palette.grey[100], borderBottom: `1px solid ${theme.palette.divider}` }}>
                <Typography className={isDarkMode ? 'heading-glow' : ''} sx={{typography: 'h6'}}>Provide Feedback on Mini-Chain Output</Typography>
              </DialogTitle>
              <DialogContent sx={{ p: 2, bgcolor: isDarkMode ? theme.palette.background.default : theme.palette.background.paper }}>
                  <Typography id="wstm-feedback-rating-label-id" gutterBottom>How would you rate the overall quality of the mini-chain's output for this task?</Typography>
                  <Rating
                    id="wstm-feedback-rating-input-id"
                    name="wstmFeedbackRatingName"
                    value={feedbackData.rating}
                    onChange={(event, newValue) => { setFeedbackData(prev => ({ ...prev, rating: newValue || 0 })); }}
                    sx={{ mb: 2 }}
                    aria-labelledby="wstm-feedback-rating-label-id"
                  />
                  <TextField
                    id="wstm-feedback-comments-input-id"
                    name="wstmFeedbackCommentsName"
                    label="Optional comments (e.g., what was good/bad, suggestions)"
                    multiline minRows={3} fullWidth
                    value={feedbackData.comments}
                    onChange={(e) => setFeedbackData(prev => ({ ...prev, comments: e.target.value }))}
                    variant="outlined" sx={{ mt: 2 }} />
              </DialogContent>
              <DialogActions sx={{ p: 2, borderTop: `1px solid ${theme.palette.divider}`, bgcolor: isDarkMode ? theme.palette.background.level1 : theme.palette.grey[100] }}>
                <Button onClick={handleSkipFeedback}>Skip & Close</Button>
                <Tooltip title={(feedbackData.rating === 0 && !feedbackData.comments.trim()) ? "Provide a rating or comments to submit" : "Submit feedback"}>
                    <span>
                      <Button onClick={handleFeedbackSubmit} variant="contained" color="primary" disabled={feedbackData.rating === 0 && !feedbackData.comments.trim()}>Submit Feedback</Button>
                    </span>
                </Tooltip>
              </DialogActions>
          </Dialog>
      </React.Fragment>
  );
}
